<!doctype html><html class="no-js" lang="en" dir="ltr"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="theme-color" content="#15a"><title>Stop Typing: The .NET CLI Tab Completion You've Been Missing — Daily DevOps & .NET</title><meta name="description" content="One command to transform your .NET CLI workflow—tab completion so responsive you&rsquo;ll wonder how you survived without it
Finally, a productivity boost …"><meta name="twitter:description" property="og:description" content="One command to transform your .NET CLI workflow—tab completion so responsive you&rsquo;ll wonder how you survived without it
Finally, a productivity boost …"><meta name="author" content="Martin Stühmer"><link rel="icon" href="/logo.svg?v=b9e294dc5c6fa04439c8c803d8e981a9" sizes="any" type="image/svg+xml"><meta name="twitter:title" property="og:title" content="Stop Typing: The .NET CLI Tab Completion You've Been Missing — Daily DevOps & .NET"><meta property="og:updated_time" content="2025-12-18T17:19:17+01:00"><meta property="article:modified_time" content="2025-12-18T17:19:17+01:00"><meta property="article:published_time" content="2025-12-18T17:00:00+01:00"><meta property="og:type" content="article"><meta property="og:site_name" content="Daily DevOps & .NET"><meta property="og:url" content="https://daily-devops.net/posts/dotnet-cli-expanding-scope-autocomplete/"><meta property="og:locale" content="en_US"><meta name="twitter:card" content="summary_large_image"><meta property="og:image" name="twitter:image" content="https://daily-devops.net/images/cli-1200x630.webp?v=f1c2870b0ac825fad6ebc8ac4a1f2368"><meta property="og:image:secure_url" content="https://daily-devops.net/images/cli-1200x630.webp?v=f1c2870b0ac825fad6ebc8ac4a1f2368"><meta property="og:image:alt" name="twitter:image:alt" content="Stop Typing: The .NET CLI Tab Completion You've Been Missing"><meta property="og:image:type" content="image/webp"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta property="og:image" name="twitter:image" content="https://daily-devops.net/images/cli-1200x630.png?v=ff2b9271110e030dbfaf200a81fa89a5"><meta property="og:image:secure_url" content="https://daily-devops.net/images/cli-1200x630.png?v=ff2b9271110e030dbfaf200a81fa89a5"><meta property="og:image:alt" name="twitter:image:alt" content="Stop Typing: The .NET CLI Tab Completion You've Been Missing"><meta property="og:image:type" content="image/png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><link rel="dns-prefetch" href="https://www.clarity.ms"><link rel="preconnect" href="https://www.clarity.ms" crossorigin><link rel="stylesheet" href="/css/style.min.0a82b1a011c427b8ad7101f4d2af27d8fdb035d1938344df11bd53b8ee18381e7feaff6dda5dc3769214cc3fd8070373bdaf19c5e92f9a772e2769a03ac862cc.css" integrity="sha512-CoKxoBHEJ7itcQH00q8n2P2wNdGTg0TfEb1TuO4YOB5/6v9t2l3DdpIUzD/YBwNzva8ZxekvmncuJ2mgOshizA==" crossorigin="anonymous"><link rel="alternate" href='https://daily-devops.net/posts/dotnet-cli-expanding-scope-autocomplete/' hreflang="x-default" title="Stop Typing: The .NET CLI Tab Completion You've Been Missing &mdash; Daily DevOps & .NET"><link rel="canonical" href="https://daily-devops.net/posts/dotnet-cli-expanding-scope-autocomplete/" hreflang="en-us" title="Stop Typing: The .NET CLI Tab Completion You've Been Missing &mdash; Daily DevOps & .NET"><link rel="home" href="https://daily-devops.net/" hreflang="en-us" title="Daily DevOps & .NET"><link rel="next" href="https://daily-devops.net/posts/dotnet-advanced-logging/" hreflang="en-us" title="Why Your Logging Strategy Fails in Production"><link rel="prev" href="https://daily-devops.net/posts/dotnet-job-scheduling-7-comparative-review/" hreflang="en-us" title=".NET Job Scheduling — Choosing the Right Framework"><link rel="author" href="https://daily-devops.net/authors/martin/" hreflang="en-us" title="Martin Stühmer &mdash; Daily DevOps & .NET"><meta name="giscus:backlink" content="https://daily-devops.net/posts/dotnet-cli-expanding-scope-autocomplete/"><script defer src="/js/above.min.cb42b2c9a453e49e278326637d72d2f01e7f32e3f91e9cdde8fb587793d05514efd2f5cc5021c9658ca0f73876dbdcd1f7cb4a37c0bebc9df01110926b6d7cba.js" integrity="sha512-y0KyyaRT5J4ngyZjfXLS8B5/MuP5Hpzd6PtYd5PQVRTv0vXMUCHJZYyg9zh229zR98tKN8C+vJ3wERCSa218ug==" crossorigin="anonymous"></script><script type="text/javascript">(function(e,t,n,s,o,i,a){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)},i=t.createElement(s),i.async=1,i.src="https://www.clarity.ms/tag/"+o,a=t.getElementsByTagName(s)[0],a.parentNode.insertBefore(i,a)})(window,document,"clarity","script","o0pr4n9gg3")</script></head><body class="container"><header class="header"><a class="logo" href="/" title="Daily DevOps & .NET" rel="home"><figure class="page-logo"><picture><img src="/logo.svg?v=b9e294dc5c6fa04439c8c803d8e981a9" alt="Daily DevOps & .NET" title="Daily DevOps & .NET"></picture></figure><span class="title">Daily DevOps & .NET</span></a><nav class="menu"><button class="burger" aria-haspopup="true" aria-expanded="false" tabindex="0">
<i class="fas fa-burger"></i></button><ul class="navigation"><li class="active"><a href="/posts/">Posts</a></li><li><a href="/authors/">About us</a></li></ul></nav><div class="divider"></div></header><main class="body"><figure class="hero"><picture><source srcset="/images/cli-544x136.webp?v=b56f1d95d52c832d1eefb6ad95321b4b" type="image/webp" media="(max-width: 575.98px)"><source srcset="/images/cli-544x136.png?v=96d5a0dedf7867abbe1aa2e313ee2b9b" type="image/png" media="(max-width: 575.98px)"><source srcset="/images/cli-672x168.webp?v=0d04c546ccf44c990cce6cdc6f109cd7" type="image/webp" media="(max-width: 767.98px)"><source srcset="/images/cli-672x168.png?v=47a7ae99884adda9b9b4ad52afbbe98c" type="image/png" media="(max-width: 767.98px)"><source srcset="/images/cli-896x224.webp?v=cfa443d4e8a83c2dfa7d3a3f3bfda70b" type="image/webp" media="(max-width: 991.98px)"><source srcset="/images/cli-896x224.png?v=1ed446efaa6b341256d55722bd560290" type="image/png" media="(max-width: 991.98px)"><source srcset="/images/cli-1104x276.webp?v=4d91808bdbad9d949949875e68db9c35" type="image/webp" media="(max-width: 1199.98px)"><source srcset="/images/cli-1104x276.png?v=45b99363d29db43fdc1393f6463adeb8" type="image/png" media="(max-width: 1199.98px)"><source srcset="/images/cli-1444x361.webp?v=624c006b19da4c4fd07b628480786884" type="image/webp"><source srcset="/images/cli-1444x361.png?v=0fd5ca62ad024c28bf36e0e051e0763e" type="image/png"><img src="/images/cli.png?v=74daed50d0ea188d53fcad80f79e87ba" alt="Stop Typing: The .NET CLI Tab Completion You've Been Missing" loading="lazy" decoding="async" title="Stop Typing: The .NET CLI Tab Completion You've Been Missing"></picture></figure><article class="post"><header><h1>Stop Typing: The .NET CLI Tab Completion You&rsquo;ve Been Missing</h1></header><section class="content"><p>I&rsquo;ve watched developers, including myself, waste hundreds of hours on something completely avoidable. Not architecture decisions or complex algorithms—just typing. Specifically, typing the same <code>.NET CLI</code> commands over and over because they couldn&rsquo;t quite remember the exact syntax.</p><p>You&rsquo;ve probably done it yourself. You&rsquo;re about to add a NuGet package, you type <code>dotnet add package</code>, then you pause. Was it <code>Microsoft.Extensions.Logging</code> or <code>Microsoft.Extensions.Logging.Abstractions</code>? You open a browser tab, search NuGet.org, find the package, copy the name, switch back to your terminal, paste it. Fifteen seconds lost. Multiply that by dozens of commands daily.</p><p>That&rsquo;s not even counting the times you mistype a command and have to run it again. Or when you forget which flags <code>dotnet publish</code> supports and end up in <code>--help</code> documentation.</p><p>The <code>.NET CLI</code> has technically supported tab completion for years. But getting it to work? That meant diving into PowerShell documentation, copying <code>Register-ArgumentCompleter</code> snippets from Stack Overflow, debugging why it wouldn&rsquo;t load properly, then maintaining that brittle setup across machines. I tried it once on a project in 2021. Gave up after the third machine where it broke differently.</p><p>When <strong>.NET 10</strong> shipped in November 2025, Microsoft finally included what should&rsquo;ve been there from day one: native completion scripts. One command. That&rsquo;s it. No registration. No manual shell configuration. Just <code>dotnet completions script >> $PROFILE</code> and you&rsquo;re done.</p><p>I tested it the day the release dropped. Took me exactly 47 seconds from reading the release notes to having working completion. That&rsquo;s the kind of feature that makes you wonder why you tolerated the old way for so long.</p><h2 id="why-tab-completion-matters-more-than-you-think"><a href="/posts/dotnet-cli-expanding-scope-autocomplete/#why-tab-completion-matters-more-than-you-think" title="Why Tab Completion Matters (More Than You Think)">Why Tab Completion Matters (More Than You Think)</a></h2><p>Here&rsquo;s something I tracked for a week in October: I ran 847 <code>dotnet</code> commands. That&rsquo;s not an exceptional week—I was doing standard development work on four different projects. No CI/CD pipelines, no deployment scripts, just regular coding.</p><p>Of those 847 commands, 312 involved package names or project references. Before I enabled completion, I&rsquo;d estimate I spent 10-15 seconds per command hunting for exact names. With completion? Two seconds. Tab, confirm, done.</p><p>Do the math on that. Even at a conservative 10 seconds saved per operation, that&rsquo;s 3,120 seconds weekly. That&rsquo;s 52 minutes I&rsquo;m not spending on mechanical busywork. But here&rsquo;s what really matters: the cognitive load disappears.</p><p>You stop maintaining these useless mental indexes of syntax. I used to have <code>-c</code> vs <code>--configuration</code> memorized, along with whether it was <code>--framework</code> or <code>-f</code>, whether <code>publish</code> took <code>--output</code> or <code>-o</code>. Now? I type <code>dotnet publish -</code> and press Tab. The shell shows me everything available. I pick what I need.</p><p>Last month I discovered <code>dotnet workload repair</code> because it appeared in completion results. I&rsquo;d been manually reinstalling workloads when they broke. Turns out there&rsquo;s been a repair command since .NET 6. I just never knew because I never ran <code>dotnet --help</code> looking for it.</p><p>The modern <code>.NET CLI</code> does a lot more than most developers realize:</p><ul><li>It queries NuGet.org in real-time as you type package names. Type <code>dotnet add package Micro</code> and hit Tab—you&rsquo;ll see <code>Microsoft.Extensions.*</code> packages before you finish typing.</li><li>It understands your solution structure. In a multi-project solution, <code>dotnet add reference</code> will show you the actual project files available, not force you to remember paths.</li><li>Nested commands like <code>dotnet tool install</code> have their own completion contexts. The shell knows when you&rsquo;re specifying a tool name vs. a version vs. a configuration flag.</li><li>Some completions are context-aware. If you&rsquo;ve already specified <code>--framework net8.0</code>, subsequent completions adjust accordingly.</li></ul><p>The old approach—before <strong>.NET 10</strong>—worked but had a fundamental performance problem. Every tab press spawned a subprocess running <code>dotnet complete</code>. That means process initialization overhead, parsing your command context, generating suggestions, serializing results back to PowerShell, then rendering them.</p><p>I measured this once on a moderately powerful dev machine (Ryzen 7, NVMe SSD, 32GB RAM). Simple completions like <code>dotnet b[Tab]</code> took 80-120ms. Not terrible, but noticeable. Package completions that needed to query NuGet.org? 400-800ms depending on network latency.</p><p>The <strong>.NET 10</strong> approach is architecturally different. The completion script that gets written to your <code>$PROFILE</code> contains the entire static grammar—every command, subcommand, and standard flag—compiled into shell-native code. Your shell (PowerShell, Bash, Zsh) can evaluate that code instantly because there&rsquo;s no external process. It only invokes <code>dotnet complete</code> when you hit something dynamic like package names or project file paths. The difference is immediately perceptible. Completions feel instant because most of them actually are instant.</p><h2 id="the-evolution-from-dynamic-to-native-completion"><a href="/posts/dotnet-cli-expanding-scope-autocomplete/#the-evolution-from-dynamic-to-native-completion" title="The Evolution: From Dynamic to Native Completion">The Evolution: From Dynamic to Native Completion</a></h2><p>Understanding what changed in <strong>.NET 10</strong> gives context to why this matters.</p><h3 id="the-old-way-dynamic-completion-pre-net-10"><a href="/posts/dotnet-cli-expanding-scope-autocomplete/#the-old-way-dynamic-completion-pre-net-10" title="The Old Way: Dynamic Completion (Pre-.NET 10)">The Old Way: Dynamic Completion (Pre-.NET 10)</a></h3><p>For <code>.NET</code> versions before 10, if you wanted tab completion, you needed to register an argument completer in your PowerShell profile. The approach was straightforward but had overhead:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-pwsh" data-lang="pwsh"><span class="line"><span class="cl"><span class="c"># The legacy approach that still works</span>
</span></span><span class="line"><span class="cl"><span class="nb">Register-ArgumentCompleter</span> <span class="n">-Native</span> <span class="n">-CommandName</span> <span class="n">dotnet</span> <span class="n">-ScriptBlock</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">param</span><span class="p">(</span><span class="nv">$wordToComplete</span><span class="p">,</span> <span class="nv">$commandAst</span><span class="p">,</span> <span class="nv">$cursorPosition</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">dotnet</span> <span class="n">complete</span> <span class="p">-</span><span class="n">-position</span> <span class="nv">$cursorPosition</span> <span class="s2">&#34;</span><span class="nv">$commandAst</span><span class="s2">&#34;</span> <span class="p">|</span> <span class="nb">ForEach-Object</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="p">[</span><span class="no">System.Management.Automation.CompletionResult</span><span class="p">]::</span><span class="n">new</span><span class="p">(</span><span class="nv">$_</span><span class="p">,</span> <span class="nv">$_</span><span class="p">,</span> <span class="s1">&#39;ParameterValue&#39;</span><span class="p">,</span> <span class="nv">$_</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>This approach technically worked. But every Tab press meant PowerShell had to invoke <code>dotnet complete</code> as a subprocess, wait for it to parse your current command, generate completions, and return them. On my old laptop (circa 2019), this sometimes took long enough that I&rsquo;d press Tab, see nothing happen, assume completion wasn&rsquo;t working, and just finish typing manually.</p><h3 id="the-new-way-native-completions-net-10"><a href="/posts/dotnet-cli-expanding-scope-autocomplete/#the-new-way-native-completions-net-10" title="The New Way: Native Completions (.NET 10+)">The New Way: Native Completions (.NET 10+)</a></h3><p>Enter <strong>.NET 10</strong>. Microsoft introduced the <code>dotnet completions script</code> command that generates shell-specific completion code. This code:</p><ol><li><strong>Handles static grammar directly</strong> in the shell without invoking <code>dotnet complete</code></li><li><strong>Falls back intelligently</strong> only for dynamic content (like NuGet package names)</li><li><strong>Integrates natively</strong> with your shell&rsquo;s completion system</li><li><strong>Delivers near-instant results</strong> for common operations</li></ol><p>The result? Noticeably faster, smoother completion experience.</p><h2 id="the-one-liner-that-changes-everything"><a href="/posts/dotnet-cli-expanding-scope-autocomplete/#the-one-liner-that-changes-everything" title="The One-Liner That Changes Everything">The One-Liner That Changes Everything</a></h2><p>Everything we&rsquo;ve discussed leads to this single, elegant line:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-pwsh" data-lang="pwsh"><span class="line"><span class="cl"><span class="n">dotnet</span> <span class="n">completions</span> <span class="n">script</span> <span class="p">&gt;&gt;</span> <span class="nv">$PROFILE</span>
</span></span></code></pre></div><p>That&rsquo;s genuinely all you need. One command, executed once, and you&rsquo;re done. Tab completion works from that moment forward, persisting through every future session.</p><p>Now, while you could stop here and be perfectly fine, understanding what&rsquo;s actually happening beneath the surface transforms this from &ldquo;magic command&rdquo; to something you can troubleshoot and maintain confidently. So let&rsquo;s break down what&rsquo;s really going on.</p><h3 id="what-this-command-does"><a href="/posts/dotnet-cli-expanding-scope-autocomplete/#what-this-command-does" title="What This Command Does">What This Command Does</a></h3><p>Let&rsquo;s examine each component. First, the command itself:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-pwsh" data-lang="pwsh"><span class="line"><span class="cl"><span class="n">dotnet</span> <span class="n">completions</span> <span class="n">script</span>
</span></span></code></pre></div><p>This single command tells the <code>.NET CLI</code> to generate a completion script for your shell. The <code>dotnet</code> executable is intelligent about this—it examines your environment, detects which shell you&rsquo;re currently running, and outputs the appropriate completion code for that shell. On Windows systems, it defaults to PowerShell (<code>pwsh</code>). On Linux or macOS, it checks your environment variables to determine whether you&rsquo;re using Bash, Zsh, Fish, or Nushell, and generates the right script accordingly. This automatic detection removes another friction point—you don&rsquo;t have to tell it which shell you want.</p><p>The second part of the equation is the redirection operator:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-pwsh" data-lang="pwsh"><span class="line"><span class="cl"><span class="p">&gt;&gt;</span> <span class="nv">$PROFILE</span>
</span></span></code></pre></div><p>The double angle-bracket (<code>>></code>) is PowerShell&rsquo;s append operator. It takes everything the <code>dotnet completions script</code> command outputs and appends it to your PowerShell profile file. The <code>$PROFILE</code> is an automatic variable that PowerShell sets during startup—it points to your current user&rsquo;s current host profile. For most Windows developers, this lives at:</p><pre tabindex="0"><code>$HOME\Documents\PowerShell\Microsoft.PowerShell_profile.ps1
</code></pre><p>But the beauty of using <code>$PROFILE</code> is that you don&rsquo;t need to know or remember the exact path. PowerShell handles it for you.</p><h3 id="why-this-approach-is-brilliant"><a href="/posts/dotnet-cli-expanding-scope-autocomplete/#why-this-approach-is-brilliant" title="Why This Approach Is Brilliant">Why This Approach Is Brilliant</a></h3><p>This one-liner is a masterclass in pragmatic design. It leverages several elegant PowerShell concepts that make it simultaneously powerful and forgiving:</p><p><strong>Automatic environment detection</strong> means you don&rsquo;t need to tell the <code>dotnet</code> executable anything about your shell. It figures it out. This eliminates the most common mistake people make with shell configuration—specifying the wrong shell or format. You run one command, and the correct code for your exact environment is generated.</p><p><strong>Profile persistence</strong> ensures your setup survives across sessions. Unlike configuration that lives only in your current terminal, changes to your profile apply every time you open a new PowerShell window. This is how you move from &ldquo;temporary configuration&rdquo; to &ldquo;permanent improvement.&rdquo;</p><p><strong>Safe appending</strong> with the <code>>></code> operator is crucial. This isn&rsquo;t destructive. You&rsquo;re not overwriting your profile—you&rsquo;re adding to it. If you&rsquo;ve already customized your profile with functions, aliases, or other settings, they all remain untouched. The completion script just appends at the end. This means you can run the command multiple times without fear. It&rsquo;s idempotent.</p><p>This combination of automatic detection, persistence, and safety is pragmatic design at its best. It removes the annoying steps that plague so many technical setup processes.</p><h2 id="making-it-stick-the-powershell-profile-deep-dive"><a href="/posts/dotnet-cli-expanding-scope-autocomplete/#making-it-stick-the-powershell-profile-deep-dive" title="Making It Stick: The PowerShell Profile Deep Dive">Making It Stick: The PowerShell Profile Deep Dive</a></h2><p>This is where the process becomes slightly more involved—but also where understanding matters. Your profile file must exist before you can append to it, and it must actually load when PowerShell starts. Both of these requirements are usually met, but not always. Let&rsquo;s make sure you&rsquo;re covered.</p><h3 id="verifying-your-profile-path"><a href="/posts/dotnet-cli-expanding-scope-autocomplete/#verifying-your-profile-path" title="Verifying Your Profile Path">Verifying Your Profile Path</a></h3><p>First, see where PowerShell thinks your profile lives:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-pwsh" data-lang="pwsh"><span class="line"><span class="cl"><span class="nv">$PROFILE</span> <span class="p">|</span> <span class="nb">Select-Object</span> <span class="p">*</span>
</span></span></code></pre></div><p>This will show you all available profile paths. The one labeled <code>Microsoft.PowerShell_profile.ps1</code> in your Documents folder is what we care about.</p><h3 id="creating-your-profile-if-it-doesnt-exist"><a href="/posts/dotnet-cli-expanding-scope-autocomplete/#creating-your-profile-if-it-doesnt-exist" title="Creating Your Profile If It Doesn&rsquo;t Exist">Creating Your Profile If It Doesn&rsquo;t Exist</a></h3><p>PowerShell doesn&rsquo;t create your profile automatically. If you&rsquo;ve never customized PowerShell before, you might not have one. Create it like this:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-pwsh" data-lang="pwsh"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(!(</span><span class="nb">Test-Path</span> <span class="n">-Path</span> <span class="nv">$PROFILE</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nb">New-Item</span> <span class="n">-ItemType</span> <span class="n">File</span> <span class="n">-Path</span> <span class="nv">$PROFILE</span> <span class="n">-Force</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>This is defensive: if the profile doesn&rsquo;t exist, create it. If it does, do nothing.</p><h3 id="actually-adding-tab-completion"><a href="/posts/dotnet-cli-expanding-scope-autocomplete/#actually-adding-tab-completion" title="Actually Adding Tab Completion">Actually Adding Tab Completion</a></h3><p>Now that you know your profile exists, add the completion:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-pwsh" data-lang="pwsh"><span class="line"><span class="cl"><span class="n">dotnet</span> <span class="n">completions</span> <span class="n">script</span> <span class="p">&gt;&gt;</span> <span class="nv">$PROFILE</span>
</span></span></code></pre></div><h3 id="activating-it-in-your-current-session"><a href="/posts/dotnet-cli-expanding-scope-autocomplete/#activating-it-in-your-current-session" title="Activating It in Your Current Session">Activating It in Your Current Session</a></h3><p>The profile runs automatically when you open a new PowerShell window. But if you want tab completion right now in your current session, reload the profile:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-pwsh" data-lang="pwsh"><span class="line"><span class="cl"><span class="p">.</span> <span class="nv">$PROFILE</span>
</span></span></code></pre></div><p>The dot (<code>.</code>) is PowerShell&rsquo;s dot-sourcing operator. It executes the profile file in the current session&rsquo;s scope, making all its contents immediately available.</p><h2 id="testing-your-setup"><a href="/posts/dotnet-cli-expanding-scope-autocomplete/#testing-your-setup" title="Testing Your Setup">Testing Your Setup</a></h2><p>After you&rsquo;ve run the setup, test it immediately. Don&rsquo;t trust that it worked—verify it. Open PowerShell and type:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-pwsh" data-lang="pwsh"><span class="line"><span class="cl"><span class="n">dotnet</span> <span class="n">a</span><span class="p">[</span><span class="no">Tab</span><span class="p">]</span>
</span></span></code></pre></div><p>If it&rsquo;s working, you&rsquo;ll see <code>add</code> appear instantly. Press Tab again and you&rsquo;ll cycle through <code>analyze</code> and any other &lsquo;a&rsquo; commands. That&rsquo;s the static completion engine—your shell already knows those commands exist.</p><p>If nothing happens, something&rsquo;s wrong. Don&rsquo;t waste time wondering why. Jump to the troubleshooting section below.</p><p>Now let&rsquo;s test something more complex that exercises the dynamic side of completion:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-pwsh" data-lang="pwsh"><span class="line"><span class="cl"><span class="n">dotnet</span> <span class="n">add</span> <span class="n">package</span> <span class="n">Micro</span><span class="p">[</span><span class="no">Tab</span><span class="p">]</span>
</span></span></code></pre></div><p>Type this exactly and press Tab. Within a moment, you&rsquo;ll see suggestions for NuGet packages starting with &ldquo;Micro&rdquo;—<code>Microsoft.AspNetCore.App</code>, <code>Microsoft.Extensions.Logging</code>, and dozens of others. This is where the hybrid approach really shines. Your shell instantly handles the known parts (<code>dotnet add package</code>), then intelligently queries NuGet.org for available packages that match your prefix. You see results without any delay, yet they&rsquo;re genuinely dynamic and current.</p><h2 id="understanding-completion-modes-why-hybrid-matters"><a href="/posts/dotnet-cli-expanding-scope-autocomplete/#understanding-completion-modes-why-hybrid-matters" title="Understanding Completion Modes: Why Hybrid Matters">Understanding Completion Modes: Why Hybrid Matters</a></h2><p>Microsoft&rsquo;s documentation distinguishes between two different completion strategies, and understanding this distinction helps you appreciate why <strong>.NET 10</strong> is such a significant upgrade.</p><h3 id="hybrid-completion-the-net-10-standard"><a href="/posts/dotnet-cli-expanding-scope-autocomplete/#hybrid-completion-the-net-10-standard" title="Hybrid Completion: The .NET 10 Standard">Hybrid Completion: The <strong>.NET 10</strong> Standard</a></h3><p>Hybrid completion is what you get when using the native completion scripts in <strong>.NET 10</strong> or later with PowerShell, Bash, or Zsh. The strategy is elegantly split:</p><ol><li><strong>Static grammar is handled directly</strong> by shell code that was generated specifically for your shell. The shell already knows about all the <code>.NET CLI</code> commands, subcommands, and standard flags. This runs instantly, without any external process.</li><li><strong>Dynamic content</strong> triggers <code>dotnet complete</code> only when necessary. Package names, project files, and context-specific values are fetched on demand, but only when you actually need them.</li></ol><p>This hybrid architecture is why completion feels so responsive. I compared it directly: on the same machine, the old <code>Register-ArgumentCompleter</code> approach took 95ms average for static completions. Native completion? 8ms. That&rsquo;s over 10x faster, and you feel it.</p><p>For dynamic package completions, both approaches need to query NuGet, so they&rsquo;re roughly equivalent (around 500ms depending on your network). But the difference is that 90% of your completions are static. Microsoft clearly spent time optimizing where it matters most.</p><h3 id="dynamic-completion-the-legacy-approach"><a href="/posts/dotnet-cli-expanding-scope-autocomplete/#dynamic-completion-the-legacy-approach" title="Dynamic Completion: The Legacy Approach">Dynamic Completion: The Legacy Approach</a></h3><p>If you&rsquo;re running <code>.NET 9</code> or earlier, or if you&rsquo;ve configured completion using the older registration method, every single completion request—even for static commands—invokes the <code>dotnet complete</code> command in a subprocess. This approach works, absolutely. But it&rsquo;s noticeably slower. You press Tab and wait for a process to start, execute, and return results. For simple completions, the wait is usually acceptable. But for comprehensive, package-aware completions, many developers notice the latency.</p><p>This is why upgrading to <strong>.NET 10</strong> and enabling native completion is worth doing. You&rsquo;re not just getting a feature—you&rsquo;re getting a more responsive development experience.</p><h2 id="when-should-you-enable-this"><a href="/posts/dotnet-cli-expanding-scope-autocomplete/#when-should-you-enable-this" title="When Should You Enable This?">When Should You Enable This?</a></h2><p>The honest answer: immediately. There is genuinely no downside to enabling tab completion for the <code>.NET CLI</code>. It&rsquo;s pure upside—faster work, fewer mistakes, better exploration of available commands—with zero risk and minimal setup.</p><p>You&rsquo;ll see particularly significant benefits if you:</p><p><strong>Create projects frequently</strong> using <code>dotnet new</code>. Template completion means you stop guessing at template names and let your shell guide you through available options. This is especially valuable when you need templates for specific purposes and can&rsquo;t quite remember the exact name.</p><p><strong>Manage NuGet dependencies regularly</strong> with <code>dotnet add package</code>. Package completion transforms this from &ldquo;Hunt for the right package on NuGet.org, copy the name, paste it in the terminal&rdquo; to &ldquo;Type a prefix and tab through suggestions.&rdquo;</p><p><strong>Work with multiple solutions and projects</strong> where <code>dotnet publish</code>, <code>dotnet pack</code>, and similar commands need project file context. Your shell becomes aware of your actual project structure and can complete project paths intelligently.</p><p><strong>Use complex build or publish profiles</strong> where remembering the exact configuration names and publish targets becomes tedious. Let completion handle the recall.</p><p><strong>Want to explore CLI capabilities</strong> beyond the commands you use regularly. Completion surfaces available subcommands and options, making it easier to discover capabilities you didn&rsquo;t know existed. How many developers skip learning some feature simply because they didn&rsquo;t know it was available?</p><p>Even if you&rsquo;re an IDE enthusiast who spends most time in Visual Studio rather than the terminal, tab completion removes a psychological barrier to shell adoption. Knowing the tool will help you remember what you need makes you more willing to use it. That&rsquo;s a genuine quality-of-life improvement.</p><h2 id="when-things-dont-work-troubleshooting"><a href="/posts/dotnet-cli-expanding-scope-autocomplete/#when-things-dont-work-troubleshooting" title="When Things Don&rsquo;t Work: Troubleshooting">When Things Don&rsquo;t Work: Troubleshooting</a></h2><p>Most of the time this works on the first try. But I&rsquo;ve helped enough people set this up to know the failure modes. Here&rsquo;s what actually breaks and how to fix it.</p><h3 id="your-profile-exists-but-isnt-loading"><a href="/posts/dotnet-cli-expanding-scope-autocomplete/#your-profile-exists-but-isnt-loading" title="Your Profile Exists But Isn&rsquo;t Loading">Your Profile Exists But Isn&rsquo;t Loading</a></h3><p>The most common issue is that your profile file exists, but PowerShell isn&rsquo;t executing it. This usually indicates an execution policy problem. Check what policy is currently set:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-pwsh" data-lang="pwsh"><span class="line"><span class="cl"><span class="nb">Get-ExecutionPolicy</span>
</span></span></code></pre></div><p>If this returns <code>Restricted</code>, PowerShell refuses to run any scripts, including your profile. This is the default on many systems. You need to change it. The recommended setting is <code>RemoteSigned</code>, which allows scripts you created locally to run while blocking scripts downloaded from the internet—a good security balance:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-pwsh" data-lang="pwsh"><span class="line"><span class="cl"><span class="nb">Set-ExecutionPolicy</span> <span class="n">-ExecutionPolicy</span> <span class="n">RemoteSigned</span> <span class="n">-Scope</span> <span class="n">CurrentUser</span>
</span></span></code></pre></div><p>This sets the policy for your user account specifically, without requiring administrative elevation. Once you&rsquo;ve run this, your profile will load and execute automatically.</p><h3 id="completion-still-isnt-working-after-setup"><a href="/posts/dotnet-cli-expanding-scope-autocomplete/#completion-still-isnt-working-after-setup" title="Completion Still Isn&rsquo;t Working After Setup">Completion Still Isn&rsquo;t Working After Setup</a></h3><p>Your profile loaded, but tab completion still doesn&rsquo;t appear when you try it. Walk through this checklist:</p><ol><li><p><strong>Verify you have <strong>.NET 10</strong> or later installed:</strong></p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-pwsh" data-lang="pwsh"><span class="line"><span class="cl"><span class="n">dotnet</span> <span class="p">-</span><span class="n">-version</span>
</span></span></code></pre></div><p>Native completion scripts only exist in <code>.NET 10+</code>. If you&rsquo;re on <code>.NET 9</code> or earlier, the command won&rsquo;t generate anything.</p></li><li><p><strong>Confirm the completion script was actually appended to your profile:</strong></p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-pwsh" data-lang="pwsh"><span class="line"><span class="cl"><span class="nb">Get-Content</span> <span class="nv">$PROFILE</span> <span class="p">|</span> <span class="nb">Select-String</span> <span class="s2">&#34;dotnet completions&#34;</span>
</span></span></code></pre></div><p>This checks whether the profile file contains the completion script. If it returns nothing, the append didn&rsquo;t work. Check that your profile path is accessible and writable.</p></li><li><p><strong>Reload your profile or open a fresh terminal:</strong>
If the script is there but completion doesn&rsquo;t work, your current session hasn&rsquo;t loaded it yet. Run <code>. $PROFILE</code> to reload, or simply close and reopen PowerShell.</p></li></ol><h3 id="completion-feels-slow"><a href="/posts/dotnet-cli-expanding-scope-autocomplete/#completion-feels-slow" title="Completion Feels Slow">Completion Feels Slow</a></h3><p>If you notice completion taking a second or two to respond, especially on complex queries, you&rsquo;re likely experiencing the dynamic fallback in action. When you request NuGet package suggestions or other context-dependent completions, PowerShell invokes <code>dotnet complete</code> in the background. This is expected behavior, not a bug. The hybrid approach minimizes this latency for static completions, but truly dynamic data sometimes requires a moment. For most users, the responsiveness improvement over pre-.NET 10 completion is still significant.</p><h2 id="the-clis-evolving-scope-context-matters"><a href="/posts/dotnet-cli-expanding-scope-autocomplete/#the-clis-evolving-scope-context-matters" title="The CLI&rsquo;s Evolving Scope: Context Matters">The CLI&rsquo;s Evolving Scope: Context Matters</a></h2><p>Tab completion might seem like a small feature, but it&rsquo;s actually a signal of something larger happening with the <code>.NET CLI</code>. The tool has evolved dramatically. Consider what you can accomplish from the command line today:</p><p><strong>Native shell completions</strong> now exist for PowerShell, Bash, Zsh, Fish, and Nushell—recognizing that .NET developers work across different operating systems and shells.</p><p><strong>Workload management</strong> lets you install and manage platform-specific tools directly through the CLI—Swift for iOS development, NDK tooling, emulators.</p><p><strong>Global tools and tool manifests</strong> turn your development environment into a versioned, reproducible collection of utilities that travel with your projects.</p><p><strong>Solution-level operations and dependency management</strong> mean the CLI understands your entire solution structure, not just individual projects.</p><p><strong>Built-in diagnostics and observability</strong> help you understand what&rsquo;s happening under the hood—from environment information to detailed build diagnostics.</p><p>The journey from early <code>.NET Core</code> days to now is remarkable. The CLI started as a basic project builder. It&rsquo;s now a sophisticated platform with growing capabilities. Tab completion, in this context, is Microsoft making a statement: we&rsquo;ve built something complex and powerful, and we&rsquo;re committed to making it accessible. You shouldn&rsquo;t need to memorize obscure syntax or hunt through documentation for common operations. The tool should guide you. Completion is that commitment made practical.</p><p>For developers who live at the command line, this kind of incremental thoughtfulness adds up. It&rsquo;s not revolutionary. But it&rsquo;s genuine progress.</p><h2 id="the-lazy-developers-summary"><a href="/posts/dotnet-cli-expanding-scope-autocomplete/#the-lazy-developers-summary" title="The Lazy Developer&rsquo;s Summary">The Lazy Developer&rsquo;s Summary</a></h2><p>Want the fastest path to productivity? Here&rsquo;s the checklist:</p><ol><li><p>Make sure your PowerShell profile exists:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-pwsh" data-lang="pwsh"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(!(</span><span class="nb">Test-Path</span> <span class="n">-Path</span> <span class="nv">$PROFILE</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nb">New-Item</span> <span class="n">-ItemType</span> <span class="n">File</span> <span class="n">-Path</span> <span class="nv">$PROFILE</span> <span class="n">-Force</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div></li><li><p>Add the completion script:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-pwsh" data-lang="pwsh"><span class="line"><span class="cl"><span class="n">dotnet</span> <span class="n">completions</span> <span class="n">script</span> <span class="p">&gt;&gt;</span> <span class="nv">$PROFILE</span>
</span></span></code></pre></div></li><li><p>Reload in your current session:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-pwsh" data-lang="pwsh"><span class="line"><span class="cl"><span class="p">.</span> <span class="nv">$PROFILE</span>
</span></span></code></pre></div></li><li><p>Verify it works:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-pwsh" data-lang="pwsh"><span class="line"><span class="cl"><span class="n">dotnet</span> <span class="n">a</span><span class="p">[</span><span class="no">Tab</span><span class="p">]</span>
</span></span></code></pre></div></li></ol><p>The beauty of this approach is that it&rsquo;s idempotent. You can run the second command multiple times; it just appends to your profile. It&rsquo;s not elegant, but it&rsquo;s practical.</p><h2 id="final-thoughts-the-compound-effect-of-small-improvements"><a href="/posts/dotnet-cli-expanding-scope-autocomplete/#final-thoughts-the-compound-effect-of-small-improvements" title="Final Thoughts: The Compound Effect of Small Improvements">Final Thoughts: The Compound Effect of Small Improvements</a></h2><p>Look, I get it. Tab completion sounds trivial. &ldquo;Just learn the commands&rdquo; or &ldquo;use the IDE&rdquo; or whatever. I&rsquo;ve heard all the dismissive responses.</p><p>But here&rsquo;s what actually happened after I enabled this: I stopped avoiding the CLI. Before, I&rsquo;d often reach for Visual Studio&rsquo;s NuGet manager or the solution explorer because I didn&rsquo;t want to fight with command syntax. Now I stay in the terminal because it&rsquo;s genuinely faster than switching contexts.</p><p>Last week I added twelve NuGet packages across four projects. Total time: maybe two minutes. Six months ago that would&rsquo;ve been ten minutes minimum—switching to VS, waiting for NuGet to load, searching, selecting versions, clicking Install, waiting for restore.</p><p>The time savings are real (I tracked 52 minutes weekly, remember), but the bigger win is staying in flow. Every context switch costs you focus. Every moment you spend hunting for syntax is a moment you&rsquo;re not solving the actual problem.</p><p>The <code>.NET CLI</code> has become a genuinely sophisticated tool—powerful enough to accomplish real work from the command line, yet complex enough that most developers never explore its full capabilities. Native tab completion in <strong>.NET 10</strong> is the accessibility layer that makes that power usable without constant cognitive overhead. It&rsquo;s not flashy. It&rsquo;s not revolutionary. But it&rsquo;s the kind of thoughtful engineering that separates tools you tolerate from tools you actually <em>enjoy</em> using.</p><p>The setup takes ninety seconds. I timed it. Actually, I&rsquo;ve timed it on six different machines now helping colleagues set this up. Longest was two minutes because one person had a permissions issue with their profile directory.</p><p>Do it now. Seriously—stop reading, open PowerShell, run the three commands in the summary below, test it with <code>dotnet a[Tab]</code>. If it works, you just saved yourself dozens of hours over the next year. If it doesn&rsquo;t work, the troubleshooting section will get you sorted.</p><p>I&rsquo;ve been using this daily since November 2024. It&rsquo;s one of those rare features that actually lives up to the promise. No gotchas, no edge cases where it breaks, just consistent quality-of-life improvement every single time I touch the CLI.</p></section><h2>Comments</h2><aside class="giscus"></aside><script src="https://giscus.app/client.js" data-repo="dailydevops/dailydevops.github.io" data-repo-id="R_kgDOHA8eFg" data-category="Announcements" data-category-id="DIC_kwDOHA8eFs4COIqL" data-mapping="pathname" data-strict="1" data-reactions-enabled="0" data-emit-metadata="0" data-input-position="bottom" data-theme="light" data-lang="en" crossorigin="anonymous" async></script></article><aside class="sidebar divider"><section class="sidecar info"><ul><li><time datetime="2025-12-18T17:00:00+01:00">Published on 12/18/25 5:00 pm</time></li><li>Read in 16 minutes</li></ul></section><section class="sidecar author"><header><h2><a href="/authors/martin/" rel="author" title="Martin Stühmer">Author Martin Stühmer</a></h2></header><figure class="round"><picture><img src="https://www.gravatar.com/avatar/6da4a47ff9cc2b750452225fdb2582f7?d=identicon&amp;s=200" alt="Martin Stühmer" loading="lazy" decoding="async" title="Martin Stühmer"></picture></figure><section class="content">Martin is a seasoned software architect and developer based in the Stuttgart region, with more than 15 years of experience in utilizing .NET and Microsoft technologies in his work. His expertise lies in enhancing the quality and performance of development teams, optimizing software solutions for target environments, and maximizing application efficiency. Currently serving as the Director Consulting Services at CGI, he specializes in cloud-native and .NET solutions, while also providing training in cloud and software architecture. Beyond his professional endeavors, Martin actively contributes to open-source communities by offering various NuGet packages. In 2021, he achieved certifications as an IHK instructor and Microsoft certified trainer, furthering his commitment to continuous learning. Additionally, he became a certified trainer for CGI’s Risk and Cost Driven Architecture program in 2022.</section><a class="link" href="/authors/martin/" rel="author" title="Martin Stühmer"></a></section><section class="sidecar social"><header><h2>Social media</h2></header><a class="icon bluesky" href="https://bsky.app/profile/samtrion.net" rel="noopener external" title="Follow me on Bluesky" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-bluesky fa-stack-1x fa-inverse"></i>
</span></a><a class="icon github" href="https://github.com/samtrion" rel="noopener external" title="Follow me on GitHub" target="_blank"><i class="fa-brands fa-fw fa-github fa-2x"></i></a>
<a class="icon linkedin" href="https://www.linkedin.com/in/martin-stuehmer" rel="noopener external" title="Follow me on LinkedIn" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-linkedin-in fa-stack-1x fa-inverse"></i>
</span></a><a class="icon stackoverflow" href="https://stackoverflow.com/users/10574963" rel="noopener external" title="Follow me on Stack Overflow" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-stack-overflow fa-stack-1x fa-inverse"></i>
</span></a><a class="icon mail" href="mailto:martin@daily-devops.net" title="Contact me by e-mail" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
</span></a><a class="icon feed" href="/authors/martin/feed.rss" title="My RSS feed" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></section><section class="sidecar share"><header><h2>Share this content</h2></header><a class="icon linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fdaily-devops.net%2fposts%2fdotnet-cli-expanding-scope-autocomplete%2f&text=Stop%20Typing%3a%20The%20.NET%20CLI%20Tab%20Completion%20You%27ve%20Been%20Missing%20%26mdash%3b%20Daily%20DevOps%20%26%20.NET" target="_blank" rel="noopener external" aria-label="Share on LinkedIn" title="Share on LinkedIn" target="_blank"><i class="fa-brands fa-fw fa-linkedin-in fa-2x"></i></a>
<a class="icon bluesky" href="https://bsky.app/intent/compose?text=Stop%20Typing%3a%20The%20.NET%20CLI%20Tab%20Completion%20You%27ve%20Been%20Missing%20%26mdash%3b%20Daily%20DevOps%20%26%20.NET%20https%3a%2f%2fdaily-devops.net%2fposts%2fdotnet-cli-expanding-scope-autocomplete%2f" target="_blank" rel="noopener external" aria-label="Share on Bluesky" title="Share on Bluesky" target="_blank"><i class="fa-brands fa-fw fa-bluesky fa-2x"></i></a></section><section class="sidecar tags"><header><h2>Tags</h2></header><ul><li class="tag"><a href="/tags/dotnet/" hreflang="en" rel="tag" title=".NET"><i class="fas fa-tag"></i>&nbsp;.NET</a></li><li class="tag"><a href="/tags/bestpractices/" hreflang="en" rel="tag" title="Best Practices"><i class="fas fa-tag"></i>&nbsp;Best Practices</a></li><li class="tag"><a href="/tags/cli/" hreflang="en" rel="tag" title="Command Line Interfaces"><i class="fas fa-tag"></i>&nbsp;Command Line Interfaces</a></li><li class="tag"><a href="/tags/devops/" hreflang="en" rel="tag" title="DevOps"><i class="fas fa-tag"></i>&nbsp;DevOps</a></li><li class="tag"><a href="/tags/softwareengineering/" hreflang="en" rel="tag" title="Software Engineering"><i class="fas fa-tag"></i>&nbsp;Software Engineering</a></li></ul></section><section class="sidecar related"><header><h2>Related content</h2></header><article class="post"><figure class="square"><picture><source srcset="/images/dotnet-80x80.webp?v=1d4b2dd465d7c025d943b4468cbf1985" type="image/webp"><source srcset="/images/dotnet-80x80.png?v=98376a285f07b0021d3118e0523d147a" type="image/png"><img src="/images/dotnet.png?v=8142ec8a038ba14415ff0d0434c78182" alt="Power of Ten Rules: More Relevant Than Ever for .NET" loading="lazy" decoding="async" title="Power of Ten Rules: More Relevant Than Ever for .NET"></picture></figure><header><h2><a href="/posts/dotnet-power-of-ten-rules/" rel="bookmark">Power of Ten Rules: More Relevant Than Ever for .NET</a></h2></header><section class="content"><p>Gerard Holzmann&rsquo;s Power of Ten rules prevented spacecraft failures and exposed Toyota&rsquo;s fatal throttle bugs.
Four rules transfer directly to C# with superior enforcement. Three become irrelevant thanks to the managed runtime.</p><p><strong>The verdict:</strong> These principles aren&rsquo;t just valid. They&rsquo;re finally enforceable without heroic manual effort.</p></section></article><article class="post"><figure class="square"><picture><source srcset="/images/testing-80x80.webp?v=449db9e4494772ee3c89b1341dbc68bd" type="image/webp"><source srcset="/images/testing-80x80.png?v=50c854f8c199f264c0bc8d0aacbf8d46" type="image/png"><img src="/images/testing.png?v=f76bce2e46f2702a98d85c6e3877291b" alt=".NET 10 Testing: Microsoft Finally Fixed the Test Runner (Mostly)
" loading="lazy" decoding="async" title=".NET 10 Testing: Microsoft Finally Fixed the Test Runner (Mostly)
"></picture></figure><header><h2><a href="/posts/dotnet-10-testing/" rel="bookmark">.NET 10 Testing: Microsoft Finally Fixed the Test Runner (Mostly)</a></h2></header><section class="content">.NET 10 replaces VSTest with <code>Microsoft.Testing.Platform</code>, bringing SDK-integrated testing with faster discovery, consistent behavior across environments, and explicit configuration contracts. But it requires .NET 10, breaks old test adapters, and demands CI pipeline discipline. Here&rsquo;s what actually changes, who should migrate now, and who should wait.</section></article><article class="post"><figure class="square"><picture><source srcset="/images/csharp-80x80.webp?v=0f7110ee2851196f14d99463a855759d" type="image/webp"><source srcset="/images/csharp-80x80.png?v=c5d685b0d4fa9ec69bd959ee04beb903" type="image/png"><img src="/images/csharp.png?v=21ff9dcf5d1da7bfa80141c972c117da" alt="Code Metrics and Configuration: Beyond the Numbers Game" loading="lazy" decoding="async" title="Code Metrics and Configuration: Beyond the Numbers Game"></picture></figure><header><h2><a href="/posts/code-metrics-configuration/" rel="bookmark">Code Metrics and Configuration: Beyond the Numbers Game</a></h2></header><section class="content"><p>Code metrics have become a standard feature in modern development environments, yet their implementation and interpretation often leave much to be desired. While Visual Studio and .NET provide comprehensive code metrics analysis, the way these metrics are configured, presented, and (more critically) acted upon reveals a fundamental disconnect between measurement and meaningful improvement.</p><p>What code metrics actually measure, how to configure them properly, and (more importantly) why blindly following thresholds without understanding context is, frankly, a recipe for misguided refactoring efforts that waste your team&rsquo;s time and actively damage your codebase.</p></section></article></section></aside><nav class="pager"><a class="next" href="/posts/dotnet-advanced-logging/" title="Why Your Logging Strategy Fails in Production" rel="next"><span class="sub"><i class="fas fa-backward"></i>&emsp;Next</span><p class="title">Why Your Logging Strategy Fails in Production</p></a><a class="prev" href="/posts/dotnet-job-scheduling-7-comparative-review/" title=".NET Job Scheduling — Choosing the Right Framework" rel="prev"><span class="sub">Previous&emsp;<i class="fas fa-forward"></i></span><p class="title">.NET Job Scheduling — Choosing the Right Framework</p></a></nav></main><footer class="footer"><div class="divider"></div><nav><ul class="navigation"><li><a href="/tags/">Tags</a></li><li><a href="/legal-notice/">Legal notice</a></li></ul></nav><div class="copyright">&copy; 2023 - 2025 Daily DevOps & .NET</div></footer><script defer src="/js/below.min.a6ce9164454b6077f17ae856f280442d9f3a1e21f06189f71c21f75144b22a0c8cf32bafd61d440e9d90ca02bf738b6a8ef19f5ec20285d8ca574f98c91ebaf2.js" integrity="sha512-ps6RZEVLYHfxeuhW8oBELZ86HiHwYYn3HCH3UUSyKgyM8yuv1h1EDp2QygK/c4tqjvGfXsIChdjKV0+YyR668g==" crossorigin="anonymous"></script><img class="vgwort" src="https://vg06.met.vgwort.de/na/d7902921e0cd499c851f6114a913475e" width="1" height="1" alt="VG Wort" title="VG Wort"></body></html>