<!doctype html><html class="no-js" lang="en" dir="ltr"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="theme-color" content="#15a"><title>Storage Architecture & Stateful Workloads in AKS — Daily DevOps & .NET</title><meta name="description" content="Stateful workloads in Kubernetes require understanding PersistentVolume architecture, Azure storage trade-offs, and backup strategies. This article covers …"><meta name="twitter:description" property="og:description" content="Stateful workloads in Kubernetes require understanding PersistentVolume architecture, Azure storage trade-offs, and backup strategies. This article covers …"><meta name="author" content="Jendrik Brack"><link rel="icon" href="/logo.svg?v=b9e294dc5c6fa04439c8c803d8e981a9" sizes="any" type="image/svg+xml"><meta name="twitter:title" property="og:title" content="Storage Architecture & Stateful Workloads in AKS — Daily DevOps & .NET"><meta property="og:updated_time" content="2026-02-04T17:06:11+01:00"><meta property="article:modified_time" content="2026-02-04T17:06:11+01:00"><meta property="article:published_time" content="2026-02-04T17:00:00+01:00"><meta property="og:type" content="article"><meta property="og:site_name" content="Daily DevOps & .NET"><meta property="og:url" content="https://daily-devops.net/posts/storage-architecture-stateful-workloads-aks/"><meta property="og:locale" content="en"><meta name="twitter:card" content="summary_large_image"><meta property="og:image" name="twitter:image" content="https://daily-devops.net/images/azure-aks-networking-1200x630.webp?v=84ce1207dfd4512773ffcdc5c48512e8"><meta property="og:image:secure_url" content="https://daily-devops.net/images/azure-aks-networking-1200x630.webp?v=84ce1207dfd4512773ffcdc5c48512e8"><meta property="og:image:alt" name="twitter:image:alt" content="Storage Architecture & Stateful Workloads in AKS"><meta property="og:image:type" content="image/webp"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta property="og:image" name="twitter:image" content="https://daily-devops.net/images/azure-aks-networking-1200x630.png?v=2e62b136b74548ab5fc5f15fccee3a35"><meta property="og:image:secure_url" content="https://daily-devops.net/images/azure-aks-networking-1200x630.png?v=2e62b136b74548ab5fc5f15fccee3a35"><meta property="og:image:alt" name="twitter:image:alt" content="Storage Architecture & Stateful Workloads in AKS"><meta property="og:image:type" content="image/png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><link rel="dns-prefetch" href="https://www.clarity.ms"><link rel="preconnect" href="https://www.clarity.ms" crossorigin><link rel="stylesheet" href="/css/style.min.0b2ef4378cd908eb695017aaa74603d244ff2b38c8068b4b51d76cad830c8ee5e3a40b67ab5b860a542c8bae73d8ba90cfbe9249b59c733a50de74cc32af818a.css" integrity="sha512-Cy70N4zZCOtpUBeqp0YD0kT/KzjIBotLUddsrYMMjuXjpAtnq1uGClQsi65z2LqQz76SSbWcczpQ3nTMMq+Big==" crossorigin="anonymous"><link rel="alternate" href='https://daily-devops.net/posts/storage-architecture-stateful-workloads-aks/' hreflang="x-default" title="Storage Architecture & Stateful Workloads in AKS &mdash; Daily DevOps & .NET"><link rel="canonical" href="https://daily-devops.net/posts/storage-architecture-stateful-workloads-aks/" hreflang="en" title="Storage Architecture & Stateful Workloads in AKS &mdash; Daily DevOps & .NET"><link rel="home" href="https://daily-devops.net/" hreflang="en" title="Daily DevOps & .NET"><link rel="next" href="https://daily-devops.net/posts/cryptography-dotnet-data-protection/" hreflang="en" title="Your Encryption Is Broken — .NET Data Protection Done Right"><link rel="prev" href="https://daily-devops.net/posts/secrets-management-azure-keyvault/" hreflang="en" title="Your appsettings.json Is a Compliance Violation"><link rel="author" href="https://daily-devops.net/authors/jendrik/" hreflang="en" title="Jendrik Brack &mdash; Daily DevOps & .NET"><meta name="giscus:backlink" content="https://daily-devops.net/posts/storage-architecture-stateful-workloads-aks/"><script defer src="/js/above.min.cb42b2c9a453e49e278326637d72d2f01e7f32e3f91e9cdde8fb587793d05514efd2f5cc5021c9658ca0f73876dbdcd1f7cb4a37c0bebc9df01110926b6d7cba.js" integrity="sha512-y0KyyaRT5J4ngyZjfXLS8B5/MuP5Hpzd6PtYd5PQVRTv0vXMUCHJZYyg9zh229zR98tKN8C+vJ3wERCSa218ug==" crossorigin="anonymous"></script><script type="text/javascript">(function(e,t,n,s,o,i,a){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)},i=t.createElement(s),i.async=1,i.src="https://www.clarity.ms/tag/"+o,a=t.getElementsByTagName(s)[0],a.parentNode.insertBefore(i,a)})(window,document,"clarity","script","o0pr4n9gg3")</script><script src="https://analytics.ahrefs.com/analytics.js" data-key="C5Iv+2Rb9el+FLJqVw2QGA" async></script></head><body class="container"><header class="header"><a class="logo" href="/" title="Daily DevOps & .NET" rel="home"><figure class="page-logo"><picture><img src="/logo.svg?v=b9e294dc5c6fa04439c8c803d8e981a9" alt="Daily DevOps & .NET" title="Daily DevOps & .NET"></picture></figure><span class="title">Daily DevOps & .NET</span></a><nav class="menu" aria-label="Main navigation"><button class="burger" type="button" aria-haspopup="menu" aria-expanded="false" aria-label="Toggle menu">
<i class="fas fa-burger" aria-hidden="true"></i></button><ul class="navigation"><li class="active"><a href="/posts/">Posts</a></li><li><a href="/authors/">About us</a></li></ul></nav><div class="divider"></div></header><main class="body"><figure class="hero"><picture><source srcset="/images/azure-aks-networking-544x136.webp?v=4fa28a61106639369657a6f62238e432" type="image/webp" media="(max-width: 575.98px)"><source srcset="/images/azure-aks-networking-544x136.png?v=fe092e5a62ae4c042edb803b090c5989" type="image/png" media="(max-width: 575.98px)"><source srcset="/images/azure-aks-networking-672x168.webp?v=95c4b9c48d1970dcb840e0194c834ee7" type="image/webp" media="(max-width: 767.98px)"><source srcset="/images/azure-aks-networking-672x168.png?v=b56c6afad8762d4b5ed5cfa94fcda04b" type="image/png" media="(max-width: 767.98px)"><source srcset="/images/azure-aks-networking-896x224.webp?v=36b7e64aa79c2b0c23b8721de36e3329" type="image/webp" media="(max-width: 991.98px)"><source srcset="/images/azure-aks-networking-896x224.png?v=d3373b9ff00fd73e34c03bb616e6ebc8" type="image/png" media="(max-width: 991.98px)"><source srcset="/images/azure-aks-networking-1104x276.webp?v=5adf3b4c4ec00e4d81b455105ea1df83" type="image/webp" media="(max-width: 1199.98px)"><source srcset="/images/azure-aks-networking-1104x276.png?v=5c379296c3b8d00855590e0679541241" type="image/png" media="(max-width: 1199.98px)"><source srcset="/images/azure-aks-networking-1444x361.webp?v=ef037af0a3793c6f1ea75de61f79e8c1" type="image/webp"><source srcset="/images/azure-aks-networking-1444x361.png?v=c946805736caeb8c51bc24ff0c07098b" type="image/png"><img src="/images/azure-aks-networking.png?v=18bd7f57024c4453f7415c91251112a9" alt="Storage Architecture & Stateful Workloads in AKS" loading="lazy" decoding="async" title="Storage Architecture & Stateful Workloads in AKS"></picture></figure><article class="post"><header><h1>Storage Architecture & Stateful Workloads in AKS</h1></header><section class="content" role="region"><h2 id="the-problem-traditional-storage-models-dont-translate-to-kubernetes"><a href="/posts/storage-architecture-stateful-workloads-aks/#the-problem-traditional-storage-models-dont-translate-to-kubernetes" title="The Problem: Traditional Storage Models Don&rsquo;t Translate to Kubernetes">The Problem: Traditional Storage Models Don&rsquo;t Translate to Kubernetes</a></h2><p>Running stateful workloads in Kubernetes means more than deploying a database pod. Traditional storage models (provision a disk, format it, mount it, expect it to stay) collide with Kubernetes&rsquo; ephemeral, distributed architecture. Pods get rescheduled, scaled, and terminated. Your database shouldn&rsquo;t lose data when that happens.</p><p>The core challenge: <strong>how do you attach persistent storage to ephemeral compute?</strong> On-premises infrastructure relies on SAN devices, NFS mounts, or local disks with predictable failure domains. You know which server hosts which disk. In AKS, you work with Azure storage primitives: Managed Disks, Azure Files, blob storage. These need seamless integration with Kubernetes lifecycle management. The abstractions differ, the failure modes differ, and operational patterns require rethinking.</p><p>Complexity multiplies with backup requirements, disaster recovery expectations, and multi-cluster data synchronization. Whether migrating legacy apps that expect local RAID controllers or building cloud-native data platforms from scratch, AKS storage architecture knowledge is foundational. Get it wrong: data loss, performance bottlenecks, escalating cloud bills.</p><h2 id="pvcpv-architecture-how-storage-binds-to-pods-in-aks"><a href="/posts/storage-architecture-stateful-workloads-aks/#pvcpv-architecture-how-storage-binds-to-pods-in-aks" title="PVC/PV Architecture: How Storage Binds to Pods in AKS">PVC/PV Architecture: How Storage Binds to Pods in AKS</a></h2><p>Kubernetes abstracts storage through two key objects: <strong>PersistentVolumes (PV)</strong> and <strong>PersistentVolumeClaims (PVC)</strong>. A PV represents the actual storage resource (Azure Disk, Azure Files share). A PVC represents the request for that storage. The relationship mirrors compute abstractions: nodes are physical machines, pods are logical units consuming node resources. Similarly, PVs are physical storage, PVCs are logical requests consuming PV capacity.</p><p>The binding flow:</p><ol><li>Developer creates a PVC specifying size, access mode, and storage class</li><li>Kubernetes finds or provisions a matching PV based on the storage class</li><li>PVC binds to the PV, making it available to pods</li><li>Pods reference the PVC in their volume mounts</li><li>When the pod terminates, the PVC remains (data persists across pod lifecycles)</li></ol><p>Access modes matter:</p><ul><li><strong>ReadWriteOnce (RWO)</strong>: Single node can mount the volume (Azure Disk)</li><li><strong>ReadWriteMany (RWX)</strong>: Multiple nodes can mount simultaneously (Azure Files)</li><li><strong>ReadOnlyMany (ROX)</strong>: Multiple nodes, read-only access</li></ul><p>Most stateful apps (databases, message queues) use RWO. Azure Disks provide better IOPS and latency than Azure Files. For shared storage (parallel batch processing, shared config directories, legacy apps expecting NFS semantics), use RWX: Azure Files or third-party CSI drivers like NFS or CephFS.</p><p>Critical insight: <strong>PVCs decouple storage requests from storage implementation.</strong> Developers don&rsquo;t need to know if they get a Premium SSD or Standard HDD. They request 100Gi of fast storage, the storage class handles provisioning. This abstraction enables platform teams to enforce policies (all production PVCs use Premium tier) without touching application manifests.</p><h2 id="azure-disk-vs-azure-files-performance-cost-regional-constraints"><a href="/posts/storage-architecture-stateful-workloads-aks/#azure-disk-vs-azure-files-performance-cost-regional-constraints" title="Azure Disk vs. Azure Files: Performance, Cost, Regional Constraints">Azure Disk vs. Azure Files: Performance, Cost, Regional Constraints</a></h2><p>Choosing between Azure Disk and Azure Files isn&rsquo;t a one-size-fits-all decision. Each has distinct performance profiles, cost implications, and operational constraints.</p><p><strong>Azure Disk (Managed Disks):</strong></p><ul><li><strong>Performance:</strong> Lower latency, higher IOPS. Premium SSDs reach 20,000 IOPS, Ultra Disks exceed that.</li><li><strong>Access:</strong> Single-node attachment (RWO). Pod rescheduling to another node triggers disk detach and reattach (expect brief delay).</li><li><strong>Use cases:</strong> Databases (PostgreSQL, MongoDB), stateful apps requiring low-latency I/O.</li><li><strong>Cost:</strong> Pay per provisioned disk size. A 1TB Premium SSD costs more than a 1TB Standard HDD, regardless of actual usage.</li><li><strong>Regional constraints:</strong> Disks are zone-specific. With availability zones, pods must schedule in the same zone as the disk.</li></ul><p><strong>Azure Files (SMB/NFS):</strong></p><ul><li><strong>Performance:</strong> Higher latency than disks. Premium Files tier improves performance but still trails disk I/O.</li><li><strong>Access:</strong> Multi-node (RWX). Multiple pods across nodes can mount the same share.</li><li><strong>Use cases:</strong> Shared logs, static assets, config files, legacy apps expecting NFS.</li><li><strong>Cost:</strong> Pay per storage consumed plus transactions. Transaction costs surprise teams on high-throughput workloads.</li><li><strong>Regional constraints:</strong> File shares are regional, not zonal. Better for cross-zone workloads, still tied to single region.</li></ul><p><strong>Decision criteria:</strong> Default to Azure Disk for databases and high-IOPS apps. Use Azure Files only when RWX access or legacy NFS compatibility is required. For backup targets or archival storage, consider blob storage with CSI drivers (experimental, improving).</p><p>Gotcha: <strong>disk attachment times.</strong> Pod rescheduling requires Azure to detach the disk from the old node and attach it to the new one. This takes 30 to 90 seconds. Apps that cannot tolerate this downtime need application-level replication (PostgreSQL streaming replication) or third-party solutions like Portworx.</p><h2 id="storage-classes--dynamic-provisioning-automating-the-lifecycle"><a href="/posts/storage-architecture-stateful-workloads-aks/#storage-classes--dynamic-provisioning-automating-the-lifecycle" title="Storage Classes & Dynamic Provisioning: Automating the Lifecycle">Storage Classes & Dynamic Provisioning: Automating the Lifecycle</a></h2><p>Static provisioning (manually creating PVs, hoping someone claims them) creates operational overhead. <strong>Storage classes</strong> enable dynamic provisioning: Kubernetes automatically creates a PV when a PVC is submitted.</p><p>AKS ships with default storage classes:</p><ul><li><code>default</code>: Standard HDD Azure Disk (RWO)</li><li><code>managed-premium</code>: Premium SSD Azure Disk (RWO)</li><li><code>azurefile</code>: Azure Files share (RWX)</li><li><code>azurefile-premium</code>: Premium Azure Files share (RWX)</li></ul><p>You can define custom storage classes to fine-tune parameters:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">storage.k8s.io/v1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">StorageClass</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">fast-ssd</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="nt">provisioner</span><span class="p">:</span><span class="w"> </span><span class="l">disk.csi.azure.com</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="nt">parameters</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">skuName</span><span class="p">:</span><span class="w"> </span><span class="l">Premium_LRS</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Managed</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">cachingMode</span><span class="p">:</span><span class="w"> </span><span class="l">ReadOnly</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># Zone redundant storage (ZRS) for higher durability</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># skuName: Premium_ZRS</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="nt">allowVolumeExpansion</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="nt">reclaimPolicy</span><span class="p">:</span><span class="w"> </span><span class="l">Retain</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="nt">volumeBindingMode</span><span class="p">:</span><span class="w"> </span><span class="l">WaitForFirstConsumer</span><span class="w">
</span></span></span></code></pre></div><p>Key parameters:</p><ul><li><strong>reclaimPolicy:</strong> <code>Delete</code> removes the disk when PVC is deleted, <code>Retain</code> keeps it. For production databases, <code>Retain</code> prevents accidental data deletion.</li><li><strong>volumeBindingMode:</strong> <code>WaitForFirstConsumer</code> delays PV creation until pod scheduling. Critical for zone-aware clusters (Kubernetes creates the disk in the same zone as the pod).</li><li><strong>allowVolumeExpansion:</strong> Enables PVC resizing without recreation. Azure Disks support this, not all storage backends do.</li></ul><p><strong>Best practice:</strong> Create environment-specific storage classes (dev, staging, prod) with different <code>skuName</code> values. Dev clusters use Standard HDDs, prod uses Premium SSDs. Developers use identical manifests across environments, only the storage class name changes.</p><h2 id="backup--recovery-rtorpo-implications"><a href="/posts/storage-architecture-stateful-workloads-aks/#backup--recovery-rtorpo-implications" title="Backup & Recovery: RTO/RPO Implications">Backup & Recovery: RTO/RPO Implications</a></h2><p>Kubernetes doesn&rsquo;t backup data by default. Running <code>kubectl delete pvc</code> without a recovery plan means permanent data loss.</p><p><strong>Velero</strong> (formerly Heptio Ark) is the de facto standard for Kubernetes backup. It snapshots PVs, captures Kubernetes object state, stores backups in object storage (Azure Blob, S3, GCS).</p><p>Example Velero backup schedule (via CLI):</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># Install Velero with Azure plugin</span>
</span></span><span class="line"><span class="cl">velero install <span class="se">\
</span></span></span><span class="line"><span class="cl">  --provider azure <span class="se">\
</span></span></span><span class="line"><span class="cl">  --plugins velero/velero-plugin-for-microsoft-azure:v1.9.0 <span class="se">\
</span></span></span><span class="line"><span class="cl">  --bucket velero-backups <span class="se">\
</span></span></span><span class="line"><span class="cl">  --secret-file ./credentials-velero <span class="se">\
</span></span></span><span class="line"><span class="cl">  --backup-location-config <span class="nv">resourceGroup</span><span class="o">=</span>aks-backups-rg,storageAccount<span class="o">=</span>aksbackupssa
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Create a daily backup schedule for production namespace</span>
</span></span><span class="line"><span class="cl">velero schedule create daily-prod-backup <span class="se">\
</span></span></span><span class="line"><span class="cl">  --schedule<span class="o">=</span><span class="s2">&#34;0 2 * * *&#34;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl">  --include-namespaces production <span class="se">\
</span></span></span><span class="line"><span class="cl">  --snapshot-volumes <span class="se">\
</span></span></span><span class="line"><span class="cl">  --ttl 720h
</span></span></code></pre></div><p><strong>RTO/RPO considerations:</strong></p><ul><li><strong>Snapshot-based backups (Azure Disk snapshots via Velero):</strong> RPO equals backup frequency (hourly, daily). RTO equals time to provision new PV plus restore data (5 to 30 minutes).</li><li><strong>Native Azure Backup for AKS:</strong> Microsoft managed solution. Integrated with Azure Backup policies, slower restores and less granular than Velero.</li><li><strong>Application-level backups (pg_dump, mongodump):</strong> Bypasses Kubernetes entirely. Lower RTO with automated restore scripts, requires custom orchestration.</li></ul><p><strong>Gotcha:</strong> Velero relies on Azure Disk snapshots. Disk in Zone 1, restore to cluster in Zone 2 requires cross-zone snapshot copy (not instant). Test restore procedures in non-prod clusters. A backup never restored is wishful thinking.</p><h2 id="multi-aks-replication-patterns-for-cross-cluster-data-synchronization"><a href="/posts/storage-architecture-stateful-workloads-aks/#multi-aks-replication-patterns-for-cross-cluster-data-synchronization" title="Multi-AKS Replication: Patterns for Cross-Cluster Data Synchronization">Multi-AKS Replication: Patterns for Cross-Cluster Data Synchronization</a></h2><p>Running stateful workloads across multiple AKS clusters—whether for HA, disaster recovery, or multi-region latency requirements—adds another layer of complexity.</p><p><strong>Pattern 1: Application-Level Replication</strong>
Let the application handle replication. PostgreSQL streaming replication, MongoDB replica sets, Kafka replication understand their data models and replicate efficiently.</p><ul><li><strong>Pros:</strong> No Kubernetes-specific dependencies. Works identically in VMs, on-premises, or managed services.</li><li><strong>Cons:</strong> You manage replication lag, split-brain scenarios, and failover logic.</li></ul><p><strong>Pattern 2: Storage-Level Replication</strong>
Use Azure NetApp Files or third-party solutions like Portworx for block or file-level replication.</p><ul><li><strong>Pros:</strong> Transparent to applications. Works with legacy apps lacking native replication.</li><li><strong>Cons:</strong> Expensive. NetApp Files Premium tier and Portworx licensing (scales with node count) add significant cost.</li></ul><p><strong>Pattern 3: Backup-Based DR</strong>
Velero backups from primary cluster, restore to secondary on failover.</p><ul><li><strong>Pros:</strong> Cost-effective (blob storage only).</li><li><strong>Cons:</strong> RPO equals last backup interval (hours, not seconds). RTO includes restore time (minutes to hours).</li></ul><p><strong>Real-world example:</strong> Multi-region PostgreSQL deployment pattern I&rsquo;ve encountered:</p><ul><li><strong>Primary AKS cluster (West Europe):</strong> Production traffic</li><li><strong>Secondary AKS cluster (North Europe):</strong> Read replicas via PostgreSQL streaming replication</li><li><strong>Velero backups:</strong> Azure Blob in third region (East US) for regulatory compliance</li></ul><p>This provides sub-second RPO within Europe (streaming replication), hourly RPO globally (Velero), 5-minute RTO for regional failover (promote read replica).</p><p><strong>Operational reality:</strong> Multi-cluster data replication is complex. Avoid it by using managed services (Azure Database for PostgreSQL with geo-replication) if possible. Running databases in AKS requires investment in automation, monitoring, and runbooks. Your 3 AM self will appreciate this decision.</p><h2 id="final-thoughts"><a href="/posts/storage-architecture-stateful-workloads-aks/#final-thoughts" title="Final Thoughts">Final Thoughts</a></h2><p>Storage in AKS represents a set of trade-offs requiring deliberate navigation. Azure Disk provides performance with zone-locking. Azure Files offers flexibility with latency penalties. Velero enables backups but demands operational discipline and testing. Multi-cluster replication delivers resilience with non-linear operational complexity.</p><p>Pragmatic approach: Start with managed storage classes and Velero. Use Azure Disk for databases and high-IOPS workloads. Use Azure Files only when RWX access or legacy NFS compatibility is genuinely required. Test restore procedures quarterly, not during outages. Schedule fire drills: delete a namespace, restore from backup. Measure actual RTO/RPO instead of assuming SLA compliance.</p><p>When stateful workload requirements outgrow AKS storage primitives (sub-second cross-region replication, disk attachment latency breaking your app, spiraling storage costs), don&rsquo;t force solutions. Consider Azure managed services (Azure Database for PostgreSQL, Cosmos DB) or specialized data platforms (Confluent Cloud for Kafka, MongoDB Atlas). Sometimes the best Kubernetes storage strategy is avoiding stateful workloads in Kubernetes.</p><p>Kubernetes excels at stateless orchestration. For stateful workloads, it&rsquo;s capable but demands understanding the plumbing, accepting trade-offs, building operational muscle around backups, monitoring, and runbooks. Treat storage as infrastructure that will fail, not infrastructure that just works. Plan accordingly.</p></section><section class="giscus"><h2>Comments</h2><aside class="giscus" id="giscus-thread" role="region" aria-label="Comments"></aside></section><script src="https://giscus.app/client.js" data-repo="dailydevops/dailydevops.github.io" data-repo-id="R_kgDOHA8eFg" data-category="Announcements" data-category-id="DIC_kwDOHA8eFs4COIqL" data-mapping="pathname" data-strict="1" data-reactions-enabled="0" data-emit-metadata="0" data-input-position="bottom" data-theme="light" data-lang="en" crossorigin="anonymous" async></script></article><aside class="sidebar divider"><section class="sidecar info" aria-labelledby="info-heading"><header><h2 id="info-heading" class="sr-only">Informations</h2></header><ul role="list"><li role="listitem"><time datetime="2026-02-04T17:00:00+01:00" itemprop="datePublished">Published on 2/4/26 5:00 pm</time></li><li>Read in 8 minutes</li></ul></section><section class="sidecar series" aria-labelledby="series-heading"><header><h2 id="series-heading">Series content</h2></header><nav class="series-nav" role="navigation" aria-label="Series content"><ul role="list"><li role="listitem"><a href="https://daily-devops.net/posts/pod-identity-access-control-aks/" title="Pod Identity & Access Control in AKS: What Actually Breaks" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right" aria-hidden="true"></i>&nbsp;
Pod Identity & Access Control in AKS: What Actually Breaks</a></li><li role="listitem"><a href="https://daily-devops.net/posts/cluster-upgrades-zero-downtime-aks/" title="AKS Cluster Upgrades: Zero-Downtime Operations That Actually Work
" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right" aria-hidden="true"></i>&nbsp;
AKS Cluster Upgrades: Zero-Downtime Operations That Actually Work</a></li><li role="listitem"><a href="https://daily-devops.net/posts/storage-architecture-stateful-workloads-aks/" title="Storage Architecture & Stateful Workloads in AKS" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right" aria-hidden="true"></i>&nbsp;
Storage Architecture & Stateful Workloads in AKS</a></li></ul></nav></section><section class="sidecar author" aria-labelledby="author-jendrik-brack"><header><h2 id="author-jendrik-brack"><a href="/authors/jendrik/" rel="author" title="Jendrik Brack" itemprop="url">Author <span itemprop="name">Jendrik Brack</span></a></h2></header><figure class="round"><picture><img src="https://www.gravatar.com/avatar/?d=identicon&amp;s=200" alt="Jendrik Brack" loading="lazy" decoding="async" title="Jendrik Brack"></picture></figure><section class="content" itemprop="description">DevOps engineer with a systems-administration background; focus on Azure, CI/CD, IaC and pragmatic automation solutions.</section><a class="link" href="/authors/jendrik/" rel="author" aria-label="Author Jendrik Brack: Read more"></a></section><section class="sidecar social" aria-labelledby="social-heading"><header><h2 id="social-heading">Social media</h2></header><nav class="social-nav" role="navigation" aria-label="Social media links"><a class="icon linkedin" href="https://www.linkedin.com/in/jendrik-brack" rel="noopener external" aria-label="Follow me on LinkedIn" target="_blank"><span class="fa-stack fa-fw fa-1x" aria-hidden="true"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-linkedin-in fa-stack-1x fa-inverse"></i>
</span></a><a class="icon mail" href="mailto:jendrik@daily-devops.net" aria-label="Contact me by e-mail" target="_blank"><span class="fa-stack fa-fw fa-1x" aria-hidden="true"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
</span></a><a class="icon feed" href="/authors/jendrik/feed.rss" aria-label="My RSS feed" target="_blank"><span class="fa-stack fa-fw fa-1x" aria-hidden="true"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></nav></section><section class="sidecar share" aria-labelledby="share-heading"><header><h2 id="share-heading">Share this content</h2></header><a class="icon linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fdaily-devops.net%2fposts%2fstorage-architecture-stateful-workloads-aks%2f&text=Storage%20Architecture%20%26%20Stateful%20Workloads%20in%20AKS%20%26mdash%3b%20Daily%20DevOps%20%26%20.NET" target="_blank" rel="noopener external" aria-label="Share on LinkedIn" title="Share on LinkedIn" target="_blank"><i class="fa-brands fa-fw fa-linkedin-in fa-2x"></i></a>
<a class="icon bluesky" href="https://bsky.app/intent/compose?text=Storage%20Architecture%20%26%20Stateful%20Workloads%20in%20AKS%20%26mdash%3b%20Daily%20DevOps%20%26%20.NET%20https%3a%2f%2fdaily-devops.net%2fposts%2fstorage-architecture-stateful-workloads-aks%2f" target="_blank" rel="noopener external" aria-label="Share on Bluesky" title="Share on Bluesky" target="_blank"><i class="fa-brands fa-fw fa-bluesky fa-2x"></i></a></section><section class="sidecar tags" aria-labelledby="tags-heading"><header><h2 id="tags-heading">Tags</h2></header><ul class="tags" role="list"><li class="tag" role="listitem"><a href="/tags/azure/" hreflang="en" rel="tag" title="Azure" aria-label="Azure tag"><i class="fas fa-tag" aria-hidden="true"></i>&nbsp;Azure</a></li><li class="tag" role="listitem"><a href="/tags/cloud/" hreflang="en" rel="tag" title="Cloud" aria-label="Cloud tag"><i class="fas fa-tag" aria-hidden="true"></i>&nbsp;Cloud</a></li><li class="tag" role="listitem"><a href="/tags/storage/" hreflang="en" rel="tag" title="Cloud Storage" aria-label="Cloud Storage tag"><i class="fas fa-tag" aria-hidden="true"></i>&nbsp;Cloud Storage</a></li><li class="tag" role="listitem"><a href="/tags/kubernetes/" hreflang="en" rel="tag" title="Kubernetes" aria-label="Kubernetes tag"><i class="fas fa-tag" aria-hidden="true"></i>&nbsp;Kubernetes</a></li><li class="tag" role="listitem"><a href="/tags/operations/" hreflang="en" rel="tag" title="Operations" aria-label="Operations tag"><i class="fas fa-tag" aria-hidden="true"></i>&nbsp;Operations</a></li><li class="tag" role="listitem"><a href="/tags/platform-engineering/" hreflang="en" rel="tag" title="Platform Engineering" aria-label="Platform Engineering tag"><i class="fas fa-tag" aria-hidden="true"></i>&nbsp;Platform Engineering</a></li><li class="tag" role="listitem"><a href="/tags/reliability/" hreflang="en" rel="tag" title="Reliability" aria-label="Reliability tag"><i class="fas fa-tag" aria-hidden="true"></i>&nbsp;Reliability</a></li></ul></section><section class="sidecar related" aria-labelledby="related-heading"><header><h2 id="related-heading">Related content</h2></header><article class="post"><figure class="square"><picture><source srcset="/images/kubernetes-80x80.webp?v=b2176ca9922334fbedb8b4a729864551" type="image/webp"><source srcset="/images/kubernetes-80x80.png?v=d788d2e12d518ec535b206b850aa6299" type="image/png"><img src="/images/kubernetes.png?v=280c2acddf92ea95b1980ffe00b959a3" alt="AKS Cluster Upgrades: Zero-Downtime Operations That Actually Work
" loading="lazy" decoding="async" title="AKS Cluster Upgrades: Zero-Downtime Operations That Actually Work
"></picture></figure><header><h2><a href="/posts/cluster-upgrades-zero-downtime-aks/" rel="bookmark">AKS Cluster Upgrades: Zero-Downtime Operations That Actually Work</a></h2></header><section class="content" role="region">AKS cluster upgrades involve node replacement and pod eviction, which can cause service disruption without proper controls. This article explains cordon and drain mechanics, Pod Disruption Budget configuration, and multi-node-pool rollout strategies with validation-driven automation for reliable zero-downtime upgrades.</section></article><article class="post"><figure class="square"><picture><source srcset="/images/azure-aks-networking-80x80.webp?v=18843f5b17b2fa3041b7e7cbd6ae1c06" type="image/webp"><source srcset="/images/azure-aks-networking-80x80.png?v=5222a7b18515bd9d3098abe7fbce0d8e" type="image/png"><img src="/images/azure-aks-networking.png?v=18bd7f57024c4453f7415c91251112a9" alt="Pod Identity & Access Control in AKS: What Actually Breaks" loading="lazy" decoding="async" title="Pod Identity & Access Control in AKS: What Actually Breaks"></picture></figure><header><h2><a href="/posts/pod-identity-access-control-aks/" rel="bookmark">Pod Identity & Access Control in AKS: What Actually Breaks</a></h2></header><section class="content" role="region">Traditional AKS authentication relied on service principals and mounted secrets. Workload Identity Federation eliminates credential lifecycle problems, but introduces new failure modes. This article covers the operational realities: where credentials still leak, how RBAC layers compound across Kubernetes and Azure, and validation patterns that prevent identity failures in production.</section></article><article class="post"><figure class="square"><picture><source srcset="/images/azure-aks-networking-80x80.webp?v=18843f5b17b2fa3041b7e7cbd6ae1c06" type="image/webp"><source srcset="/images/azure-aks-networking-80x80.png?v=5222a7b18515bd9d3098abe7fbce0d8e" type="image/png"><img src="/images/azure-aks-networking.png?v=18bd7f57024c4453f7415c91251112a9" alt="AKS Network Policies: The Security Layer Your Cluster Is Missing" loading="lazy" decoding="async" title="AKS Network Policies: The Security Layer Your Cluster Is Missing"></picture></figure><header><h2><a href="/posts/aks-network-policies-zero-trust/" rel="bookmark">AKS Network Policies: The Security Layer Your Cluster Is Missing</a></h2></header><section class="content" role="region"><p>Network segmentation is a fundamental security control for modern Kubernetes environments. AKS supports multiple networking models such as kubenet, Azure CNI, and overlay CNIs. The networking model matters, but the decisive factor for enforcing isolation and compliance is the consistent application of network policies.</p><p>This article describes how network policies work in AKS, the available engines, practical examples, and recommended practices for enforcing a zero-trust posture within a cluster.</p></section></article></section></aside><nav class="pager" aria-label="Article navigation" role="navigation"><a class="next" href="/posts/cryptography-dotnet-data-protection/" rel="next" aria-label="Next: Your Encryption Is Broken — .NET Data Protection Done Right"><span class="sub"><i class="fas fa-backward" aria-hidden="true"></i>&emsp;<span class="sr-only">Next</span></span><p class="title">Your Encryption Is Broken — .NET Data Protection Done Right</p></a><a class="prev" href="/posts/secrets-management-azure-keyvault/" rel="prev" aria-label="Previous: Your appsettings.json Is a Compliance Violation"><span class="sub"><span class="sr-only">Previous</span>&emsp;<i class="fas fa-forward" aria-hidden="true"></i></span><p class="title">Your appsettings.json Is a Compliance Violation</p></a></nav></main><footer class="footer"><div class="divider"></div><nav><ul class="navigation"><li><a href="/tags/">Tags</a></li><li><a href="/legal-notice/">Legal notice</a></li></ul></nav><div class="copyright">&copy; 2023 - 2026 Daily DevOps & .NET</div></footer><script defer src="/js/below.min.a6ce9164454b6077f17ae856f280442d9f3a1e21f06189f71c21f75144b22a0c8cf32bafd61d440e9d90ca02bf738b6a8ef19f5ec20285d8ca574f98c91ebaf2.js" integrity="sha512-ps6RZEVLYHfxeuhW8oBELZ86HiHwYYn3HCH3UUSyKgyM8yuv1h1EDp2QygK/c4tqjvGfXsIChdjKV0+YyR668g==" crossorigin="anonymous"></script></body></html>