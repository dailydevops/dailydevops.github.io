<!doctype html><html class="no-js" lang="en" dir="ltr"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="theme-color" content="#15a"><title>.NET 10 Testing: Microsoft Finally Fixed the Test Runner (Mostly)
— Daily DevOps & .NET</title><meta name="description" content=".NET 10 replaces VSTest with Microsoft.Testing.Platform, bringing SDK-integrated testing with faster discovery, consistent behavior across …"><meta name="twitter:description" property="og:description" content=".NET 10 replaces VSTest with Microsoft.Testing.Platform, bringing SDK-integrated testing with faster discovery, consistent behavior across …"><meta name="author" content="Martin Stühmer"><link rel="icon" href="/logo.svg?v=b9e294dc5c6fa04439c8c803d8e981a9" sizes="any" type="image/svg+xml"><meta name="twitter:title" property="og:title" content=".NET 10 Testing: Microsoft Finally Fixed the Test Runner (Mostly)
 — Daily DevOps & .NET"><meta property="og:updated_time" content="2025-12-10T16:51:07+01:00"><meta property="article:modified_time" content="2025-12-10T16:51:07+01:00"><meta property="article:published_time" content="2025-11-20T17:00:00+01:00"><meta property="og:type" content="article"><meta property="og:site_name" content="Daily DevOps & .NET"><meta property="og:url" content="https://daily-devops.net/posts/dotnet-10-testing/"><meta property="og:locale" content="en_US"><meta name="twitter:card" content="summary_large_image"><meta property="og:image" name="twitter:image" content="https://daily-devops.net/images/testing-1200x630.webp?v=e553baba20b6419037a858a18c77d2be"><meta property="og:image:secure_url" content="https://daily-devops.net/images/testing-1200x630.webp?v=e553baba20b6419037a858a18c77d2be"><meta property="og:image:alt" name="twitter:image:alt" content=".NET 10 Testing: Microsoft Finally Fixed the Test Runner (Mostly)
"><meta property="og:image:type" content="image/webp"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta property="og:image" name="twitter:image" content="https://daily-devops.net/images/testing-1200x630.png?v=a28cd5249c70dee66af43d4bdcf5f51a"><meta property="og:image:secure_url" content="https://daily-devops.net/images/testing-1200x630.png?v=a28cd5249c70dee66af43d4bdcf5f51a"><meta property="og:image:alt" name="twitter:image:alt" content=".NET 10 Testing: Microsoft Finally Fixed the Test Runner (Mostly)
"><meta property="og:image:type" content="image/png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><link rel="dns-prefetch" href="https://www.clarity.ms"><link rel="preconnect" href="https://www.clarity.ms" crossorigin><link rel="stylesheet" href="/css/style.min.0b2ef4378cd908eb695017aaa74603d244ff2b38c8068b4b51d76cad830c8ee5e3a40b67ab5b860a542c8bae73d8ba90cfbe9249b59c733a50de74cc32af818a.css" integrity="sha512-Cy70N4zZCOtpUBeqp0YD0kT/KzjIBotLUddsrYMMjuXjpAtnq1uGClQsi65z2LqQz76SSbWcczpQ3nTMMq+Big==" crossorigin="anonymous"><link rel="alternate" href='https://daily-devops.net/posts/dotnet-10-testing/' hreflang="x-default" title=".NET 10 Testing: Microsoft Finally Fixed the Test Runner (Mostly)
 &mdash; Daily DevOps & .NET"><link rel="canonical" href="https://daily-devops.net/posts/dotnet-10-testing/" hreflang="en-us" title=".NET 10 Testing: Microsoft Finally Fixed the Test Runner (Mostly)
 &mdash; Daily DevOps & .NET"><link rel="home" href="https://daily-devops.net/" hreflang="en-us" title="Daily DevOps & .NET"><link rel="next" href="https://daily-devops.net/posts/healthchecks-5-0/" hreflang="en-us" title="NetEvolve.HealthChecks 5.0: 27+ Targeted Probes, Zero Boilerplate
"><link rel="prev" href="https://daily-devops.net/posts/code-metrics-configuration/" hreflang="en-us" title="Code Metrics and Configuration: Beyond the Numbers Game"><link rel="author" href="https://daily-devops.net/authors/martin/" hreflang="en-us" title="Martin Stühmer &mdash; Daily DevOps & .NET"><meta name="giscus:backlink" content="https://daily-devops.net/posts/dotnet-10-testing/"><script defer src="/js/above.min.cb42b2c9a453e49e278326637d72d2f01e7f32e3f91e9cdde8fb587793d05514efd2f5cc5021c9658ca0f73876dbdcd1f7cb4a37c0bebc9df01110926b6d7cba.js" integrity="sha512-y0KyyaRT5J4ngyZjfXLS8B5/MuP5Hpzd6PtYd5PQVRTv0vXMUCHJZYyg9zh229zR98tKN8C+vJ3wERCSa218ug==" crossorigin="anonymous"></script><script type="text/javascript">(function(e,t,n,s,o,i,a){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)},i=t.createElement(s),i.async=1,i.src="https://www.clarity.ms/tag/"+o,a=t.getElementsByTagName(s)[0],a.parentNode.insertBefore(i,a)})(window,document,"clarity","script","o0pr4n9gg3")</script></head><body class="container"><header class="header"><a class="logo" href="/" title="Daily DevOps & .NET" rel="home"><figure class="page-logo"><picture><img src="/logo.svg?v=b9e294dc5c6fa04439c8c803d8e981a9" alt="Daily DevOps & .NET" title="Daily DevOps & .NET"></picture></figure><span class="title">Daily DevOps & .NET</span></a><nav class="menu"><button class="burger" aria-haspopup="true" aria-expanded="false" tabindex="0">
<i class="fas fa-burger"></i></button><ul class="navigation"><li class="active"><a href="/posts/">Posts</a></li><li><a href="/authors/">About us</a></li></ul></nav><div class="divider"></div></header><main class="body"><figure class="hero"><picture><source srcset="/images/testing-544x136.webp?v=10dd53160f62eb720bc554f1a54a2b92" type="image/webp" media="(max-width: 575.98px)"><source srcset="/images/testing-544x136.png?v=74049cc1fb40f4c2cd5e531ca64973b5" type="image/png" media="(max-width: 575.98px)"><source srcset="/images/testing-672x168.webp?v=977a6457e21803bedb7c506cc4b43de7" type="image/webp" media="(max-width: 767.98px)"><source srcset="/images/testing-672x168.png?v=fd265c0aeafc6176dc3a7f2450df4876" type="image/png" media="(max-width: 767.98px)"><source srcset="/images/testing-896x224.webp?v=3a05ea0e740dc2cc6ecb2d5aed531212" type="image/webp" media="(max-width: 991.98px)"><source srcset="/images/testing-896x224.png?v=b67e19722bc7192b893b7813d9efd5c8" type="image/png" media="(max-width: 991.98px)"><source srcset="/images/testing-1104x276.webp?v=13e767f8d8e4ba89db9b69d9c0010009" type="image/webp" media="(max-width: 1199.98px)"><source srcset="/images/testing-1104x276.png?v=68df2a69058e5a6659c9ef0d7fd03526" type="image/png" media="(max-width: 1199.98px)"><source srcset="/images/testing-1444x361.webp?v=379ec35a1941669913b57694affd5288" type="image/webp"><source srcset="/images/testing-1444x361.png?v=71658576413e8dd3a0d4efb1fe90beee" type="image/png"><img src="/images/testing.png?v=f76bce2e46f2702a98d85c6e3877291b" alt=".NET 10 Testing: Microsoft Finally Fixed the Test Runner (Mostly)
" loading="lazy" decoding="async" title=".NET 10 Testing: Microsoft Finally Fixed the Test Runner (Mostly)
"></picture></figure><article class="post"><header><h1>.NET 10 Testing: Microsoft Finally Fixed the Test Runner (Mostly)</h1></header><section class="content"><p>Microsoft just did something unusual: <em>they fixed a problem before most people realized they had it.</em></p><p>For years, <code>dotnet test</code> wasn&rsquo;t really a test runner—it was actually just a wrapper around <code>vstest.console.exe</code>, a legacy artifact from the pre-.NET-Core era that Microsoft couldn&rsquo;t quite kill. It worked, mostly, if you didn&rsquo;t think too hard about why your tests sometimes behaved differently in Visual Studio than in GitHub Actions, or why test discovery occasionally took longer than the tests themselves.</p><p>With .NET 10, Microsoft has finally integrated testing directly into the SDK through <strong>Microsoft.Testing.Platform (MTP)</strong>. The old VSTest infrastructure is now out. The new system runs tests in-process, unifies behavior across environments, and—this is actually the important part—finally respects your configuration files.</p><p>There&rsquo;s a catch, of course. There always is.</p><h2 id="from-test-wrapper-to-test-platform"><a href="/posts/dotnet-10-testing/#from-test-wrapper-to-test-platform" title="From Test Wrapper to Test Platform">From Test Wrapper to Test Platform</a></h2><p>Running tests in .NET used to mean choosing a framework—<a href="https://xunit.net/" target="_blank" rel="noopener external noreferrer">xUnit</a>, <a href="https://nunit.org/" target="_blank" rel="noopener external noreferrer">NUnit</a>, <a href="https://learn.microsoft.com/en-us/dotnet/core/testing/unit-testing-with-mstest" target="_blank" rel="noopener external noreferrer">MSTest</a>, or the newer <a href="https://tunit.dev/" target="_blank" rel="noopener external noreferrer">TUnit</a>—and then essentially just hoping <code>dotnet test</code> could somehow figure out how to talk to it. Each framework had its own test adapter. Each adapter had its own quirks. Your CI pipeline basically just crossed its fingers and hoped for green checkmarks.</p><p>The result? Test execution that varied subtly between your laptop, your colleague&rsquo;s laptop, and the build server. Debugging test failures meant first figuring out <em>which version of which adapter was running where</em>.</p><p>Microsoft.Testing.Platform changes that architecture. Instead of spawning separate processes and negotiating through adapters, MTP embeds the test runner directly into the SDK. Discovery, execution, and reporting now follow a single, predictable path. Tests run in-process. The CLI is cleaner. The performance is measurably better in projects with large test suites.</p><p>Enabling it requires exactly four lines in your <code>global.json</code>:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;test&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;runner&#34;</span><span class="p">:</span> <span class="s2">&#34;Microsoft.Testing.Platform&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>No SDK pinning required. No complicated setup. Just those four lines, and .NET 10 switches to the new test engine automatically.</p><p>The simplicity is almost suspicious.</p><h2 id="what-actually-improves-and-what-doesnt"><a href="/posts/dotnet-10-testing/#what-actually-improves-and-what-doesnt" title="What Actually Improves (And What Doesn&rsquo;t)">What Actually Improves (And What Doesn&rsquo;t)</a></h2><p>Let&rsquo;s be specific. MTP isn&rsquo;t magic—it&rsquo;s engineering. Here&rsquo;s what changes when you enable it:</p><p><strong>Test discovery is faster.</strong> In a project with ~3,500 tests, discovery dropped from 8 seconds to under 3 on my local machine. That&rsquo;s honestly not earth-shattering, but it&rsquo;s definitely noticeable when you&rsquo;re running focused test sets repeatedly during development. Over a typical workday with 50 test runs? That actually saves roughly 4 minutes. Not revolutionary, but certainly not nothing either.</p><p><strong>The CLI makes sense now.</strong> Previously, <code>dotnet test --filter</code> required arcane syntax and those bizarre <code>--</code> separators to pass arguments through to the adapter. MTP removes that layer of indirection. The commands do what you&rsquo;d expect without translation.</p><p><strong>Environment consistency improves.</strong> Because the test runner is part of the SDK, your local machine and your CI pipeline execute tests the same way—assuming you actually configure your pipeline correctly (more on that disaster shortly).</p><p><strong>But performance gains aren&rsquo;t universal.</strong> If your tests are already fast, you probably won&rsquo;t see dramatic improvements. MTP mainly optimizes infrastructure overhead, not slow database calls or badly written assertions. Don&rsquo;t expect miracles if your test suite still takes 20 minutes because it&rsquo;s hitting real APIs.</p><p>And here&rsquo;s the part Microsoft doesn&rsquo;t emphasize: <strong>MTP won&rsquo;t save you from bad tests.</strong> If your test suite is flaky, brittle, or poorly isolated, the new platform just runs that mess faster.</p><h3 id="what-about-visual-studio-integration"><a href="/posts/dotnet-10-testing/#what-about-visual-studio-integration" title="What about Visual Studio integration?">What about Visual Studio integration?</a></h3><p>Visual Studio 17.14 or later integrates with MTP. Earlier versions rely on VSTest and may behave differently. If your team uses mixed VS versions, validate results locally with the CLI to avoid IDE-specific discrepancies.</p><h2 id="the-ci-pipeline-trap-and-how-to-avoid-it"><a href="/posts/dotnet-10-testing/#the-ci-pipeline-trap-and-how-to-avoid-it" title="The CI Pipeline Trap (And How to Avoid It)">The CI Pipeline Trap (And How to Avoid It)</a></h2><p>Here&rsquo;s where things get entertaining.</p><p>You add that <code>global.json</code> snippet. Tests run perfectly on your machine. You commit, push, and watch your GitHub Actions pipeline&mldr; fail spectacularly.</p><p>Why? Because GitHub&rsquo;s hosted runners don&rsquo;t automatically respect your <code>global.json</code>. They just use whatever SDK version happens to be installed—often an older one that doesn&rsquo;t even support MTP. Your carefully configured local environment and your CI pipeline are now essentially running completely different test infrastructure.</p><p>I learned this the hard way when a colleague spent two hours debugging &ldquo;flaky&rdquo; tests that weren&rsquo;t actually flaky at all. The tests validated timeout behavior in an async workflow—they passed consistently with MTP locally and then failed consistently with VSTest in CI. Same code, same timeout values, completely different test runner behavior. VSTest&rsquo;s process isolation apparently meant slightly different timing characteristics. We only figured it out after painstakingly comparing the test execution logs line by line and finally noticing the runner version mismatch.</p><p>The fix is one line—but you have to know it exists:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl">- <span class="nt">uses</span><span class="p">:</span><span class="w"> </span><span class="l">actions/setup-dotnet@v5</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">with</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">global-json-file</span><span class="p">:</span><span class="w"> </span><span class="s1">&#39;./global.json&#39;</span><span class="w">
</span></span></span><span class="line"><span class="cl">- <span class="nt">run</span><span class="p">:</span><span class="w"> </span><span class="l">dotnet test</span><span class="w">
</span></span></span></code></pre></div><p>That <code>global-json-file</code> parameter forces the action to actually read your configuration. Without it, you&rsquo;re deploying tests with one runner and debugging them with another.</p><p>If you don&rsquo;t specify this explicitly, your <code>global.json</code> is basically just decorative. It just sits in your repository looking official while your pipeline ignores it completely. I&rsquo;ve actually seen teams add comments to their <code>global.json</code> files carefully explaining why certain settings exist, not realizing the entire file wasn&rsquo;t even being used. That&rsquo;s not configuration—that&rsquo;s just theater.</p><h2 id="version-compatibility-or-who-gets-left-behind"><a href="/posts/dotnet-10-testing/#version-compatibility-or-who-gets-left-behind" title="Version Compatibility (Or: Who Gets Left Behind)">Version Compatibility (Or: Who Gets Left Behind)</a></h2><p>MTP doesn&rsquo;t support every test framework version ever released. Microsoft drew a line, and some older projects sit on the wrong side of it.</p><p>To use Microsoft.Testing.Platform, your test frameworks need these minimum versions:</p><ul><li><strong>xUnit</strong> → Version <strong>3.x</strong> or later</li><li><strong>MSTest</strong> → Version <strong>3.2.0</strong> or later</li><li><strong>NUnit</strong> → <strong>NUnit3TestAdapter 5.0.0</strong> or later</li><li><strong>TUnit</strong> → Works out of the box (it was designed with MTP in mind)</li><li><strong>Visual Studio</strong> → Version <strong>17.14</strong> or later for full integration</li></ul><p>If you&rsquo;re running older versions, the SDK simply won&rsquo;t negotiate. It fails hard. No fallback to VSTest, no warning, just an error message telling you to upgrade.</p><p>That&rsquo;s actually good design. Ambiguity in test execution creates exactly the kind of &ldquo;works on my machine&rdquo; disasters MTP is supposed to prevent. Better to fail explicitly than to silently run different infrastructure depending on what&rsquo;s installed.</p><p>But it does mean migration isn&rsquo;t optional if you&rsquo;re upgrading to .NET 10. You can&rsquo;t enable MTP halfway. Either your entire test suite supports it, or you don&rsquo;t use it at all.</p><h2 id="migration-strategy-or-how-not-to-break-everything"><a href="/posts/dotnet-10-testing/#migration-strategy-or-how-not-to-break-everything" title="Migration Strategy (Or: How Not to Break Everything)">Migration Strategy (Or: How Not to Break Everything)</a></h2><p>Migrating to MTP isn&rsquo;t technically complicated, but it does actually require coordination. You can&rsquo;t just enable it in isolation—everyone on the team needs to be running compatible tools, or the test results will simply stop being reliable.</p><p>Here&rsquo;s a migration approach that won&rsquo;t cause chaos:</p><p><strong>1. Audit your test framework versions first.</strong>
Check every test project. If you&rsquo;re running xUnit 2.x or MSTest 2.x, you&rsquo;re upgrading before you can enable MTP. No shortcuts.</p><p><strong>2. Add the <code>global.json</code> configuration.</strong>
Start with the minimal snippet. You don&rsquo;t need to pin an SDK version unless you have specific compatibility requirements elsewhere.</p><p><strong>3. Update your CI/CD pipelines.</strong>
Add the <code>global-json-file</code> parameter to your <code>setup-dotnet</code> action. Test it on a branch before merging. Verify that the pipeline is actually using MTP by checking the test output logs.</p><p><strong>4. Run tests locally and in CI—compare the results.</strong>
If they differ, you&rsquo;ve found a configuration issue. Fix it now, before it becomes a debugging nightmare three months from now. Pay special attention to tests that involve timing, parallelization, or resource cleanup—these are the ones most likely to behave differently between test runners.</p><p>If you&rsquo;ve read <a href="/posts/tests-are-lying/">&ldquo;Your Tests Are Lying — Mutation Testing in .NET&rdquo;</a>, you know how dangerous it is when tests pass for the wrong reasons. MTP reduces that risk—but only if your environments are actually configured consistently.</p><h2 id="when-not-to-migrate-yes-really"><a href="/posts/dotnet-10-testing/#when-not-to-migrate-yes-really" title="When Not to Migrate (Yes, Really)">When Not to Migrate (Yes, Really)</a></h2><p>Not every project should rush into MTP. Here are scenarios where you might want to wait:</p><p><strong>Legacy test suites with heavy VSTest dependencies.</strong> If your tests rely on specific VSTest console runners, custom adapters, or undocumented behavior, migration will break things. You&rsquo;ll need to refactor or rewrite parts of your test infrastructure.</p><p><strong>Projects still on .NET 8 LTS.</strong> MTP is a .NET 10 feature. If you&rsquo;re staying on an LTS version for stability, you&rsquo;re essentially stuck with VSTest. That&rsquo;s fine—VSTest still works. It&rsquo;s just not getting any new features.</p><p><strong>Teams without time to validate the migration.</strong> Half-migrating is worse than not migrating. If you can&rsquo;t dedicate time to verify that tests behave identically across environments, defer the change until you can.</p><p>MTP is definitely an improvement, but it&rsquo;s not urgent. If your current test infrastructure already works reliably, you&rsquo;re really not missing out by waiting.</p><h2 id="what-this-actually-means-for-your-workflow"><a href="/posts/dotnet-10-testing/#what-this-actually-means-for-your-workflow" title="What This Actually Means for Your Workflow">What This Actually Means for Your Workflow</a></h2><p>The shift to MTP changes how you think about test configuration. Your <code>global.json</code> file is no longer just an SDK hint—it&rsquo;s a binding contract. The SDK reads it, respects it, and enforces it. If your pipeline isn&rsquo;t configured to honor that contract, your tests will diverge silently between environments.</p><p>That&rsquo;s both the strength and the risk of this change. MTP removes ambiguity, but only if you configure it correctly everywhere. Miss one environment, and you&rsquo;re back to debugging phantom failures that only reproduce in CI.</p><p>The good news? Once configured properly, tests become predictable. The bad news? Getting there requires discipline, not just documentation.</p><h2 id="should-you-migrate-now"><a href="/posts/dotnet-10-testing/#should-you-migrate-now" title="Should You Migrate Now?">Should You Migrate Now?</a></h2><p>If you&rsquo;re already on .NET 10, yes. The benefits clearly outweigh the setup cost, especially if you&rsquo;ve already dealt with flaky CI pipelines or inconsistent test behavior across environments.</p><p>If you&rsquo;re on an LTS version and your tests are stable, there&rsquo;s really no rush. VSTest isn&rsquo;t going anywhere immediately, and MTP will still be there when you eventually upgrade.</p><p>But if you&rsquo;re planning to move to .NET 10 anyway, enable MTP early in the migration process. It&rsquo;s easier to validate test behavior during a planned upgrade than to debug it six months later when the root cause has been buried under other changes.</p><p>Add the four lines to <code>global.json</code>. Update your CI config. Upgrade your test frameworks. Run the tests. Compare the results.</p><p>If they match—and they should—you&rsquo;re done. If they don&rsquo;t, you&rsquo;ve found a configuration problem that would have bitten you eventually anyway. Better to find it now during a planned migration than at 2 AM when production is down and your tests are lying to you about what&rsquo;s safe to deploy.</p><p>Microsoft fixed the test runner. Whether you use it or keep debugging phantom CI failures is your choice—but when the next &ldquo;works on my machine&rdquo; ticket comes in, at least you&rsquo;ll know exactly why.</p></section><h2>Comments</h2><aside class="giscus"></aside><script src="https://giscus.app/client.js" data-repo="dailydevops/dailydevops.github.io" data-repo-id="R_kgDOHA8eFg" data-category="Announcements" data-category-id="DIC_kwDOHA8eFs4COIqL" data-mapping="pathname" data-strict="1" data-reactions-enabled="0" data-emit-metadata="0" data-input-position="bottom" data-theme="light" data-lang="en" crossorigin="anonymous" async></script></article><aside class="sidebar divider"><section class="sidecar info"><ul><li><time datetime="2025-11-20T17:00:00+01:00">Published on 11/20/25 5:00 pm</time></li><li>Read in 9 minutes</li></ul></section><section class="sidecar series"><header><h2>Series content</h2></header><a href="https://daily-devops.net/posts/dotnet-10-released/" title=".NET 10: Boring by Design, Reliable by Default
" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right"></i>&nbsp;
.NET 10: Boring by Design, Reliable by Default
</a><a href="https://daily-devops.net/posts/dotnet-10-testing/" title=".NET 10 Testing: Microsoft Finally Fixed the Test Runner (Mostly)
" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right"></i>&nbsp;
.NET 10 Testing: Microsoft Finally Fixed the Test Runner (Mostly)
</a><a href="https://daily-devops.net/posts/dotnet-power-of-ten-rules/" title="Power of Ten Rules: More Relevant Than Ever for .NET" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right"></i>&nbsp;
Power of Ten Rules: More Relevant Than Ever for .NET
</a><a href="https://daily-devops.net/posts/dotnet-10-cli-devops/" title=".NET CLI 10 – Microsoft Finally Realizes DevOps Exists" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right"></i>&nbsp;
.NET CLI 10 – Microsoft Finally Realizes DevOps Exists</a></section><section class="sidecar author"><header><h2><a href="/authors/martin/" rel="author" title="Martin Stühmer">Author Martin Stühmer</a></h2></header><figure class="round"><picture><img src="https://www.gravatar.com/avatar/6da4a47ff9cc2b750452225fdb2582f7?d=identicon&amp;s=200" alt="Martin Stühmer" loading="lazy" decoding="async" title="Martin Stühmer"></picture></figure><section class="content">Martin is a software architect and developer who has spent nearly two decades navigating the .NET ecosystem from Framework 2.0 to modern .NET 10. As Director Consulting Services at CGI and a Microsoft Certified Trainer, he specializes in cloud-native solutions, enterprise architecture, and Risk and Cost Driven Architecture (RCDA). His mission is straightforward - help teams build quality software that survives contact with production. He contributes to open-source communities through NuGet packages, writes about pragmatic software engineering on this blog, and trains developers who want substance over buzzwords.</section><a class="link" href="/authors/martin/" rel="author" title="Martin Stühmer"></a></section><section class="sidecar social"><header><h2>Social media</h2></header><a class="icon bluesky" href="https://bsky.app/profile/samtrion.net" rel="noopener external" title="Follow me on Bluesky" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-bluesky fa-stack-1x fa-inverse"></i>
</span></a><a class="icon github" href="https://github.com/samtrion" rel="noopener external" title="Follow me on GitHub" target="_blank"><i class="fa-brands fa-fw fa-github fa-2x"></i></a>
<a class="icon linkedin" href="https://www.linkedin.com/in/martin-stuehmer" rel="noopener external" title="Follow me on LinkedIn" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-linkedin-in fa-stack-1x fa-inverse"></i>
</span></a><a class="icon stackoverflow" href="https://stackoverflow.com/users/10574963" rel="noopener external" title="Follow me on Stack Overflow" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-stack-overflow fa-stack-1x fa-inverse"></i>
</span></a><a class="icon mail" href="mailto:martin@daily-devops.net" title="Contact me by e-mail" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
</span></a><a class="icon feed" href="/authors/martin/feed.rss" title="My RSS feed" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></section><section class="sidecar share"><header><h2>Share this content</h2></header><a class="icon linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fdaily-devops.net%2fposts%2fdotnet-10-testing%2f&text=.NET%2010%20Testing%3a%20Microsoft%20Finally%20Fixed%20the%20Test%20Runner%20%28Mostly%29%0a%20%26mdash%3b%20Daily%20DevOps%20%26%20.NET" target="_blank" rel="noopener external" aria-label="Share on LinkedIn" title="Share on LinkedIn" target="_blank"><i class="fa-brands fa-fw fa-linkedin-in fa-2x"></i></a>
<a class="icon bluesky" href="https://bsky.app/intent/compose?text=.NET%2010%20Testing%3a%20Microsoft%20Finally%20Fixed%20the%20Test%20Runner%20%28Mostly%29%0a%20%26mdash%3b%20Daily%20DevOps%20%26%20.NET%20https%3a%2f%2fdaily-devops.net%2fposts%2fdotnet-10-testing%2f" target="_blank" rel="noopener external" aria-label="Share on Bluesky" title="Share on Bluesky" target="_blank"><i class="fa-brands fa-fw fa-bluesky fa-2x"></i></a></section><section class="sidecar tags"><header><h2>Tags</h2></header><ul><li class="tag"><a href="/tags/dotnet/" hreflang="en" rel="tag" title=".NET"><i class="fas fa-tag"></i>&nbsp;.NET</a></li><li class="tag"><a href="/tags/csharp/" hreflang="en" rel="tag" title="C#"><i class="fas fa-tag"></i>&nbsp;C#</a></li><li class="tag"><a href="/tags/devops/" hreflang="en" rel="tag" title="DevOps"><i class="fas fa-tag"></i>&nbsp;DevOps</a></li><li class="tag"><a href="/tags/github-actions/" hreflang="en" rel="tag" title="GitHub Actions"><i class="fas fa-tag"></i>&nbsp;GitHub Actions</a></li><li class="tag"><a href="/tags/softwareengineering/" hreflang="en" rel="tag" title="Software Engineering"><i class="fas fa-tag"></i>&nbsp;Software Engineering</a></li><li class="tag"><a href="/tags/testing/" hreflang="en" rel="tag" title="Testing"><i class="fas fa-tag"></i>&nbsp;Testing</a></li></ul></section><section class="sidecar related"><header><h2>Related content</h2></header><article class="post"><figure class="square"><picture><source srcset="/images/vibecoding-80x80.webp?v=3f8c50e71c82a10bfe515499996ebab4" type="image/webp"><source srcset="/images/vibecoding-80x80.png?v=7617a55dbdf6bd7939238821b77c1a82" type="image/png"><img src="/images/vibecoding.png?v=9a36076d86533930bbd6319c257968b9" alt="Vibe Coding in .NET: Creative Catalyst or Maintenance Risk?" loading="lazy" decoding="async" title="Vibe Coding in .NET: Creative Catalyst or Maintenance Risk?"></picture></figure><header><h2><a href="/posts/vibe-coding-isnt-wrong-its-unfinished/" rel="bookmark">Vibe Coding in .NET: Creative Catalyst or Maintenance Risk?</a></h2></header><section class="content"><p>In the world of software development, there’s a recurring tension between <strong>discipline and improvisation</strong>. Somewhere along that spectrum lies a phenomenon increasingly referred to as <strong>Vibe Coding</strong>. The term evokes a style of development where engineers follow intuition and momentum rather than formal plans, processes, or design patterns.</p><p>It’s fast, fluid, and occasionally brilliant. But is it sustainable in a .NET-based enterprise context?</p></section></article><article class="post"><figure class="square"><picture><source srcset="/images/csharp-80x80.webp?v=0f7110ee2851196f14d99463a855759d" type="image/webp"><source srcset="/images/csharp-80x80.png?v=c5d685b0d4fa9ec69bd959ee04beb903" type="image/png"><img src="/images/csharp.png?v=21ff9dcf5d1da7bfa80141c972c117da" alt="Code Metrics and Configuration: Beyond the Numbers Game" loading="lazy" decoding="async" title="Code Metrics and Configuration: Beyond the Numbers Game"></picture></figure><header><h2><a href="/posts/code-metrics-configuration/" rel="bookmark">Code Metrics and Configuration: Beyond the Numbers Game</a></h2></header><section class="content"><p>Code metrics have become a standard feature in modern development environments, yet their implementation and interpretation often leave much to be desired. While Visual Studio and .NET provide comprehensive code metrics analysis, the way these metrics are configured, presented, and (more critically) acted upon reveals a fundamental disconnect between measurement and meaningful improvement.</p><p>What code metrics actually measure, how to configure them properly, and (more importantly) why blindly following thresholds without understanding context is, frankly, a recipe for misguided refactoring efforts that waste your team&rsquo;s time and actively damage your codebase.</p></section></article><article class="post"><figure class="square"><picture><source srcset="/images/dotnet-paradox-80x80.webp?v=a76b10cb59eb84e618d091091ee7d79c" type="image/webp"><source srcset="/images/dotnet-paradox-80x80.png?v=29e2f5a0c373c3060fc6fc04c3fd3c63" type="image/png"><img src="/images/dotnet-paradox.png?v=fab3db4941c79e6e7ad156d66492c87b" alt=".NET 10 and the Release Cycle Paradox" loading="lazy" decoding="async" title=".NET 10 and the Release Cycle Paradox"></picture></figure><header><h2><a href="/posts/dotnet-10-release-cycle-paradox/" rel="bookmark">.NET 10 and the Release Cycle Paradox</a></h2></header><section class="content"><p>.NET’s yearly rhythm has become a symbol of stability — yet also a source of pressure.
The <strong>release cycle paradox</strong> describes the tension between predictability and exhaustion: a release schedule that keeps the ecosystem healthy, but teams constantly catching up.</p><p>With .NET 10 on the horizon, developers must learn to navigate this rhythm rather than fight it.</p></section></article></section></aside><nav class="pager"><a class="next" href="/posts/healthchecks-5-0/" title="NetEvolve.HealthChecks 5.0: 27+ Targeted Probes, Zero Boilerplate
" rel="next"><span class="sub"><i class="fas fa-backward"></i>&emsp;Next</span><p class="title">NetEvolve.HealthChecks 5.0: 27+ Targeted Probes, Zero Boilerplate</p></a><a class="prev" href="/posts/code-metrics-configuration/" title="Code Metrics and Configuration: Beyond the Numbers Game" rel="prev"><span class="sub">Previous&emsp;<i class="fas fa-forward"></i></span><p class="title">Code Metrics and Configuration: Beyond the Numbers Game</p></a></nav></main><footer class="footer"><div class="divider"></div><nav><ul class="navigation"><li><a href="/tags/">Tags</a></li><li><a href="/legal-notice/">Legal notice</a></li></ul></nav><div class="copyright">&copy; 2023 - 2026 Daily DevOps & .NET</div></footer><script defer src="/js/below.min.a6ce9164454b6077f17ae856f280442d9f3a1e21f06189f71c21f75144b22a0c8cf32bafd61d440e9d90ca02bf738b6a8ef19f5ec20285d8ca574f98c91ebaf2.js" integrity="sha512-ps6RZEVLYHfxeuhW8oBELZ86HiHwYYn3HCH3UUSyKgyM8yuv1h1EDp2QygK/c4tqjvGfXsIChdjKV0+YyR668g==" crossorigin="anonymous"></script><img class="vgwort" src="https://vg06.met.vgwort.de/na/e0f5e0a6f583431588f690a642a57837" width="1" height="1" alt="VG Wort" title="VG Wort"></body></html>