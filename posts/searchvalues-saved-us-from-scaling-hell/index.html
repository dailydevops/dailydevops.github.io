<!doctype html><html class="no-js" lang="en" dir="ltr"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="theme-color" content="#15a"><title>How SearchValues&lt;T> Saved Us From Scaling Hell — Daily DevOps & .NET</title><meta name="description" content="While you&rsquo;re busy optimizing database queries and adding cache layers, thousands of string searches per second are quietly eating your CPU budget. The …"><meta name="twitter:description" property="og:description" content="While you&rsquo;re busy optimizing database queries and adding cache layers, thousands of string searches per second are quietly eating your CPU budget. The …"><meta name="author" content="Martin Stühmer"><link rel="icon" href="/logo.svg?v=b9e294dc5c6fa04439c8c803d8e981a9" sizes="any" type="image/svg+xml"><meta name="twitter:title" property="og:title" content="How SearchValues Saved Us From Scaling Hell — Daily DevOps & .NET"><meta property="og:updated_time" content="2025-10-20T18:36:01+02:00"><meta property="article:modified_time" content="2025-10-20T18:36:01+02:00"><meta property="article:published_time" content="2025-10-20T17:30:00+01:00"><meta property="og:type" content="article"><meta property="og:site_name" content="Daily DevOps & .NET"><meta property="og:url" content="https://daily-devops.net/posts/searchvalues-saved-us-from-scaling-hell/"><meta property="og:locale" content="en_US"><meta name="twitter:card" content="summary_large_image"><meta property="og:image" name="twitter:image" content="https://daily-devops.net/images/csharp-1200x630.webp?v=5c7eb45c8a150e022013b4e27111196e"><meta property="og:image:secure_url" content="https://daily-devops.net/images/csharp-1200x630.webp?v=5c7eb45c8a150e022013b4e27111196e"><meta property="og:image:alt" name="twitter:image:alt" content="How SearchValues Saved Us From Scaling Hell"><meta property="og:image:type" content="image/webp"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta property="og:image" name="twitter:image" content="https://daily-devops.net/images/csharp-1200x630.png?v=547760eed18b566792e92844110e5c96"><meta property="og:image:secure_url" content="https://daily-devops.net/images/csharp-1200x630.png?v=547760eed18b566792e92844110e5c96"><meta property="og:image:alt" name="twitter:image:alt" content="How SearchValues Saved Us From Scaling Hell"><meta property="og:image:type" content="image/png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><link rel="dns-prefetch" href="https://www.clarity.ms"><link rel="preconnect" href="https://www.clarity.ms" crossorigin><link rel="stylesheet" href="/css/style.min.7e76e405b6ecafd3553b4adc6e80357de4c3f62b201446bee12f4da2c8e7bc55d5654111192754d7cad95b2966e591d3a0463e82627a4b4a962399c6e58159d5.css" integrity="sha512-fnbkBbbsr9NVO0rcboA1feTD9isgFEa+4S9NosjnvFXVZUERGSdU18rZWylm5ZHToEY+gmJ6S0qWI5nG5YFZ1Q==" crossorigin="anonymous"><link rel="alternate" href='https://daily-devops.net/posts/searchvalues-saved-us-from-scaling-hell/' hreflang="x-default" title="How SearchValues Saved Us From Scaling Hell &mdash; Daily DevOps & .NET"><link rel="canonical" href="https://daily-devops.net/posts/searchvalues-saved-us-from-scaling-hell/" hreflang="en-us" title="How SearchValues Saved Us From Scaling Hell &mdash; Daily DevOps & .NET"><link rel="home" href="https://daily-devops.net/" hreflang="en-us" title="Daily DevOps & .NET"><link rel="next" href="https://daily-devops.net/posts/compositeformat-performance-boost/" hreflang="en-us" title="Stop Parsing the Same String Twice: CompositeFormat in .NET"><link rel="prev" href="https://daily-devops.net/posts/clean-code-lip-service-not-a-standard/" hreflang="en-us" title="Clean Code: A Lip Service, Not a Standard
"><link rel="author" href="https://daily-devops.net/authors/martin/" hreflang="en-us" title="Martin Stühmer &mdash; Daily DevOps & .NET"><meta name="giscus:backlink" content="https://daily-devops.net/posts/searchvalues-saved-us-from-scaling-hell/"><script defer src="/js/above.min.cb42b2c9a453e49e278326637d72d2f01e7f32e3f91e9cdde8fb587793d05514efd2f5cc5021c9658ca0f73876dbdcd1f7cb4a37c0bebc9df01110926b6d7cba.js" integrity="sha512-y0KyyaRT5J4ngyZjfXLS8B5/MuP5Hpzd6PtYd5PQVRTv0vXMUCHJZYyg9zh229zR98tKN8C+vJ3wERCSa218ug==" crossorigin="anonymous"></script><script type="text/javascript">(function(e,t,n,s,o,i,a){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)},i=t.createElement(s),i.async=1,i.src="https://www.clarity.ms/tag/"+o,a=t.getElementsByTagName(s)[0],a.parentNode.insertBefore(i,a)})(window,document,"clarity","script","o0pr4n9gg3")</script></head><body class="container"><header class="header"><a class="logo" href="/" title="Daily DevOps & .NET" rel="home"><figure class="page-logo"><picture><img src="/logo.svg?v=b9e294dc5c6fa04439c8c803d8e981a9" alt="Daily DevOps & .NET" title="Daily DevOps & .NET"></picture></figure><span class="title">Daily DevOps & .NET</span></a><nav class="menu"><button class="burger" aria-haspopup="true" aria-expanded="false" tabindex="0">
<i class="fas fa-burger"></i></button><ul class="navigation"><li class="active"><a href="/posts/">Posts</a></li><li><a href="/authors/">About us</a></li></ul></nav><div class="divider"></div></header><main class="body"><figure class="hero"><picture><source srcset="/images/csharp-544x136.webp?v=9bbfeabee0c6b19776eb4bae8fca211d" type="image/webp" media="(max-width: 575.98px)"><source srcset="/images/csharp-544x136.png?v=038bf53dc3518576014653d5dda06a5e" type="image/png" media="(max-width: 575.98px)"><source srcset="/images/csharp-672x168.webp?v=3fa46357fff03c0c4b798f079a602df4" type="image/webp" media="(max-width: 767.98px)"><source srcset="/images/csharp-672x168.png?v=a18b6001d35dd946ef8b9a47af6e86ed" type="image/png" media="(max-width: 767.98px)"><source srcset="/images/csharp-896x224.webp?v=5ee0ce0eebe6b2d117a1debafde6b317" type="image/webp" media="(max-width: 991.98px)"><source srcset="/images/csharp-896x224.png?v=7eb31dd18bd53b0bf209074e79eb8f2f" type="image/png" media="(max-width: 991.98px)"><source srcset="/images/csharp-1104x276.webp?v=c0d049427db1a4417293102205f2a711" type="image/webp" media="(max-width: 1199.98px)"><source srcset="/images/csharp-1104x276.png?v=b760a9ea4f05629aa6cd15bbdcdf9d16" type="image/png" media="(max-width: 1199.98px)"><source srcset="/images/csharp-1444x361.webp?v=ae2c09968f0fee3e1b5cc2c566fccd94" type="image/webp"><source srcset="/images/csharp-1444x361.png?v=e71fca8a8b32ef8c283bb0b4c8af95fb" type="image/png"><img src="/images/csharp.png?v=21ff9dcf5d1da7bfa80141c972c117da" alt="How SearchValues Saved Us From Scaling Hell" loading="lazy" decoding="async" title="How SearchValues Saved Us From Scaling Hell"></picture></figure><article class="post"><header><h1>How SearchValues<t> Saved Us From Scaling Hell</h1></header><section class="content"><p>Your string operations are killing your API. You just haven&rsquo;t measured it yet.</p><p>While you&rsquo;re busy optimizing database queries and adding cache layers, thousands of string searches per second are quietly eating your CPU budget. The problem isn&rsquo;t visible in your APM dashboard because it&rsquo;s distributed across every request. But it&rsquo;s there. Compounding. Scaling linearly with load.</p><p>I discovered this the hard way when a log processing API started choking under production traffic. The bottleneck? String validation and sanitization. The fix? A .NET 8 feature that delivered a <strong>5x performance improvement</strong> and let us shut down servers instead of adding them. And it&rsquo;s gotten even better in .NET 9 and 10.</p><p><code>SearchValues&lt;T></code> isn&rsquo;t a nice-to-have optimization. It&rsquo;s the difference between infrastructure costs that scale with your success versus infrastructure costs that scale with your inefficiency.</p><h2 id="the-real-problem-string-operations-dont-scale-like-you-think"><a href="/posts/searchvalues-saved-us-from-scaling-hell/#the-real-problem-string-operations-dont-scale-like-you-think" title="The Real Problem: String Operations Don&rsquo;t Scale Like You Think">The Real Problem: String Operations Don&rsquo;t Scale Like You Think</a></h2><p>Here&rsquo;s what nobody tells you about string operations: they scale linearly with load. Double the traffic? Double the CPU usage. Add more features that parse strings? Multiply the pain.</p><p>Traditional approaches using <code>string.IndexOfAny()</code> or custom loops work fine when you&rsquo;re processing dozens of requests per second. They fail silently when you&rsquo;re processing thousands. No exceptions. No errors. Just slow, expensive CPU burn that compounds into massive infrastructure waste.</p><p>Consider a real scenario: a log aggregation service processing application logs in real-time. Each log entry needs sanitization, sensitive data detection, and validation before storage. That&rsquo;s multiple string operations per log entry. Thousands of log entries per second. Millions of string operations per minute.</p><p>With traditional methods, you&rsquo;re leaving performance on the table. Modern CPUs have SIMD instructions that can process multiple characters simultaneously, but <code>IndexOfAny()</code> doesn&rsquo;t use them consistently. It&rsquo;s a generic solution for a problem that benefits from specialization.</p><p>That&rsquo;s where <code>SearchValues&lt;T></code> comes in. It&rsquo;s a frozen, immutable set of values that .NET analyzes once at creation time, then optimizes specifically for your search pattern using the fastest algorithm available, whether that&rsquo;s SIMD vectorization, bitmap lookups, or other strategies depending on your value set. The difference isn&rsquo;t marginal. It&rsquo;s transformational.</p><h2 id="what-makes-searchvaluest-different"><a href="/posts/searchvalues-saved-us-from-scaling-hell/#what-makes-searchvaluest-different" title="What Makes SearchValues<T> Different?">What Makes <code>SearchValues&lt;T></code> Different?</a></h2><p><code>SearchValues&lt;T></code> was introduced in .NET 8. Most developers still haven&rsquo;t heard of it. That&rsquo;s a mistake that&rsquo;s costing infrastructure budget.</p><p>When you create a <code>SearchValues&lt;T></code> instance, .NET analyzes your value set <strong>once</strong> and selects the most efficient search algorithm. SIMD vectorization when possible. Bitmap lookups for dense character sets. Optimized branching for sparse sets. The runtime chooses. You don&rsquo;t.</p><p>You pay the analysis cost once at startup. Then you reuse that optimized instance across millions of operations. That&rsquo;s the trade-off: slightly more expensive creation, dramatically cheaper execution.</p><blockquote><p>TLDR; Pure performance win.</p></blockquote><h2 id="net-9-and-net-10-getting-even-faster"><a href="/posts/searchvalues-saved-us-from-scaling-hell/#net-9-and-net-10-getting-even-faster" title=".NET 9 and .NET 10: Getting Even Faster">.NET 9 and .NET 10: Getting Even Faster</a></h2><p><code>SearchValues&lt;T></code> didn&rsquo;t stop at .NET 8. Microsoft kept pushing performance further with each release, expanding both capabilities and raw speed.</p><h3 id="net-9-multi-substring-search"><a href="/posts/searchvalues-saved-us-from-scaling-hell/#net-9-multi-substring-search" title=".NET 9: Multi-Substring Search">.NET 9: Multi-Substring Search</a></h3><p>.NET 8 gave us <code>SearchValues&lt;char></code> and <code>SearchValues&lt;byte></code> for character-level searches. .NET 9 expands this with <code>SearchValues&lt;string></code> for searching multiple substrings within a string.</p><p><strong>Before (Regex):</strong></p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="c1">// Looking for &#34;error&#34;, &#34;warning&#34;, or &#34;critical&#34; (case-insensitive)</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">regex</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Regex</span><span class="p">(</span><span class="s">&#34;(?i)error|warning|critical&#34;</span><span class="p">,</span> <span class="n">RegexOptions</span><span class="p">.</span><span class="n">Compiled</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">found</span> <span class="p">=</span> <span class="n">regex</span><span class="p">.</span><span class="n">IsMatch</span><span class="p">(</span><span class="n">logMessage</span><span class="p">);</span>
</span></span></code></pre></div><p><strong>After (SearchValues):</strong></p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="kd">private</span> <span class="kd">static</span> <span class="k">readonly</span> <span class="n">SearchValues</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">LogKeywords</span> <span class="p">=</span> 
</span></span><span class="line"><span class="cl">    <span class="n">SearchValues</span><span class="p">.</span><span class="n">Create</span><span class="p">([</span><span class="s">&#34;error&#34;</span><span class="p">,</span> <span class="s">&#34;warning&#34;</span><span class="p">,</span> <span class="s">&#34;critical&#34;</span><span class="p">],</span> <span class="n">StringComparison</span><span class="p">.</span><span class="n">OrdinalIgnoreCase</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">found</span> <span class="p">=</span> <span class="n">logMessage</span><span class="p">.</span><span class="n">AsSpan</span><span class="p">().</span><span class="n">ContainsAny</span><span class="p">(</span><span class="n">LogKeywords</span><span class="p">);</span>
</span></span></code></pre></div><p>The Regex compiler in .NET 9 <strong>uses this automatically</strong> when it detects multi-substring patterns. Call it directly to skip regex parsing overhead entirely.</p><p>Multi-substring searches in log analysis became 3-4x faster in .NET 9. Patterns that were &ldquo;too expensive&rdquo; for every log entry suddenly became viable for real-time alerting.</p><blockquote><p>TLDR; .NET 9 is even faster for multi-substring searches.</p></blockquote><h3 id="net-10-hardware-level-optimizations"><a href="/posts/searchvalues-saved-us-from-scaling-hell/#net-10-hardware-level-optimizations" title=".NET 10: Hardware-Level Optimizations">.NET 10: Hardware-Level Optimizations</a></h3><p>.NET 10 takes the optimization further by targeting CPU instruction sets directly. On AVX-512, it replaces two instructions with a single <code>PermuteVar64x8x2</code>, cutting CPU cycles in half. ARM64 gets cheaper <code>UnzipEven</code> instructions, delivering better performance on AWS Graviton and Azure Ampere instances. Case-insensitive searches benefit from extended fast-path logic that reduces validation overhead.</p><p>If you&rsquo;re running .NET 9 and seeing good results, .NET 10 makes the same operations <strong>10-20% faster</strong> without code changes. Just upgrade the runtime.</p><p>For heavy text processing workloads, that 10-20% compounds across millions of operations. It&rsquo;s the difference between needing an extra worker node versus staying within capacity.</p><blockquote><p>TLDR; Once again, .NET 10 is faster.</p></blockquote><h2 id="production-numbers"><a href="/posts/searchvalues-saved-us-from-scaling-hell/#production-numbers" title="Production Numbers">Production Numbers</a></h2><blockquote><p><strong>Benchmarks lie. Production doesn&rsquo;t.</strong></p></blockquote><p>In a real log processing pipeline handling production traffic, 10,000 log entries that previously took ~450ms now complete in ~85ms. That&rsquo;s <strong>5.3x faster on the same hardware</strong>. Not <em><strong>20% faster</strong></em> optimization theater. That&rsquo;s handling five times more throughput without adding a single server. Infrastructure costs going down while traffic going up.</p><p>This isn&rsquo;t theoretical performance gains on a conference slide deck. This is the difference between scaling horizontally by adding servers versus scaling efficiently by using what you have. Between infrastructure costs that increase with growth versus costs that stay flat. Between firefighting capacity problems versus preventing them.</p><blockquote><p>The business impact is direct: <strong>fewer servers, lower costs, same (or better) performance</strong>.</p></blockquote><h2 id="log-sanitization-without-the-performance-tax"><a href="/posts/searchvalues-saved-us-from-scaling-hell/#log-sanitization-without-the-performance-tax" title="Log Sanitization Without the Performance Tax">Log Sanitization Without the Performance Tax</a></h2><p>Logging should be cheap and invisible. Write to stdout, let your log shipper handle it, done. Reality is messier.</p><p>Log sanitization is expensive. Stripping sensitive data and control characters before storage becomes a bottleneck at scale. And every production system does it because compliance demands it. Regulations like GDPR, PCI-DSS, and HIPAA all require sanitizing logs.</p><br><p>Here&rsquo;s a simplified example of log sanitization that removes dangerous characters and redacts sensitive data patterns:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">System.Buffers</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">System.Text</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">class</span> <span class="nc">LogSanitizer</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Characters that could indicate injection attempts or corrupt data</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="k">readonly</span> <span class="n">SearchValues</span><span class="p">&lt;</span><span class="kt">char</span><span class="p">&gt;</span> <span class="n">DangerousCharacters</span> <span class="p">=</span> 
</span></span><span class="line"><span class="cl">        <span class="n">SearchValues</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="s">&#34;\0\x01\x02\x03\x04\x05\x06\x07\x08\x0B\x0C\x0E\x0F&#34;</span> <span class="p">+</span>
</span></span><span class="line"><span class="cl">                           <span class="s">&#34;\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Patterns that often precede sensitive data in logs</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="k">readonly</span> <span class="n">SearchValues</span><span class="p">&lt;</span><span class="kt">char</span><span class="p">&gt;</span> <span class="n">SensitiveMarkers</span> <span class="p">=</span> 
</span></span><span class="line"><span class="cl">        <span class="n">SearchValues</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="s">&#34;=:@&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">string</span> <span class="n">SanitizeLogEntry</span><span class="p">(</span><span class="kt">string</span> <span class="n">logEntry</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ReadOnlySpan</span><span class="p">&lt;</span><span class="kt">char</span><span class="p">&gt;</span> <span class="n">span</span> <span class="p">=</span> <span class="n">logEntry</span><span class="p">.</span><span class="n">AsSpan</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// Fast path: if no dangerous characters, return original</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(!</span><span class="n">span</span><span class="p">.</span><span class="n">ContainsAny</span><span class="p">(</span><span class="n">DangerousCharacters</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">ProcessSensitiveData</span><span class="p">(</span><span class="n">logEntry</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// Slow path: rebuild without dangerous characters</span>
</span></span><span class="line"><span class="cl">        <span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="p">(</span><span class="n">logEntry</span><span class="p">.</span><span class="n">Length</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">foreach</span> <span class="p">(</span><span class="kt">char</span> <span class="n">c</span> <span class="k">in</span> <span class="n">span</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(!</span><span class="n">DangerousCharacters</span><span class="p">.</span><span class="n">Contains</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="n">builder</span><span class="p">.</span><span class="n">Append</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">ProcessSensitiveData</span><span class="p">(</span><span class="n">builder</span><span class="p">.</span><span class="n">ToString</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">string</span> <span class="n">ProcessSensitiveData</span><span class="p">(</span><span class="kt">string</span> <span class="n">log</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Find patterns like &#34;password=&#34;, &#34;token:&#34;, &#34;apiKey@&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="n">ReadOnlySpan</span><span class="p">&lt;</span><span class="kt">char</span><span class="p">&gt;</span> <span class="n">span</span> <span class="p">=</span> <span class="n">log</span><span class="p">.</span><span class="n">AsSpan</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">markerIndex</span> <span class="p">=</span> <span class="n">span</span><span class="p">.</span><span class="n">IndexOfAny</span><span class="p">(</span><span class="n">SensitiveMarkers</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">markerIndex</span> <span class="p">==</span> <span class="p">-</span><span class="m">1</span><span class="p">)</span> <span class="k">return</span> <span class="n">log</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// Redact the next 20 characters after sensitive markers</span>
</span></span><span class="line"><span class="cl">        <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="n">Length</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">result</span><span class="p">.</span><span class="n">Append</span><span class="p">(</span><span class="n">span</span><span class="p">.</span><span class="n">Slice</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="n">markerIndex</span> <span class="p">+</span> <span class="m">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="n">result</span><span class="p">.</span><span class="n">Append</span><span class="p">(</span><span class="s">&#34;[REDACTED]&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">result</span><span class="p">.</span><span class="n">ToString</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>The Impact:</strong> 87% reduction in sanitization time. Not in a benchmark. In production. Under real load.</p><p>The fast path (clean logs) allocates <strong>zero heap memory</strong>. Garbage collector stays asleep. Sub-millisecond performance for 10KB log entries is the norm.</p><p>Across millions of logs daily, that&rsquo;s measurable infrastructure savings. We <strong>shut down log processing workers</strong> instead of adding them. Real money saved.</p><h2 id="what-you-need-to-know"><a href="/posts/searchvalues-saved-us-from-scaling-hell/#what-you-need-to-know" title="What You Need to Know">What You Need to Know</a></h2><p>Microsoft&rsquo;s CA1870 analyzer throws warnings when it detects string searching that could use <code>SearchValues&lt;T></code>. The warning appears on code like <code>text.IndexOfAny(new[] { ',', ';', '|' })</code> and suggests converting to <code>SearchValues&lt;T></code>. The fix is straightforward: create a static readonly <code>SearchValues&lt;char> Delimiters = SearchValues.Create([',', ';', '|'])</code> and use <code>text.AsSpan().IndexOfAny(Delimiters)</code>. The analyzer is helpful once you know when to act on it.</p><p>The most critical mistake is creating instances in loops or hot paths. <code>SearchValues&lt;T></code> is powerful but easy to misuse. The analysis work happens at creation time, which is expensive. The lookup cost is cheap. This means you need to store instances as static readonly fields. Pay the creation cost once at startup, then benefit from fast lookups across millions of operations. Creating <code>SearchValues&lt;T></code> repeatedly destroys the performance advantage you&rsquo;re trying to gain.</p><p>Premature optimization is still evil, but there&rsquo;s a clear pattern where <code>SearchValues&lt;T></code> delivers real value. The sweet spot is searching for <strong>3+ different characters</strong> or values in code that executes <strong>hundreds to millions of times</strong>, specifically in hot paths, per-request logic, or tight loops. Variable-length input where you can&rsquo;t predict string size amplifies the benefits. Modern CPUs with SIMD support (most hardware from the last 5-7 years) show the biggest gains, often 5-10x faster. For searching 1-2 characters, just use <code>IndexOf</code> directly. It&rsquo;s simpler and performs similarly. Skip <code>SearchValues&lt;T></code> for code that runs once at startup, error handling paths that rarely execute, tiny fixed-length strings, or when you&rsquo;re already bottlenecked on I/O operations. The overhead isn&rsquo;t worth it for infrequent operations.</p><p>The real test is production, not benchmarks. I&rsquo;ve seen 2x to 10x improvements depending on workload, but your results will vary based on several factors. Character set size matters, where larger sets (10+ characters) benefit more from vectorization than small sets (2-3 characters). String length amplifies the speedup since more characters are processed. Search frequency compounds the benefits over time. CPU architecture plays a role too, with modern SIMD-capable processors showing 5-10x gains while older CPUs show 2-3x improvements. Don&rsquo;t trust microbenchmarks that optimize for cache locality and predictable branching that production never has. Run load tests with production-like data. Measure wall-clock time and monitor allocations, not just throughput.</p><p>Performance improvements in production aren&rsquo;t synthetic benchmark gains. They&rsquo;re real, measurable, budget-impacting improvements. Zero-allocation fast paths reduce GC pressure, which compounds in long-running services. Security validators that ran 3-5x faster meant user-facing latency reduction that customers noticed. ETL pipelines that completed 4x faster let us <strong>decommission servers</strong> instead of adding them. Not &ldquo;up to&rdquo; savings in a marketing slide. Actual, budgeted, we-turned-off-these-instances savings.</p><p>Not every use case benefits equally. Profile first, optimize second. Small character sets (2-3 characters) show minimal gains. Large character sets (10+ characters) deliver significant wins. Find your workload&rsquo;s threshold. The creation cost is real, so single searches don&rsquo;t benefit. This optimization is for repeated operations in high-frequency code paths.</p><p>In high-throughput APIs and data pipelines, <code>SearchValues&lt;T></code> delivered one of the highest ROI optimizations relative to effort. Minimal code changes. No architectural changes. No dependency updates or compatibility breaks. Measurable immediate gains. But ROI requires return. If you&rsquo;re not processing thousands of operations per second, this won&rsquo;t move the needle. Measure your use case and save energy for problems that actually matter.</p><h2 id="the-bottom-line"><a href="/posts/searchvalues-saved-us-from-scaling-hell/#the-bottom-line" title="The Bottom Line">The Bottom Line</a></h2><p><code>SearchValues&lt;T></code> delivers measurable business value when applied correctly, but becomes noise when applied incorrectly. The difference lies in recognizing the pattern: high-frequency operations searching for multiple characters in variable-length input. This pattern shows up in log processing, input validation, CSV parsing, security filtering, and file path sanitization, essentially anywhere you&rsquo;re repeatedly searching for multiple values in strings or spans where the size varies.</p><p>The methodology is straightforward, though discipline matters. Start by measuring and profiling your hot paths to identify actual bottlenecks instead of guessing where problems might be. Apply the optimization selectively, focusing on repeated operations with 3+ characters in performance-critical code paths. Then validate the impact through benchmarking with realistic data under realistic load, not synthetic microbenchmarks that optimize for conditions production never sees. Treat CA1870 warnings as a starting point for investigation, not a mandate for action. Your profiler understands your workload better than any static analyzer ever could.</p><p>The log sanitization example from earlier demonstrates the core pattern in action: high frequency, variable input, multiple search targets. This same combination appears across input validation, data parsing, security filtering, and content sanitization throughout production systems. When you find this pattern in your codebase, apply <code>SearchValues&lt;T></code> and measure what changes. When it works, it transforms performance in ways that show up directly in infrastructure costs. When it doesn&rsquo;t deliver results, you&rsquo;ve invested an hour learning something valuable about your workload&rsquo;s actual characteristics.</p><p>The impact is asymmetric by design. Your infrastructure budget notices the difference immediately through fewer servers, lower costs, and better resource utilization. Your customers notice nothing, which is exactly the point of effective performance optimization. Good performance work is invisible to users while being highly visible in cost structure and operational metrics. One less bottleneck when scaling. One fewer server to provision. One more problem solved before it escalates into a crisis that demands emergency intervention.</p></section><h2>Comments</h2><aside class="giscus"></aside><script src="https://giscus.app/client.js" data-repo="dailydevops/dailydevops.github.io" data-repo-id="R_kgDOHA8eFg" data-category="Announcements" data-category-id="DIC_kwDOHA8eFs4COIqL" data-mapping="pathname" data-strict="1" data-reactions-enabled="0" data-emit-metadata="0" data-input-position="bottom" data-theme="light" data-lang="en" crossorigin="anonymous" async></script></article><aside class="sidebar divider"><section class="sidecar info"><ul><li><time datetime="2025-10-20T17:30:00+01:00">Published on 10/20/25 5:30 pm</time></li><li>Read in 10 minutes</li></ul></section><section class="sidecar author"><header><h2><a href="/authors/martin/" rel="author" title="Martin Stühmer">Author Martin Stühmer</a></h2></header><figure class="round"><picture><img src="https://www.gravatar.com/avatar/6da4a47ff9cc2b750452225fdb2582f7?d=identicon&amp;s=200" alt="Martin Stühmer" loading="lazy" decoding="async" title="Martin Stühmer"></picture></figure><section class="content">Martin is a seasoned software architect and developer based in the Cologne/Bonn area, with over 15 years of experience in utilizing .NET and Microsoft technologies in his work. His expertise lies in enhancing the quality and performance of development teams, optimizing software solutions for target environments, and maximizing application efficiency. Currently serving as the Director Consulting Services at CGI, he specializes in cloud-native and .NET solutions, while also providing training in cloud and software architecture. Beyond his professional endeavors, Martin actively contributes to open-source communities by offering various NuGet packages. In 2021, he achieved certifications as an IHK instructor and Microsoft certified trainer, furthering his commitment to continuous learning. Additionally, he became a certified trainer for CGI’s Risk and Cost Driven Architecture program in 2022.</section><a class="link" href="/authors/martin/" rel="author" title="Martin Stühmer"></a></section><section class="sidecar social"><header><h2>Social media</h2></header><a class="icon bluesky" href="https://bsky.app/profile/samtrion.net" rel="noopener external" title="Follow me on Bluesky" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-bluesky fa-stack-1x fa-inverse"></i>
</span></a><a class="icon github" href="https://github.com/samtrion" rel="noopener external" title="Follow me on GitHub" target="_blank"><i class="fa-brands fa-fw fa-github fa-2x"></i></a>
<a class="icon linkedin" href="https://www.linkedin.com/in/martin-stuehmer" rel="noopener external" title="Follow me on LinkedIn" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-linkedin-in fa-stack-1x fa-inverse"></i>
</span></a><a class="icon stackoverflow" href="https://stackoverflow.com/users/10574963" rel="noopener external" title="Follow me on Stack Overflow" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-stack-overflow fa-stack-1x fa-inverse"></i>
</span></a><a class="icon mail" href="mailto:martin@daily-devops.net" title="Contact me by e-mail" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
</span></a><a class="icon feed" href="/authors/martin/feed.rss" title="My RSS feed" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></section><section class="sidecar share"><header><h2>Share this content</h2></header><a class="icon linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fdaily-devops.net%2fposts%2fsearchvalues-saved-us-from-scaling-hell%2f&text=How%20SearchValues%3cT%3e%20Saved%20Us%20From%20Scaling%20Hell%20%26mdash%3b%20Daily%20DevOps%20%26%20.NET" target="_blank" rel="noopener external" aria-label="Share on LinkedIn" title="Share on LinkedIn" target="_blank"><i class="fa-brands fa-fw fa-linkedin-in fa-2x"></i></a>
<a class="icon bluesky" href="https://bsky.app/intent/compose?text=How%20SearchValues%3cT%3e%20Saved%20Us%20From%20Scaling%20Hell%20%26mdash%3b%20Daily%20DevOps%20%26%20.NET%20https%3a%2f%2fdaily-devops.net%2fposts%2fsearchvalues-saved-us-from-scaling-hell%2f" target="_blank" rel="noopener external" aria-label="Share on Bluesky" title="Share on Bluesky" target="_blank"><i class="fa-brands fa-fw fa-bluesky fa-2x"></i></a></section><section class="sidecar tags"><header><h2>Tags</h2></header><ul><li class="tag"><a href="/tags/dotnet/" hreflang="en" rel="tag" title=".NET"><i class="fas fa-tag"></i>&nbsp;.NET</a></li><li class="tag"><a href="/tags/bestpractices/" hreflang="en" rel="tag" title="Best Practices"><i class="fas fa-tag"></i>&nbsp;Best Practices</a></li><li class="tag"><a href="/tags/csharp/" hreflang="en" rel="tag" title="C#"><i class="fas fa-tag"></i>&nbsp;C#</a></li><li class="tag"><a href="/tags/codequality/" hreflang="en" rel="tag" title="Code Quality"><i class="fas fa-tag"></i>&nbsp;Code Quality</a></li><li class="tag"><a href="/tags/hidden-gems/" hreflang="en" rel="tag" title="Hidden Gems"><i class="fas fa-tag"></i>&nbsp;Hidden Gems</a></li></ul></section><section class="sidecar related"><header><h2>Related content</h2></header><article class="post"><figure class="square"><picture><source srcset="/images/csharp-80x80.webp?v=2009610da0e7ad52e611197cf3092830" type="image/webp"><source srcset="/images/csharp-80x80.png?v=c5d685b0d4fa9ec69bd959ee04beb903" type="image/png"><img src="/images/csharp.png?v=21ff9dcf5d1da7bfa80141c972c117da" alt="Stop Parsing the Same String Twice: CompositeFormat in .NET" loading="lazy" decoding="async" title="Stop Parsing the Same String Twice: CompositeFormat in .NET"></picture></figure><header><h2><a href="/posts/compositeformat-performance-boost/" rel="bookmark">Stop Parsing the Same String Twice: CompositeFormat in .NET</a></h2></header><section class="content">Every time you call <code>string.Format()</code> with the same format string, .NET parses it again. And again. And again. CompositeFormat changes that: parse once, reuse forever. The result? Up to 30% faster formatting, fewer allocations, and a one-line code change. Here&rsquo;s why this matters and how to use it.</section></article><article class="post"><figure class="square"><picture><source srcset="/images/technical-debt-80x80.webp?v=9636bd37f068db75d20c8f528818b34a" type="image/webp"><source srcset="/images/technical-debt-80x80.png?v=89bb5046cc0b986270c06c1c4de9e797" type="image/png"><img src="/images/technical-debt.png?v=67ddb8f47e467b6ae8d570696cc5f79d" alt="Clean Code: A Lip Service, Not a Standard
" loading="lazy" decoding="async" title="Clean Code: A Lip Service, Not a Standard
"></picture></figure><header><h2><a href="/posts/clean-code-lip-service-not-a-standard/" rel="bookmark">Clean Code: A Lip Service, Not a Standard</a></h2></header><section class="content">Clean Code is often praised but rarely practiced effectively. This article explores how misunderstood ideals and over-engineering harm .NET systems, how to recognize such failures early, and which C# best practices and official guidelines truly support maintainable software.</section></article><article class="post"><figure class="square"><picture><source srcset="/images/dotnet-80x80.webp?v=362353a62d867b7e3a0f33ec80e2eebf" type="image/webp"><source srcset="/images/dotnet-80x80.png?v=98376a285f07b0021d3118e0523d147a" type="image/png"><img src="/images/dotnet.png?v=8142ec8a038ba14415ff0d0434c78182" alt="ConstantExpectedAttribute: Unlocking Performance Through Compiler Awareness" loading="lazy" decoding="async" title="ConstantExpectedAttribute: Unlocking Performance Through Compiler Awareness"></picture></figure><header><h2><a href="/posts/constant-expected-attribute/" rel="bookmark">ConstantExpectedAttribute: Unlocking Performance Through Compiler Awareness</a></h2></header><section class="content">The ConstantExpectedAttribute, introduced in .NET 7, provides a powerful mechanism to signal compiler expectations about constant values. This enables better performance optimizations, enhanced IDE tooling, and clearer API contracts. Learn how to leverage this attribute to build more efficient and maintainable .NET applications.</section></article></section></aside><nav class="pager"><a class="next" href="/posts/compositeformat-performance-boost/" title="Stop Parsing the Same String Twice: CompositeFormat in .NET" rel="next"><span class="sub"><i class="fas fa-backward"></i>&emsp;Next</span><p class="title">Stop Parsing the Same String Twice: CompositeFormat in .NET</p></a><a class="prev" href="/posts/clean-code-lip-service-not-a-standard/" title="Clean Code: A Lip Service, Not a Standard
" rel="prev"><span class="sub">Previous&emsp;<i class="fas fa-forward"></i></span><p class="title">Clean Code: A Lip Service, Not a Standard</p></a></nav></main><footer class="footer"><div class="divider"></div><nav><ul class="navigation"><li><a href="/tags/">Tags</a></li><li><a href="/legal-notice/">Legal notice</a></li></ul></nav><div class="copyright">&copy; 2023 - 2025 Daily DevOps & .NET</div></footer><script defer src="/js/below.min.a6ce9164454b6077f17ae856f280442d9f3a1e21f06189f71c21f75144b22a0c8cf32bafd61d440e9d90ca02bf738b6a8ef19f5ec20285d8ca574f98c91ebaf2.js" integrity="sha512-ps6RZEVLYHfxeuhW8oBELZ86HiHwYYn3HCH3UUSyKgyM8yuv1h1EDp2QygK/c4tqjvGfXsIChdjKV0+YyR668g==" crossorigin="anonymous"></script><img class="vgwort" src="https://vg06.met.vgwort.de/na/31c6726fbc914f2a8645b1afc6206550" width="1" height="1" alt="VG Wort" title="VG Wort"></body></html>