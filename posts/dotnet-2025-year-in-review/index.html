<!doctype html><html class="no-js" lang="en" dir="ltr"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="theme-color" content="#15a"><title>2025 in Review: The Year .NET Stopped Lying to Itself — Daily DevOps & .NET</title><meta name="description" content="Forget the hype—2025 was when .NET tooling finally stopped pretending complexity doesn&rsquo;t exist
Three tools won by being honest: Aspire exposed topology, …"><meta name="twitter:description" property="og:description" content="Forget the hype—2025 was when .NET tooling finally stopped pretending complexity doesn&rsquo;t exist
Three tools won by being honest: Aspire exposed topology, …"><meta name="author" content="Martin Stühmer"><link rel="icon" href="/logo.svg?v=b9e294dc5c6fa04439c8c803d8e981a9" sizes="any" type="image/svg+xml"><meta name="twitter:title" property="og:title" content="2025 in Review: The Year .NET Stopped Lying to Itself — Daily DevOps & .NET"><meta property="og:updated_time" content="2025-12-30T17:06:09+01:00"><meta property="article:modified_time" content="2025-12-30T17:06:09+01:00"><meta property="article:published_time" content="2025-12-30T17:00:00+01:00"><meta property="og:type" content="article"><meta property="og:site_name" content="Daily DevOps & .NET"><meta property="og:url" content="https://daily-devops.net/posts/dotnet-2025-year-in-review/"><meta property="og:locale" content="en_US"><meta name="twitter:card" content="summary_large_image"><meta property="og:image" name="twitter:image" content="https://daily-devops.net/images/review-2025-1200x630.webp?v=ee3552bfcc57ecc44883cc26774b596a"><meta property="og:image:secure_url" content="https://daily-devops.net/images/review-2025-1200x630.webp?v=ee3552bfcc57ecc44883cc26774b596a"><meta property="og:image:alt" name="twitter:image:alt" content="2025 in Review: The Year .NET Stopped Lying to Itself"><meta property="og:image:type" content="image/webp"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta property="og:image" name="twitter:image" content="https://daily-devops.net/images/review-2025-1200x630.png?v=fbcbf42525a36e7545f5ea73a99a7b70"><meta property="og:image:secure_url" content="https://daily-devops.net/images/review-2025-1200x630.png?v=fbcbf42525a36e7545f5ea73a99a7b70"><meta property="og:image:alt" name="twitter:image:alt" content="2025 in Review: The Year .NET Stopped Lying to Itself"><meta property="og:image:type" content="image/png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><link rel="dns-prefetch" href="https://www.clarity.ms"><link rel="preconnect" href="https://www.clarity.ms" crossorigin><link rel="stylesheet" href="/css/style.min.0b2ef4378cd908eb695017aaa74603d244ff2b38c8068b4b51d76cad830c8ee5e3a40b67ab5b860a542c8bae73d8ba90cfbe9249b59c733a50de74cc32af818a.css" integrity="sha512-Cy70N4zZCOtpUBeqp0YD0kT/KzjIBotLUddsrYMMjuXjpAtnq1uGClQsi65z2LqQz76SSbWcczpQ3nTMMq+Big==" crossorigin="anonymous"><link rel="alternate" href='https://daily-devops.net/posts/dotnet-2025-year-in-review/' hreflang="x-default" title="2025 in Review: The Year .NET Stopped Lying to Itself &mdash; Daily DevOps & .NET"><link rel="canonical" href="https://daily-devops.net/posts/dotnet-2025-year-in-review/" hreflang="en-us" title="2025 in Review: The Year .NET Stopped Lying to Itself &mdash; Daily DevOps & .NET"><link rel="home" href="https://daily-devops.net/" hreflang="en-us" title="Daily DevOps & .NET"><link rel="prev" href="https://daily-devops.net/posts/dotnet-10-cli-devops/" hreflang="en-us" title=".NET CLI 10 – Microsoft Finally Realizes DevOps Exists"><link rel="author" href="https://daily-devops.net/authors/martin/" hreflang="en-us" title="Martin Stühmer &mdash; Daily DevOps & .NET"><meta name="giscus:backlink" content="https://daily-devops.net/posts/dotnet-2025-year-in-review/"><script defer src="/js/above.min.cb42b2c9a453e49e278326637d72d2f01e7f32e3f91e9cdde8fb587793d05514efd2f5cc5021c9658ca0f73876dbdcd1f7cb4a37c0bebc9df01110926b6d7cba.js" integrity="sha512-y0KyyaRT5J4ngyZjfXLS8B5/MuP5Hpzd6PtYd5PQVRTv0vXMUCHJZYyg9zh229zR98tKN8C+vJ3wERCSa218ug==" crossorigin="anonymous"></script><script type="text/javascript">(function(e,t,n,s,o,i,a){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)},i=t.createElement(s),i.async=1,i.src="https://www.clarity.ms/tag/"+o,a=t.getElementsByTagName(s)[0],a.parentNode.insertBefore(i,a)})(window,document,"clarity","script","o0pr4n9gg3")</script></head><body class="container"><header class="header"><a class="logo" href="/" title="Daily DevOps & .NET" rel="home"><figure class="page-logo"><picture><img src="/logo.svg?v=b9e294dc5c6fa04439c8c803d8e981a9" alt="Daily DevOps & .NET" title="Daily DevOps & .NET"></picture></figure><span class="title">Daily DevOps & .NET</span></a><nav class="menu"><button class="burger" aria-haspopup="true" aria-expanded="false" tabindex="0">
<i class="fas fa-burger"></i></button><ul class="navigation"><li class="active"><a href="/posts/">Posts</a></li><li><a href="/authors/">About us</a></li></ul></nav><div class="divider"></div></header><main class="body"><figure class="hero"><picture><source srcset="/images/review-2025-544x136.webp?v=098ce4fe7888518ae210bfde47a14834" type="image/webp" media="(max-width: 575.98px)"><source srcset="/images/review-2025-544x136.png?v=c1fbe5e25918688a3d1c403733b1774b" type="image/png" media="(max-width: 575.98px)"><source srcset="/images/review-2025-672x168.webp?v=95fe12347c4781a652d35f235d04a20d" type="image/webp" media="(max-width: 767.98px)"><source srcset="/images/review-2025-672x168.png?v=496ec1857793cf5f506f0e1666d20918" type="image/png" media="(max-width: 767.98px)"><source srcset="/images/review-2025-896x224.webp?v=7ebf1fb681ae3fcd22158324785ef2a2" type="image/webp" media="(max-width: 991.98px)"><source srcset="/images/review-2025-896x224.png?v=b8e14cfeeaa555b4c1afaa53484d34ee" type="image/png" media="(max-width: 991.98px)"><source srcset="/images/review-2025-1104x276.webp?v=6de4649721c66f2b62e2c47bd4a88736" type="image/webp" media="(max-width: 1199.98px)"><source srcset="/images/review-2025-1104x276.png?v=7e55217a3d1a7569656a5941ef7485a7" type="image/png" media="(max-width: 1199.98px)"><source srcset="/images/review-2025-1444x361.webp?v=416fbadf26976d23519e9de191439f88" type="image/webp"><source srcset="/images/review-2025-1444x361.png?v=bec4d049b8b784df5042d3e728b6d851" type="image/png"><img src="/images/review-2025.png?v=2cd18cbff5eeb978a3df449bf107e5c2" alt="2025 in Review: The Year .NET Stopped Lying to Itself" loading="lazy" decoding="async" title="2025 in Review: The Year .NET Stopped Lying to Itself"></picture></figure><article class="post"><header><h1>2025 in Review: The Year .NET Stopped Lying to Itself</h1></header><section class="content"><p>Let&rsquo;s be honest about 2025: no runtime breakthroughs, no language revolutions. Nothing that&rsquo;ll make the keynote highlight reels. What we got instead was something the ecosystem desperately needed—tooling that finally stopped lying about complexity.</p><p>The wins came from admitting reality. Distributed systems aren&rsquo;t simple, and tools that pretend otherwise just create delayed failures. Async execution semantics matter, whether your abstraction acknowledges them or not. Infrastructure dependencies aren&rsquo;t implementation details you can mock away without consequences. In 2025, the tools that delivered value made all of this explicit, testable, impossible to ignore.</p><p>But alongside that technical progress, we also saw the cracks widen. Open source sustainability, corporate consumption patterns, ecosystem trust—these structural tensions didn&rsquo;t get resolved. If anything, they became harder to ignore. And they&rsquo;re shaping our tooling choices just as much as any technical consideration.</p><p>Here&rsquo;s what actually mattered this year.</p><h2 id="making-complexity-visible-not-optional"><a href="/posts/dotnet-2025-year-in-review/#making-complexity-visible-not-optional" title="Making Complexity Visible, Not Optional">Making Complexity Visible, Not Optional</a></h2><p>The pattern I kept seeing in 2025: tools that actually mattered forced you to deal with reality instead of pretending it away. Topology. Concurrency. Dependency lifecycles. Infrastructure behavior. The messy stuff we&rsquo;ve been hiding behind &ldquo;convenience&rdquo; layers for years, just postponing production incidents.</p><p>Aspire, TUnit, Testcontainers. Three different problems. One consistent theme: show me what&rsquo;s actually happening.</p><p>.NET Aspire: Beyond the Azure Narrative</p><p>Most people look at Aspire and see Azure tooling. That&rsquo;s reading it wrong. It&rsquo;s worth correcting because it misses what actually changed in 2025.</p><p>I watched teams use Aspire in ways that had nothing to do with Azure. Polyglot systems where only the orchestration layer was .NET. Existing containerized services that got wired in without rewrites. Self-hosted infrastructure, alternative cloud providers, Docker on a developer&rsquo;s laptop. Hybrid setups where Aspire was just the coordination layer, not the runtime.</p><p>What makes this work is that Aspire isn&rsquo;t really about deployment targets. It&rsquo;s about making system intent explicit.</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="n">DistributedApplication</span><span class="p">.</span><span class="n">CreateBuilder</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">postgres</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">AddPostgres</span><span class="p">(</span><span class="s">&#34;db&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">api</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">AddProject</span><span class="p">&lt;</span><span class="n">Projects</span><span class="p">.</span><span class="n">Api</span><span class="p">&gt;(</span><span class="s">&#34;api&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                 <span class="p">.</span><span class="n">WithReference</span><span class="p">(</span><span class="n">postgres</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">().</span><span class="n">Run</span><span class="p">();</span>
</span></span></code></pre></div><p>Look at this code. Dependencies aren&rsquo;t buried in appsettings files or injected through environment variables scattered across deployment scripts. They&rsquo;re right there, versioned with your application code, reviewable in pull requests, enforced at composition time.</p><p>The app model is your system topology as code. Aspire then &ldquo;lowers&rdquo; that high-level description into whatever you actually need—Kubernetes manifests, Bicep templates, Docker Compose files, whatever your target environment requires.</p><p>But the thing that actually shifted conversations: observability gets baked in. With Aspire, OpenTelemetry isn&rsquo;t a post-deployment retrofit. <code>OTEL_SERVICE_NAME</code> and <code>OTEL_EXPORTER_OTLP_ENDPOINT</code> are automatic. The dashboard shows you traces, logs, metrics during local dev—without the boilerplate.</p><p>When observability is structural instead of bolted-on, the entire conversation changes.</p><p>That alignment—between how you describe your system, how it gets deployed, and how you observe it—is where Aspire delivered real value in 2025.</p><p><strong>Resources</strong>: <a href="https://github.com/dotnet/aspire" target="_blank" rel="noopener external noreferrer">GitHub</a> | <a href="https://learn.microsoft.com/en-us/dotnet/aspire/" target="_blank" rel="noopener external noreferrer">Docs</a></p><h2 id="tunit-when-test-frameworks-hide-what-matters"><a href="/posts/dotnet-2025-year-in-review/#tunit-when-test-frameworks-hide-what-matters" title="TUnit: When Test Frameworks Hide What Matters">TUnit: When Test Frameworks Hide What Matters</a></h2><p>TUnit looks like cleaner syntax. It&rsquo;s not. The actual value is in execution semantics that most frameworks just ignore because they don&rsquo;t care about precision.</p><p>Real test suites fail constantly for reasons that have nothing to do with your code. Shared state between parameterized tests. Async forced into sync silently. Parallel runs creating race conditions that only show up in CI. Test fixtures hiding execution boundaries you never designed for. The list goes on.</p><p>Most frameworks allow tests with these problems. TUnit makes them hard to accidentally create.</p><p>Take a realistic scenario—testing behavior that depends on multiple runtime dimensions like feature flags and tenant configuration:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">sealed</span> <span class="k">class</span> <span class="nc">FeatureFlagTests</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="na">    [Test]</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">async</span> <span class="n">Task</span> <span class="n">Request_is_processed_correctly</span><span class="p">(</span>
</span></span><span class="line"><span class="cl"><span class="na">        [Values(true, false)]</span> <span class="kt">bool</span> <span class="n">featureEnabled</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="na">        [Values(&#34;Free&#34;, &#34;Premium&#34;)]</span> <span class="kt">string</span> <span class="n">tenantType</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">await</span> <span class="k">using</span> <span class="nn">var</span> <span class="n">system</span> <span class="p">=</span> <span class="k">await</span> <span class="n">TestSystem</span>
</span></span><span class="line"><span class="cl">            <span class="p">.</span><span class="n">CreateAsync</span><span class="p">(</span><span class="n">featureEnabled</span><span class="p">,</span> <span class="n">tenantType</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kt">var</span> <span class="n">response</span> <span class="p">=</span> <span class="k">await</span> <span class="n">system</span><span class="p">.</span><span class="n">ExecuteRequestAsync</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">await</span> <span class="n">Assert</span><span class="p">.</span><span class="n">That</span><span class="p">(</span><span class="n">response</span><span class="p">.</span><span class="n">IsSuccessful</span><span class="p">).</span><span class="n">IsTrue</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>In TUnit, each parameter combination runs in complete isolation. The async lifecycle is native—no hidden <code>Task.Run()</code> or <code>.Result</code> calls. Fixtures are explicit. Parallel execution doesn&rsquo;t introduce coupling you didn&rsquo;t ask for.</p><p>What this eliminates is that whole category of tests that pass locally, fail in CI, pass again when you re-run them, and fail on Tuesdays. You know the ones. The flaky tests that eat hours of investigation time because the failure mode has nothing to do with the business logic you&rsquo;re testing.</p><p>In production CI pipelines, I saw this translate to predictable parallel execution times, reduced variance across agents, and—most importantly—test failures that actually correlated with system behavior rather than execution artifacts.</p><p>TUnit makes execution boundaries explicit. That&rsquo;s the real contribution.</p><p><strong>Resources</strong>: <a href="https://github.com/thomhurst/TUnit" target="_blank" rel="noopener external noreferrer">GitHub</a></p><h2 id="testcontainers-when-mocks-stop-being-enough"><a href="/posts/dotnet-2025-year-in-review/#testcontainers-when-mocks-stop-being-enough" title="Testcontainers: When Mocks Stop Being Enough">Testcontainers: When Mocks Stop Being Enough</a></h2><p>By 2025, I stopped treating Testcontainers as optional. If you&rsquo;re testing assumptions instead of real infrastructure, you&rsquo;re setting yourself up for surprises in production.</p><p>In-memory substitutes lie. You can&rsquo;t test transaction isolation with SQLite. You can&rsquo;t test Kafka&rsquo;s partition rebalancing without Kafka. Message delivery semantics, startup timing, schema migrations—the real database handles all this differently than a polite fake.</p><p>Testcontainers lets you test actual infrastructure behavior:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">kafka</span> <span class="p">=</span> <span class="k">new</span> <span class="n">KafkaBuilder</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">WithCleanUp</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">Build</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">await</span> <span class="n">kafka</span><span class="p">.</span><span class="n">StartAsync</span><span class="p">();</span>
</span></span></code></pre></div><p>When these tests fail, they&rsquo;re usually telling you about real production risks, not artifacts of your test harness.</p><p>Consider what this means for database testing. PostgreSQL handles concurrent transactions, deadlocks, constraint violations in ways that in-memory databases simply don&rsquo;t. Kafka&rsquo;s exactly-once semantics, partition assignment, consumer group rebalancing—you need the actual broker to test any of this meaningfully.</p><p>I&rsquo;ve watched too many teams ship code that works fine against mocks and breaks immediately in production. Connection pool exhaustion. Deadlocks under load. Message ordering violations during partition reassignment. Schema migrations that work on SQLite but fail on Postgres because of type handling differences.</p><p>These aren&rsquo;t edge cases. They&rsquo;re the default in real systems.</p><p>Testcontainers spins up real containers in your CI pipeline. Tests run against actual systems. Then the containers get cleaned up. The feedback loop stays fast. The confidence isn&rsquo;t false.</p><p><strong>Resources</strong>: <a href="https://github.com/testcontainers/testcontainers-dotnet" target="_blank" rel="noopener external noreferrer">GitHub</a></p><h2 id="the-structural-problems-were-not-solving"><a href="/posts/dotnet-2025-year-in-review/#the-structural-problems-were-not-solving" title="The Structural Problems We&rsquo;re Not Solving">The Structural Problems We&rsquo;re Not Solving</a></h2><p>The tooling highlights tell one story. But 2025 also made it harder to ignore structural problems that aren&rsquo;t getting better.</p><h3 id="licensing-as-operational-dependency"><a href="/posts/dotnet-2025-year-in-review/#licensing-as-operational-dependency" title="Licensing as Operational Dependency">Licensing as Operational Dependency</a></h3><p>Commercializing open source dependencies isn&rsquo;t new. What became clearer in 2025 were the operational costs that don&rsquo;t appear in pricing discussions.</p><p>CI pipelines started failing during container builds because license checks couldn&rsquo;t reach licensing servers. Dependency upgrades got blocked not for technical reasons but because legal teams needed weeks to review new license terms. Build systems became coupled to licensing infrastructure in ways nobody had planned for. Features fragmented across paid and unpaid tiers, forcing architectural decisions based on licensing rather than technical fit.</p><p>From an RCDA perspective, this is a risk profile change. When your build breaks because a license server is down, you&rsquo;ve introduced a runtime dependency that wasn&rsquo;t part of the original technical evaluation. The feedback cycle slows. Operational complexity increases. And most teams don&rsquo;t see this coming until they&rsquo;re already committed to the dependency.</p><h3 id="the-consumption-contribution-imbalance"><a href="/posts/dotnet-2025-year-in-review/#the-consumption-contribution-imbalance" title="The Consumption-Contribution Imbalance">The Consumption-Contribution Imbalance</a></h3><p>Large organizations continued extracting value from open source while contributing little back. Internal forks maintained indefinitely. Bug fixes applied internally but never pushed upstream. Copyright violations discovered through community audits, not voluntary disclosure.</p><p>Is this malicious? Usually not. It&rsquo;s legal risk management, procurement friction, organizational complexity. But the outcome remains the same: ecosystem fragmentation and maintainer burnout, while enterprises save millions on software they couldn&rsquo;t build themselves.</p><p>This isn&rsquo;t sustainable. When consumption at scale doesn&rsquo;t come with proportional contribution—whether that&rsquo;s code, funding, security disclosures, or just documentation improvements—the ecosystem becomes extractive. Maintainers burn out. Critical libraries go unmaintained. Trust erodes.</p><p>2025 made this tension more visible. We still don&rsquo;t have good answers.</p><h2 id="what-2025-actually-taught-us"><a href="/posts/dotnet-2025-year-in-review/#what-2025-actually-taught-us" title="What 2025 Actually Taught Us">What 2025 Actually Taught Us</a></h2><p>2025 was the year .NET tooling stopped hiding what&rsquo;s actually hard. Aspire made system intent explicit. TUnit made execution boundaries explicit. Testcontainers made infrastructure behavior explicit.</p><p>The open source sustainability crisis? Still unresolved. Still worsening. And still being treated as someone else&rsquo;s problem by many organizations extracting the most value. These aren&rsquo;t abstract concerns—they shape which tools survive, which maintainers continue, which dependencies remain viable long-term.</p><p>Here&rsquo;s the lesson: technical maturity and ecosystem health aren&rsquo;t separate. Ignore sustainability problems and you eventually constrain technical progress. Build on foundations maintained by exhausted volunteers subsidizing enterprise infrastructure, and you&rsquo;re building on uncertain ground.</p><p>The tools that mattered were honest. They didn&rsquo;t promise to make distributed systems simple. They didn&rsquo;t pretend async execution doesn&rsquo;t matter. They didn&rsquo;t hide infrastructure behavior and hope you wouldn&rsquo;t notice.</p><p>A mature ecosystem doesn&rsquo;t have magic. It has tools that show you what&rsquo;s happening so you can make real decisions instead of discovering the truth during an incident.</p><p>The frameworks and libraries that&rsquo;ll thrive going forward are the ones making system behavior transparent, testable, debuggable. Not the ones selling simplicity through opacity.</p><p>2025 taught us that honesty scales better than convenient abstractions that break under production load.</p></section><h2>Comments</h2><aside class="giscus"></aside><script src="https://giscus.app/client.js" data-repo="dailydevops/dailydevops.github.io" data-repo-id="R_kgDOHA8eFg" data-category="Announcements" data-category-id="DIC_kwDOHA8eFs4COIqL" data-mapping="pathname" data-strict="1" data-reactions-enabled="0" data-emit-metadata="0" data-input-position="bottom" data-theme="light" data-lang="en" crossorigin="anonymous" async></script></article><aside class="sidebar divider"><section class="sidecar info"><ul><li><time datetime="2025-12-30T17:00:00+01:00">Published on 12/30/25 5:00 pm</time></li><li>Read in 7 minutes</li></ul></section><section class="sidecar author"><header><h2><a href="/authors/martin/" rel="author" title="Martin Stühmer">Author Martin Stühmer</a></h2></header><figure class="round"><picture><img src="https://www.gravatar.com/avatar/6da4a47ff9cc2b750452225fdb2582f7?d=identicon&amp;s=200" alt="Martin Stühmer" loading="lazy" decoding="async" title="Martin Stühmer"></picture></figure><section class="content">Martin is a software architect and developer who has spent nearly two decades navigating the .NET ecosystem from Framework 2.0 to modern .NET 10. As Director Consulting Services at CGI and a Microsoft Certified Trainer, he specializes in cloud-native solutions, enterprise architecture, and Risk and Cost Driven Architecture (RCDA). His mission is straightforward - help teams build quality software that survives contact with production. He contributes to open-source communities through NuGet packages, writes about pragmatic software engineering on this blog, and trains developers who want substance over buzzwords.</section><a class="link" href="/authors/martin/" rel="author" title="Martin Stühmer"></a></section><section class="sidecar social"><header><h2>Social media</h2></header><a class="icon bluesky" href="https://bsky.app/profile/samtrion.net" rel="noopener external" title="Follow me on Bluesky" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-bluesky fa-stack-1x fa-inverse"></i>
</span></a><a class="icon github" href="https://github.com/samtrion" rel="noopener external" title="Follow me on GitHub" target="_blank"><i class="fa-brands fa-fw fa-github fa-2x"></i></a>
<a class="icon linkedin" href="https://www.linkedin.com/in/martin-stuehmer" rel="noopener external" title="Follow me on LinkedIn" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-linkedin-in fa-stack-1x fa-inverse"></i>
</span></a><a class="icon stackoverflow" href="https://stackoverflow.com/users/10574963" rel="noopener external" title="Follow me on Stack Overflow" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-stack-overflow fa-stack-1x fa-inverse"></i>
</span></a><a class="icon mail" href="mailto:martin@daily-devops.net" title="Contact me by e-mail" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
</span></a><a class="icon feed" href="/authors/martin/feed.rss" title="My RSS feed" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></section><section class="sidecar share"><header><h2>Share this content</h2></header><a class="icon linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fdaily-devops.net%2fposts%2fdotnet-2025-year-in-review%2f&text=2025%20in%20Review%3a%20The%20Year%20.NET%20Stopped%20Lying%20to%20Itself%20%26mdash%3b%20Daily%20DevOps%20%26%20.NET" target="_blank" rel="noopener external" aria-label="Share on LinkedIn" title="Share on LinkedIn" target="_blank"><i class="fa-brands fa-fw fa-linkedin-in fa-2x"></i></a>
<a class="icon bluesky" href="https://bsky.app/intent/compose?text=2025%20in%20Review%3a%20The%20Year%20.NET%20Stopped%20Lying%20to%20Itself%20%26mdash%3b%20Daily%20DevOps%20%26%20.NET%20https%3a%2f%2fdaily-devops.net%2fposts%2fdotnet-2025-year-in-review%2f" target="_blank" rel="noopener external" aria-label="Share on Bluesky" title="Share on Bluesky" target="_blank"><i class="fa-brands fa-fw fa-bluesky fa-2x"></i></a></section><section class="sidecar tags"><header><h2>Tags</h2></header><ul><li class="tag"><a href="/tags/dotnet/" hreflang="en" rel="tag" title=".NET"><i class="fas fa-tag"></i>&nbsp;.NET</a></li><li class="tag"><a href="/tags/architecture/" hreflang="en" rel="tag" title="Architecture"><i class="fas fa-tag"></i>&nbsp;Architecture</a></li><li class="tag"><a href="/tags/aspire/" hreflang="en" rel="tag" title="Aspire"><i class="fas fa-tag"></i>&nbsp;Aspire</a></li><li class="tag"><a href="/tags/csharp/" hreflang="en" rel="tag" title="C#"><i class="fas fa-tag"></i>&nbsp;C#</a></li><li class="tag"><a href="/tags/opensource/" hreflang="en" rel="tag" title="Open Source"><i class="fas fa-tag"></i>&nbsp;Open Source</a></li><li class="tag"><a href="/tags/softwareengineering/" hreflang="en" rel="tag" title="Software Engineering"><i class="fas fa-tag"></i>&nbsp;Software Engineering</a></li><li class="tag"><a href="/tags/technicaldebt/" hreflang="en" rel="tag" title="Technical Debt"><i class="fas fa-tag"></i>&nbsp;Technical Debt</a></li><li class="tag"><a href="/tags/testing/" hreflang="en" rel="tag" title="Testing"><i class="fas fa-tag"></i>&nbsp;Testing</a></li></ul></section><section class="sidecar related"><header><h2>Related content</h2></header><article class="post"><figure class="square"><picture><source srcset="/images/vibecoding-80x80.webp?v=3f8c50e71c82a10bfe515499996ebab4" type="image/webp"><source srcset="/images/vibecoding-80x80.png?v=7617a55dbdf6bd7939238821b77c1a82" type="image/png"><img src="/images/vibecoding.png?v=9a36076d86533930bbd6319c257968b9" alt="Vibe Coding in .NET: Creative Catalyst or Maintenance Risk?" loading="lazy" decoding="async" title="Vibe Coding in .NET: Creative Catalyst or Maintenance Risk?"></picture></figure><header><h2><a href="/posts/vibe-coding-isnt-wrong-its-unfinished/" rel="bookmark">Vibe Coding in .NET: Creative Catalyst or Maintenance Risk?</a></h2></header><section class="content"><p>In the world of software development, there’s a recurring tension between <strong>discipline and improvisation</strong>. Somewhere along that spectrum lies a phenomenon increasingly referred to as <strong>Vibe Coding</strong>. The term evokes a style of development where engineers follow intuition and momentum rather than formal plans, processes, or design patterns.</p><p>It’s fast, fluid, and occasionally brilliant. But is it sustainable in a .NET-based enterprise context?</p></section></article><article class="post"><figure class="square"><picture><source srcset="/images/nuget-scheduler-80x80.webp?v=4e5974129f045a8390e2e29b217f7ecc" type="image/webp"><source srcset="/images/nuget-scheduler-80x80.png?v=21983cb7d1aaee6a20b10806f639db1c" type="image/png"><img src="/images/nuget-scheduler.png?v=4159bfd7c08b58b0fc741782fe532741" alt=".NET Job Scheduling — Choosing the Right Framework" loading="lazy" decoding="async" title=".NET Job Scheduling — Choosing the Right Framework"></picture></figure><header><h2><a href="/posts/dotnet-job-scheduling-7-comparative-review/" rel="bookmark">.NET Job Scheduling — Choosing the Right Framework</a></h2></header><section class="content">Synthesizing the series into actionable guidance with feature comparisons, suitability ratings, and decision frameworks.
Select the scheduler that matches your operational model, infrastructure constraints, and team priorities.</section></article><article class="post"><figure class="square"><picture><source srcset="/images/nuget-scheduler-80x80.webp?v=4e5974129f045a8390e2e29b217f7ecc" type="image/webp"><source srcset="/images/nuget-scheduler-80x80.png?v=21983cb7d1aaee6a20b10806f639db1c" type="image/png"><img src="/images/nuget-scheduler.png?v=4159bfd7c08b58b0fc741782fe532741" alt=".NET Job Scheduling — TickerQ and Modern Architecture" loading="lazy" decoding="async" title=".NET Job Scheduling — TickerQ and Modern Architecture"></picture></figure><header><h2><a href="/posts/dotnet-job-scheduling-6-tickerq/" rel="bookmark">.NET Job Scheduling — TickerQ and Modern Architecture</a></h2></header><section class="content">TickerQ represents the next generation of .NET schedulers with compile-time validation, reflection-free execution, and SignalR-powered monitoring.
Understand when modern architecture patterns and performance optimizations justify adopting newer frameworks over established alternatives.</section></article></section></aside><nav class="pager"><a class="prev" href="/posts/dotnet-10-cli-devops/" title=".NET CLI 10 – Microsoft Finally Realizes DevOps Exists" rel="prev"><span class="sub">Previous&emsp;<i class="fas fa-forward"></i></span><p class="title">.NET CLI 10 – Microsoft Finally Realizes DevOps Exists</p></a></nav></main><footer class="footer"><div class="divider"></div><nav><ul class="navigation"><li><a href="/tags/">Tags</a></li><li><a href="/legal-notice/">Legal notice</a></li></ul></nav><div class="copyright">&copy; 2023 - 2025 Daily DevOps & .NET</div></footer><script defer src="/js/below.min.a6ce9164454b6077f17ae856f280442d9f3a1e21f06189f71c21f75144b22a0c8cf32bafd61d440e9d90ca02bf738b6a8ef19f5ec20285d8ca574f98c91ebaf2.js" integrity="sha512-ps6RZEVLYHfxeuhW8oBELZ86HiHwYYn3HCH3UUSyKgyM8yuv1h1EDp2QygK/c4tqjvGfXsIChdjKV0+YyR668g==" crossorigin="anonymous"></script><img class="vgwort" src="https://vg06.met.vgwort.de/na/e128d28dbe0d45e7be1d0082bcd746e7" width="1" height="1" alt="VG Wort" title="VG Wort"></body></html>