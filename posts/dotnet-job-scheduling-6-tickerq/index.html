<!doctype html><html class="no-js" lang="en" dir="ltr"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="theme-color" content="#15a"><title>.NET Job Scheduling — TickerQ and Modern Architecture — Daily DevOps & .NET</title><meta name="description" content="TickerQ represents the next generation of .NET schedulers with compile-time validation, reflection-free execution, and SignalR-powered monitoring.
Understand …"><meta name="twitter:description" property="og:description" content="TickerQ represents the next generation of .NET schedulers with compile-time validation, reflection-free execution, and SignalR-powered monitoring.
Understand …"><meta name="author" content="Martin Stühmer"><link rel="icon" href="/logo.svg?v=b9e294dc5c6fa04439c8c803d8e981a9" sizes="any" type="image/svg+xml"><meta name="twitter:title" property="og:title" content=".NET Job Scheduling — TickerQ and Modern Architecture — Daily DevOps & .NET"><meta property="og:updated_time" content="2025-12-21T12:13:05+01:00"><meta property="article:modified_time" content="2025-12-21T12:13:05+01:00"><meta property="article:published_time" content="2025-12-11T17:00:00+01:00"><meta property="og:type" content="article"><meta property="og:site_name" content="Daily DevOps & .NET"><meta property="og:url" content="https://daily-devops.net/posts/dotnet-job-scheduling-6-tickerq/"><meta property="og:locale" content="en_US"><meta name="twitter:card" content="summary_large_image"><meta property="og:image" name="twitter:image" content="https://daily-devops.net/images/nuget-scheduler-1200x630.webp?v=f3d889c42c9ebef75a8080657d86d1e1"><meta property="og:image:secure_url" content="https://daily-devops.net/images/nuget-scheduler-1200x630.webp?v=f3d889c42c9ebef75a8080657d86d1e1"><meta property="og:image:alt" name="twitter:image:alt" content=".NET Job Scheduling — TickerQ and Modern Architecture"><meta property="og:image:type" content="image/webp"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta property="og:image" name="twitter:image" content="https://daily-devops.net/images/nuget-scheduler-1200x630.png?v=16dd667ddd31353e2d9ebc222586164d"><meta property="og:image:secure_url" content="https://daily-devops.net/images/nuget-scheduler-1200x630.png?v=16dd667ddd31353e2d9ebc222586164d"><meta property="og:image:alt" name="twitter:image:alt" content=".NET Job Scheduling — TickerQ and Modern Architecture"><meta property="og:image:type" content="image/png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><link rel="dns-prefetch" href="https://www.clarity.ms"><link rel="preconnect" href="https://www.clarity.ms" crossorigin><link rel="stylesheet" href="/css/style.min.0b2ef4378cd908eb695017aaa74603d244ff2b38c8068b4b51d76cad830c8ee5e3a40b67ab5b860a542c8bae73d8ba90cfbe9249b59c733a50de74cc32af818a.css" integrity="sha512-Cy70N4zZCOtpUBeqp0YD0kT/KzjIBotLUddsrYMMjuXjpAtnq1uGClQsi65z2LqQz76SSbWcczpQ3nTMMq+Big==" crossorigin="anonymous"><link rel="alternate" href='https://daily-devops.net/posts/dotnet-job-scheduling-6-tickerq/' hreflang="x-default" title=".NET Job Scheduling — TickerQ and Modern Architecture &mdash; Daily DevOps & .NET"><link rel="canonical" href="https://daily-devops.net/posts/dotnet-job-scheduling-6-tickerq/" hreflang="en-us" title=".NET Job Scheduling — TickerQ and Modern Architecture &mdash; Daily DevOps & .NET"><link rel="home" href="https://daily-devops.net/" hreflang="en-us" title="Daily DevOps & .NET"><link rel="next" href="https://daily-devops.net/posts/dotnet-job-scheduling-7-comparative-review/" hreflang="en-us" title=".NET Job Scheduling — Choosing the Right Framework"><link rel="prev" href="https://daily-devops.net/posts/dotnet-power-of-ten-rules/" hreflang="en-us" title="Power of Ten Rules: More Relevant Than Ever for .NET"><link rel="author" href="https://daily-devops.net/authors/martin/" hreflang="en-us" title="Martin Stühmer &mdash; Daily DevOps & .NET"><meta name="giscus:backlink" content="https://daily-devops.net/posts/dotnet-job-scheduling-6-tickerq/"><script defer src="/js/above.min.cb42b2c9a453e49e278326637d72d2f01e7f32e3f91e9cdde8fb587793d05514efd2f5cc5021c9658ca0f73876dbdcd1f7cb4a37c0bebc9df01110926b6d7cba.js" integrity="sha512-y0KyyaRT5J4ngyZjfXLS8B5/MuP5Hpzd6PtYd5PQVRTv0vXMUCHJZYyg9zh229zR98tKN8C+vJ3wERCSa218ug==" crossorigin="anonymous"></script><script type="text/javascript">(function(e,t,n,s,o,i,a){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)},i=t.createElement(s),i.async=1,i.src="https://www.clarity.ms/tag/"+o,a=t.getElementsByTagName(s)[0],a.parentNode.insertBefore(i,a)})(window,document,"clarity","script","o0pr4n9gg3")</script></head><body class="container"><header class="header"><a class="logo" href="/" title="Daily DevOps & .NET" rel="home"><figure class="page-logo"><picture><img src="/logo.svg?v=b9e294dc5c6fa04439c8c803d8e981a9" alt="Daily DevOps & .NET" title="Daily DevOps & .NET"></picture></figure><span class="title">Daily DevOps & .NET</span></a><nav class="menu"><button class="burger" aria-haspopup="true" aria-expanded="false" tabindex="0">
<i class="fas fa-burger"></i></button><ul class="navigation"><li class="active"><a href="/posts/">Posts</a></li><li><a href="/authors/">About us</a></li></ul></nav><div class="divider"></div></header><main class="body"><figure class="hero"><picture><source srcset="/images/nuget-scheduler-544x136.webp?v=0e0bb9efd96bd0b3b7b45b871b5167aa" type="image/webp" media="(max-width: 575.98px)"><source srcset="/images/nuget-scheduler-544x136.png?v=f24f4c05bcbce7421f53568505a29f42" type="image/png" media="(max-width: 575.98px)"><source srcset="/images/nuget-scheduler-672x168.webp?v=de5b6c8d6aa6a6aa919713225a93e3fb" type="image/webp" media="(max-width: 767.98px)"><source srcset="/images/nuget-scheduler-672x168.png?v=9081a48ed39bbcf72048c71e59f757bf" type="image/png" media="(max-width: 767.98px)"><source srcset="/images/nuget-scheduler-896x224.webp?v=2bd0203b85c5855d6e65e5f1623effa8" type="image/webp" media="(max-width: 991.98px)"><source srcset="/images/nuget-scheduler-896x224.png?v=2e6bb71535af5f7bbaa14618564af8db" type="image/png" media="(max-width: 991.98px)"><source srcset="/images/nuget-scheduler-1104x276.webp?v=398614058e8e62a2c8e4df74236f5f0f" type="image/webp" media="(max-width: 1199.98px)"><source srcset="/images/nuget-scheduler-1104x276.png?v=13c4fd9c98192929ddcca480ea783609" type="image/png" media="(max-width: 1199.98px)"><source srcset="/images/nuget-scheduler-1444x361.webp?v=1ef9c89362404bf7bd1fffc612397312" type="image/webp"><source srcset="/images/nuget-scheduler-1444x361.png?v=5e8383f2e2acb3de1df045ebc65e458d" type="image/png"><img src="/images/nuget-scheduler.png?v=4159bfd7c08b58b0fc741782fe532741" alt=".NET Job Scheduling — TickerQ and Modern Architecture" loading="lazy" decoding="async" title=".NET Job Scheduling — TickerQ and Modern Architecture"></picture></figure><article class="post"><header><h1>.NET Job Scheduling — TickerQ and Modern Architecture</h1></header><section class="content"><p>Your SaaS platform processes tens of thousands of background jobs daily—user-triggered reports, scheduled data synchronization, recurring billing cycles. Performance matters: every millisecond spent in reflection overhead compounds across job volume. We measured it once: a 2ms reflection penalty per job execution meant an extra 40 seconds of CPU time daily across 20,000 jobs. Not catastrophic, but not free either.</p><p>Observability matters: product managers need real-time dashboards showing job states without deploying custom monitoring solutions. Safety matters: configuration errors should surface at compile time, not in production when a misspelled job name causes silent failures. We&rsquo;ve all been there—typo in a cron expression, job never runs, customer discovers it three weeks later.</p><p>TickerQ addresses these demands using modern .NET primitives: source generators eliminate reflection, Entity Framework Core provides persistence, and SignalR powers real-time dashboards. Jobs are defined with attributes, generating boilerplate code at compile time. The scheduler is async-first, stateless at its core, and integrates seamlessly with ASP.NET Core&rsquo;s dependency injection. The result: a framework that feels contemporary, performs efficiently, and surfaces errors early.</p><p>The trade-off: as a newer entrant, the ecosystem and community remain smaller compared to long-established alternatives. For teams building new systems prioritizing performance and modern patterns, the architectural approach offers compelling advantages. For teams requiring battle-tested stability or extensive plugin ecosystems, maturity considerations become relevant.</p><blockquote><h2 id="disclaimer"><a href="/posts/dotnet-job-scheduling-6-tickerq/#disclaimer" title="Disclaimer">Disclaimer</a></h2><p>This article’s code examples reflect the TickerQ API as of versions 8+ (current docs show .NET 8+ usage). If you are on older major versions, please refer to the official upgrade notes and adapt signatures and configuration accordingly.</p></blockquote><h2 id="architecture-source-generation-and-stateless-core"><a href="/posts/dotnet-job-scheduling-6-tickerq/#architecture-source-generation-and-stateless-core" title="Architecture: Source Generation and Stateless Core">Architecture: Source Generation and Stateless Core</a></h2><p>TickerQ&rsquo;s architecture centers on compile-time code generation. Jobs are defined as methods decorated with <code>[TickerFunction]</code> attributes. During compilation, source generators discover these methods, validate their signatures, and generate registration code that wires them into the scheduler without reflection.</p><p>Consider a job definition:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">TickerQ.Utilities.Base</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">class</span> <span class="nc">ReportJobs</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="k">readonly</span> <span class="n">IReportService</span> <span class="n">_reportService</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">ReportJobs</span><span class="p">(</span><span class="n">IReportService</span> <span class="n">reportService</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">_reportService</span> <span class="p">=</span> <span class="n">reportService</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="na">
</span></span></span><span class="line"><span class="cl"><span class="na">    [TickerFunction(&#34;GenerateMonthlyReport&#34;, cronExpression: &#34;0 0 0 1 * *&#34;)]</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">async</span> <span class="n">Task</span> <span class="n">GenerateMonthlyReport</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">TickerFunctionContext</span> <span class="n">context</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="n">CancellationToken</span> <span class="n">cancellationToken</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">await</span> <span class="n">_reportService</span><span class="p">.</span><span class="n">GenerateAsync</span><span class="p">(</span><span class="n">cancellationToken</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>At compile time, the source generator:</p><ol><li>Discovers the <code>GenerateMonthlyReport</code> method.</li><li>Validates the cron expression <code>0 0 0 1 * *</code> (monthly at midnight, 6-part cron).</li><li>Generates registration code mapping <code>"GenerateMonthlyReport"</code> to the method.</li><li>Injects dependency resolution logic for <code>IReportService</code>.</li></ol><p>At runtime, the scheduler invokes jobs via generated delegates—no reflection, no <code>MethodInfo.Invoke()</code>, no dictionary lookups. This yields:</p><ul><li><strong>Performance</strong>: Reflection overhead eliminated, reducing invocation latency.</li><li><strong>Compile-time safety</strong>: Invalid cron expressions or missing dependencies cause build errors, not runtime exceptions.</li><li><strong>Tooling support</strong>: IDEs detect errors, provide IntelliSense, and enable refactoring tools to work correctly.</li></ul><p>The stateless core design means job state lives in the database (via Entity Framework Core), not in-memory. The scheduler queries the database for jobs whose execution times have arrived, claims them atomically, and dispatches them to workers. This architecture supports clustering naturally: multiple instances coordinate via the database without custom locking logic.</p><h2 id="configuration-and-entity-framework-integration"><a href="/posts/dotnet-job-scheduling-6-tickerq/#configuration-and-entity-framework-integration" title="Configuration and Entity Framework Integration">Configuration and Entity Framework Integration</a></h2><p>Integrating TickerQ requires configuring Entity Framework Core for persistence. Install the packages:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">dotnet add package TickerQ
</span></span><span class="line"><span class="cl">dotnet add package TickerQ.EntityFrameworkCore
</span></span><span class="line"><span class="cl">dotnet add package TickerQ.Dashboard
</span></span></code></pre></div><p>Configure services in <code>Program.cs</code>:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">TickerQ.DependencyInjection</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">TickerQ.EntityFrameworkCore.DependencyInjection</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">TickerQ.Dashboard.DependencyInjection</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">builder</span><span class="p">.</span><span class="n">Services</span><span class="p">.</span><span class="n">AddTickerQ</span><span class="p">(</span><span class="n">options</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">options</span><span class="p">.</span><span class="n">ConfigureScheduler</span><span class="p">(</span><span class="n">scheduler</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">scheduler</span><span class="p">.</span><span class="n">MaxConcurrency</span> <span class="p">=</span> <span class="m">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">options</span><span class="p">.</span><span class="n">AddOperationalStore</span><span class="p">&lt;</span><span class="n">SchedulerDbContext</span><span class="p">&gt;(</span><span class="n">efOptions</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">efOptions</span><span class="p">.</span><span class="n">UseApplicationDbContext</span><span class="p">&lt;</span><span class="n">SchedulerDbContext</span><span class="p">&gt;(</span><span class="n">ConfigurationType</span><span class="p">.</span><span class="n">UseModelCustomizer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">options</span><span class="p">.</span><span class="n">AddDashboard</span><span class="p">(</span><span class="n">dashboardOptions</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">dashboardOptions</span><span class="p">.</span><span class="n">SetBasePath</span><span class="p">(</span><span class="s">&#34;/tickerq/dashboard&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">dashboardOptions</span><span class="p">.</span><span class="n">WithBasicAuth</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">app</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">app</span><span class="p">.</span><span class="n">UseTickerQ</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">app</span><span class="p">.</span><span class="n">Run</span><span class="p">();</span>
</span></span></code></pre></div><p>The <code>AddOperationalStore</code> method integrates TickerQ with your existing <code>DbContext</code>. TickerQ creates tables for job definitions (<code>TimeTicker</code>, <code>CronTicker</code>) and execution history. Using <code>UseApplicationDbContext&lt;SchedulerDbContext>(ConfigurationType.UseModelCustomizer)</code> applies TickerQ&rsquo;s entity configurations via model customizer while keeping your domain model clean.</p><h3 id="generate-and-apply-migrations"><a href="/posts/dotnet-job-scheduling-6-tickerq/#generate-and-apply-migrations" title="Generate and apply migrations">Generate and apply migrations</a></h3><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">dotnet ef migrations add AddTickerQSupport -c SchedulerDbContext
</span></span><span class="line"><span class="cl">dotnet ef database update
</span></span></code></pre></div><p>TickerQ&rsquo;s tables store:</p><ul><li><strong>CronTickers</strong>: Recurring jobs with cron expressions.</li><li><strong>TimeTickers</strong>: One-time jobs scheduled for specific execution times.</li><li><strong>CronTickerOccurrences</strong>: Execution history for audit trails and retry tracking.</li></ul><p>This database-backed persistence ensures jobs survive application restarts. If a job should have executed while the application was down, TickerQ handles it upon restart based on configuration—either executing missed jobs or skipping them.</p><h2 id="job-definitions-cron-and-time-tickers"><a href="/posts/dotnet-job-scheduling-6-tickerq/#job-definitions-cron-and-time-tickers" title="Job Definitions: Cron and Time Tickers">Job Definitions: Cron and Time Tickers</a></h2><p>TickerQ supports two job types: cron-based recurring jobs and time-based one-time jobs.</p><p><strong>Cron jobs</strong> execute repeatedly:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">TickerQ.Utilities.Base</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">class</span> <span class="nc">MaintenanceJobs</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="na">    [TickerFunction(&#34;CleanupLogs&#34;, &#34;0 0 * * * *&#34;)]</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">async</span> <span class="n">Task</span> <span class="n">CleanupLogs</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">TickerFunctionContext</span> <span class="n">context</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="n">CancellationToken</span> <span class="n">cancellationToken</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">await</span> <span class="n">DeleteOldLogsAsync</span><span class="p">(</span><span class="n">cancellationToken</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>The source generator validates <code>"0 0 * * * *"</code> at compile time. If the expression is invalid—say, <code>"0 25 * * * *"</code> (invalid hour)—the build fails with a descriptive error.</p><p><strong>Time tickers</strong> execute once at a specified time:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">TickerQ.Utilities.Base</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">class</span> <span class="nc">NotificationJobs</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="na">    [TickerFunction(&#34;SendReminder&#34;)]</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">async</span> <span class="n">Task</span> <span class="n">SendReminder</span><span class="p">(</span><span class="n">TickerFunctionContext</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">context</span><span class="p">,</span> <span class="n">CancellationToken</span> <span class="n">cancellationToken</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">var</span> <span class="n">userId</span> <span class="p">=</span> <span class="n">context</span><span class="p">.</span><span class="n">Request</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">await</span> <span class="n">SendReminderEmailAsync</span><span class="p">(</span><span class="n">userId</span><span class="p">,</span> <span class="n">cancellationToken</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Schedule time tickers programmatically:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">TickerQ.Utilities.Entities</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">TickerQ.Utilities.Base</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">TickerQ.Utilities.Interfaces.Managers</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">private</span> <span class="k">readonly</span> <span class="n">ITimeTickerManager</span><span class="p">&lt;</span><span class="n">TimeTickerEntity</span><span class="p">&gt;</span> <span class="n">_timeTickerManager</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">await</span> <span class="n">_timeTickerManager</span><span class="p">.</span><span class="n">AddAsync</span><span class="p">(</span><span class="k">new</span> <span class="n">TimeTickerEntity</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Function</span> <span class="p">=</span> <span class="s">&#34;SendReminder&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">ExecutionTime</span> <span class="p">=</span> <span class="n">DateTime</span><span class="p">.</span><span class="n">UtcNow</span><span class="p">.</span><span class="n">AddHours</span><span class="p">(</span><span class="m">2</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">Request</span> <span class="p">=</span> <span class="n">TickerHelper</span><span class="p">.</span><span class="n">CreateTickerRequest</span><span class="p">(</span><span class="n">userId</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">Retries</span> <span class="p">=</span> <span class="m">3</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">RetryIntervals</span> <span class="p">=</span> <span class="k">new</span><span class="p">[]</span> <span class="p">{</span> <span class="m">60</span><span class="p">,</span> <span class="m">300</span><span class="p">,</span> <span class="m">900</span> <span class="p">}</span> <span class="c1">// 1min, 5min, 15min</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span></code></pre></div><p>This schedules a reminder to send in two hours. If execution fails, TickerQ retries up to three times with increasing intervals. The <code>Request</code> parameter passes data (here, <code>userId</code>) to the job, serialized as JSON in the database.</p><h2 id="real-time-dashboard-with-signalr"><a href="/posts/dotnet-job-scheduling-6-tickerq/#real-time-dashboard-with-signalr" title="Real-Time Dashboard with SignalR">Real-Time Dashboard with SignalR</a></h2><p>TickerQ&rsquo;s dashboard provides live visibility into job states using SignalR for real-time updates. Administrators view:</p><ul><li><strong>Active jobs</strong>: Currently executing, with elapsed time and progress indicators.</li><li><strong>Scheduled jobs</strong>: Pending execution with countdown timers.</li><li><strong>Execution history</strong>: Completed jobs with duration, outcome, and error details.</li><li><strong>Cron tickers</strong>: Recurring jobs with last/next execution times.</li></ul><p>The dashboard also supports:</p><ul><li><strong>Manual triggering</strong>: Execute recurring jobs on-demand.</li><li><strong>Job cancellation</strong>: Stop long-running jobs mid-execution.</li><li><strong>Live updates</strong>: Job states update in real-time via SignalR, no page refreshes required.</li></ul><p>Configure basic authentication to protect the dashboard:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="n">builder</span><span class="p">.</span><span class="n">Services</span><span class="p">.</span><span class="n">AddTickerQ</span><span class="p">(</span><span class="n">options</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">options</span><span class="p">.</span><span class="n">AddDashboard</span><span class="p">(</span><span class="n">dashboardOptions</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">dashboardOptions</span><span class="p">.</span><span class="n">SetBasePath</span><span class="p">(</span><span class="s">&#34;/tickerq/dashboard&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">dashboardOptions</span><span class="p">.</span><span class="n">WithBasicAuth</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span></code></pre></div><p>For production deployments, integrate with your authentication system—ASP.NET Core Identity, OAuth, or Azure AD—using <code>WithHostAuthentication()</code> and standard ASP.NET Core authorization policies.</p><p>The dashboard&rsquo;s Vue.js-based UI is modern and responsive, tailored for operational teams monitoring background processing health. Compare this to Hangfire&rsquo;s dashboard, which uses server-rendered HTML with periodic polling. TickerQ&rsquo;s SignalR approach reduces latency and provides instant feedback when job states change.</p><h2 id="retry-policies-throttling-and-distributed-coordination"><a href="/posts/dotnet-job-scheduling-6-tickerq/#retry-policies-throttling-and-distributed-coordination" title="Retry Policies, Throttling, and Distributed Coordination">Retry Policies, Throttling, and Distributed Coordination</a></h2><p>TickerQ supports per-job retry policies:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">TickerQ.Utilities.Entities</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">await</span> <span class="n">_timeTickerManager</span><span class="p">.</span><span class="n">AddAsync</span><span class="p">(</span><span class="k">new</span> <span class="n">TimeTickerEntity</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Function</span> <span class="p">=</span> <span class="s">&#34;ImportData&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">ExecutionTime</span> <span class="p">=</span> <span class="n">DateTime</span><span class="p">.</span><span class="n">UtcNow</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">Retries</span> <span class="p">=</span> <span class="m">5</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">RetryIntervals</span> <span class="p">=</span> <span class="k">new</span><span class="p">[]</span> <span class="p">{</span> <span class="m">30</span><span class="p">,</span> <span class="m">60</span><span class="p">,</span> <span class="m">120</span><span class="p">,</span> <span class="m">300</span><span class="p">,</span> <span class="m">600</span> <span class="p">},</span> <span class="c1">// Exponential backoff</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span></code></pre></div><p>Failed jobs retry based on the specified intervals. After exhausting retries, jobs transition to <code>Failed</code> state, visible in the dashboard with full error details.</p><p><strong>Throttling</strong> limits concurrent execution. If your database supports 50 concurrent connections and you schedule 100 jobs simultaneously, throttling prevents connection exhaustion:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="n">builder</span><span class="p">.</span><span class="n">Services</span><span class="p">.</span><span class="n">AddTickerQ</span><span class="p">(</span><span class="n">options</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">options</span><span class="p">.</span><span class="n">ConfigureScheduler</span><span class="p">(</span><span class="n">scheduler</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">scheduler</span><span class="p">.</span><span class="n">MaxConcurrency</span> <span class="p">=</span> <span class="m">10</span><span class="p">;</span> <span class="c1">// Max 10 concurrent jobs</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span></code></pre></div><p>TickerQ queues excess jobs until workers become available, preventing resource contention.</p><p><strong>Distributed coordination</strong> works via Entity Framework Core&rsquo;s optimistic concurrency. When a scheduler instance queries for jobs, it claims them with an atomic update:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="n">UPDATE</span> <span class="n">TimeTicker</span>
</span></span><span class="line"><span class="cl"><span class="n">SET</span> <span class="n">State</span> <span class="p">=</span> <span class="err">&#39;</span><span class="n">Processing</span><span class="err">&#39;</span><span class="p">,</span> <span class="n">Instance</span> <span class="p">=</span> <span class="err">&#39;</span><span class="n">server</span><span class="p">-</span><span class="m">01</span><span class="err">&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">WHERE</span> <span class="n">State</span> <span class="p">=</span> <span class="err">&#39;</span><span class="n">Pending</span><span class="err">&#39;</span> <span class="n">AND</span> <span class="n">ExecutionTime</span> <span class="p">&lt;=</span> <span class="n">GETUTCDATE</span><span class="p">();</span>
</span></span></code></pre></div><p>Only one instance succeeds per job. If an instance crashes mid-execution, orphaned jobs remain in <code>Processing</code> state until a recovery mechanism detects and resets them—configurable via timeout policies.</p><p>This coordination is simpler than Quartz.NET&rsquo;s pessimistic locking but sufficient for most scenarios. Teams running dozens of instances in high-throughput environments may need to tune timeout settings to balance recovery speed and false-positive detection.</p><h2 id="batch-jobs-and-dependency-workflows"><a href="/posts/dotnet-job-scheduling-6-tickerq/#batch-jobs-and-dependency-workflows" title="Batch Jobs and Dependency Workflows">Batch Jobs and Dependency Workflows</a></h2><p>TickerQ supports batch jobs—groups of related tasks that execute as a unit:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">TickerQ.Utilities.Entities</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">TickerQ.Utilities.Interfaces.Managers</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Schedule parent job</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">parentResult</span> <span class="p">=</span> <span class="k">await</span> <span class="n">_timeTickerManager</span><span class="p">.</span><span class="n">AddAsync</span><span class="p">(</span><span class="k">new</span> <span class="n">TimeTickerEntity</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Function</span> <span class="p">=</span> <span class="s">&#34;ImportUsers&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">ExecutionTime</span> <span class="p">=</span> <span class="n">DateTime</span><span class="p">.</span><span class="n">UtcNow</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">parentId</span> <span class="p">=</span> <span class="n">parentResult</span><span class="p">.</span><span class="n">Result</span><span class="p">.</span><span class="n">Id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Schedule dependent job that runs only if parent succeeds</span>
</span></span><span class="line"><span class="cl"><span class="k">await</span> <span class="n">_timeTickerManager</span><span class="p">.</span><span class="n">AddAsync</span><span class="p">(</span><span class="k">new</span> <span class="n">TimeTickerEntity</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Function</span> <span class="p">=</span> <span class="s">&#34;TransformUsers&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">ExecutionTime</span> <span class="p">=</span> <span class="n">DateTime</span><span class="p">.</span><span class="n">UtcNow</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">ParentId</span> <span class="p">=</span> <span class="n">parentId</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">RunCondition</span> <span class="p">=</span> <span class="n">RunCondition</span><span class="p">.</span><span class="n">OnSuccess</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span></code></pre></div><p>TickerQ executes <code>ImportUsers</code> first. If it succeeds, <code>TransformUsers</code> runs; if it fails, <code>TransformUsers</code> is skipped. This declarative workflow removes custom orchestration logic from application code.</p><p>Batch conditions include:</p><ul><li><strong>Always</strong>: Execute regardless of parent outcomes.</li><li><strong>OnSuccess</strong>: Execute only if all previous batch jobs succeeded.</li><li><strong>OnFailure</strong>: Execute only if any previous job failed (error handling workflows).</li></ul><p>This feature mirrors Hangfire&rsquo;s continuations and Quartz.NET&rsquo;s job chaining but integrates more naturally with Entity Framework Core&rsquo;s transactional boundaries.</p><h2 id="when-tickerq-fits"><a href="/posts/dotnet-job-scheduling-6-tickerq/#when-tickerq-fits" title="When TickerQ Fits">When TickerQ Fits</a></h2><p>TickerQ excels when:</p><ol><li><p><strong>Performance matters</strong>: High job volumes benefit from reflection-free execution and async-first design.</p></li><li><p><strong>Compile-time safety is valued</strong>: Teams that prefer catching configuration errors during builds rather than runtime.</p></li><li><p><strong>Modern tooling is prioritized</strong>: Source generation, SignalR, and Entity Framework Core integration appeal to teams comfortable with current .NET patterns.</p></li><li><p><strong>Real-time observability is required</strong>: The dashboard&rsquo;s live updates provide operational visibility without custom monitoring infrastructure.</p></li></ol><p>TickerQ is less suitable when:</p><ul><li><p><strong>Battle-tested stability is critical</strong>: Hangfire (13+ years) and Quartz.NET (20+ years) have larger user bases and more production validation.</p></li><li><p><strong>Extensive plugins are needed</strong>: TickerQ&rsquo;s ecosystem is smaller. Hangfire and Quartz.NET offer more storage backends, monitoring integrations, and community extensions.</p></li><li><p><strong>Legacy .NET Framework support is required</strong>: TickerQ targets modern .NET (6+). Teams on .NET Framework should use Hangfire or Quartz.NET.</p></li></ul><h2 id="operational-considerations"><a href="/posts/dotnet-job-scheduling-6-tickerq/#operational-considerations" title="Operational Considerations">Operational Considerations</a></h2><p>TickerQ&rsquo;s reliance on Entity Framework Core couples job scheduling to your database strategy. Teams already using EF Core benefit from unified migration workflows and tooling. Teams preferring Dapper, raw SQL, or NoSQL databases face friction—TickerQ&rsquo;s operational store requires EF Core.</p><p>The source generation approach requires recompilation when job definitions change. This aligns with modern CI/CD practices (deploy code, not configuration) but contrasts with Hangfire or Quartz.NET, where jobs can be scheduled dynamically at runtime without redeployment.</p><p>TickerQ&rsquo;s dashboard consumes resources—SignalR connections, server memory for real-time updates. In resource-constrained environments, disable the dashboard and rely on application logging.</p><h2 id="practical-takeaways"><a href="/posts/dotnet-job-scheduling-6-tickerq/#practical-takeaways" title="Practical Takeaways">Practical Takeaways</a></h2><p>TickerQ represents modern .NET job scheduling: source generation, async-first design, and real-time monitoring. It bridges the gap between simplicity (NCronJob, Coravel) and enterprise features (Quartz.NET), offering persistence and performance without operational complexity.</p><p>Consider TickerQ if:</p><ul><li>You&rsquo;re building new systems on modern .NET (6+).</li><li>Performance and compile-time safety are priorities.</li><li>You use Entity Framework Core and value tooling integration.</li><li>Real-time dashboards enhance operational workflows.</li></ul><p>Avoid TickerQ if:</p><ul><li>Your system runs on .NET Framework or older .NET Core versions.</li><li>You need extensive ecosystem support or community plugins.</li><li>You prefer runtime configuration over compile-time code generation.</li></ul><p>The final article synthesizes the series into comparative guidance, presenting a feature matrix, rating framework suitability across dimensions, and offering decision heuristics for selecting the right scheduler based on system maturity, infrastructure, and team priorities.</p></section><h2>Comments</h2><aside class="giscus"></aside><script src="https://giscus.app/client.js" data-repo="dailydevops/dailydevops.github.io" data-repo-id="R_kgDOHA8eFg" data-category="Announcements" data-category-id="DIC_kwDOHA8eFs4COIqL" data-mapping="pathname" data-strict="1" data-reactions-enabled="0" data-emit-metadata="0" data-input-position="bottom" data-theme="light" data-lang="en" crossorigin="anonymous" async></script></article><aside class="sidebar divider"><section class="sidecar info"><ul><li><time datetime="2025-12-11T17:00:00+01:00">Published on 12/11/25 5:00 pm</time></li><li>Read in 9 minutes</li></ul></section><section class="sidecar series"><header><h2>Series content</h2></header><a href="https://daily-devops.net/posts/dotnet-job-scheduling-1-landscape/" title=".NET Job Scheduling — The Landscape" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right"></i>&nbsp;
.NET Job Scheduling — The Landscape
</a><a href="https://daily-devops.net/posts/dotnet-job-scheduling-2-hangfire/" title=".NET Job Scheduling — Hangfire and Persistent Reliability" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right"></i>&nbsp;
.NET Job Scheduling — Hangfire and Persistent Reliability
</a><a href="https://daily-devops.net/posts/dotnet-job-scheduling-3-quartznet/" title=".NET Job Scheduling — Quartz.NET for Enterprise Scale" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right"></i>&nbsp;
.NET Job Scheduling — Quartz.NET for Enterprise Scale
</a><a href="https://daily-devops.net/posts/dotnet-job-scheduling-4-coravel/" title=".NET Job Scheduling — Coravel and Fluent Simplicity" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right"></i>&nbsp;
.NET Job Scheduling — Coravel and Fluent Simplicity
</a><a href="https://daily-devops.net/posts/dotnet-job-scheduling-5-ncronjob/" title=".NET Job Scheduling — NCronJob and Native Minimalism" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right"></i>&nbsp;
.NET Job Scheduling — NCronJob and Native Minimalism
</a><a href="https://daily-devops.net/posts/dotnet-job-scheduling-6-tickerq/" title=".NET Job Scheduling — TickerQ and Modern Architecture" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right"></i>&nbsp;
.NET Job Scheduling — TickerQ and Modern Architecture
</a><a href="https://daily-devops.net/posts/dotnet-job-scheduling-7-comparative-review/" title=".NET Job Scheduling — Choosing the Right Framework" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right"></i>&nbsp;
.NET Job Scheduling — Choosing the Right Framework</a></section><section class="sidecar author"><header><h2><a href="/authors/martin/" rel="author" title="Martin Stühmer">Author Martin Stühmer</a></h2></header><figure class="round"><picture><img src="https://www.gravatar.com/avatar/6da4a47ff9cc2b750452225fdb2582f7?d=identicon&amp;s=200" alt="Martin Stühmer" loading="lazy" decoding="async" title="Martin Stühmer"></picture></figure><section class="content">Martin is a software architect and developer who has spent nearly two decades navigating the .NET ecosystem from Framework 2.0 to modern .NET 10. As Director Consulting Services at CGI and a Microsoft Certified Trainer, he specializes in cloud-native solutions, enterprise architecture, and Risk and Cost Driven Architecture (RCDA). His mission is straightforward - help teams build quality software that survives contact with production. He contributes to open-source communities through NuGet packages, writes about pragmatic software engineering on this blog, and trains developers who want substance over buzzwords.</section><a class="link" href="/authors/martin/" rel="author" title="Martin Stühmer"></a></section><section class="sidecar social"><header><h2>Social media</h2></header><a class="icon bluesky" href="https://bsky.app/profile/samtrion.net" rel="noopener external" title="Follow me on Bluesky" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-bluesky fa-stack-1x fa-inverse"></i>
</span></a><a class="icon github" href="https://github.com/samtrion" rel="noopener external" title="Follow me on GitHub" target="_blank"><i class="fa-brands fa-fw fa-github fa-2x"></i></a>
<a class="icon linkedin" href="https://www.linkedin.com/in/martin-stuehmer" rel="noopener external" title="Follow me on LinkedIn" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-linkedin-in fa-stack-1x fa-inverse"></i>
</span></a><a class="icon stackoverflow" href="https://stackoverflow.com/users/10574963" rel="noopener external" title="Follow me on Stack Overflow" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-stack-overflow fa-stack-1x fa-inverse"></i>
</span></a><a class="icon mail" href="mailto:martin@daily-devops.net" title="Contact me by e-mail" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
</span></a><a class="icon feed" href="/authors/martin/feed.rss" title="My RSS feed" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></section><section class="sidecar share"><header><h2>Share this content</h2></header><a class="icon linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fdaily-devops.net%2fposts%2fdotnet-job-scheduling-6-tickerq%2f&text=.NET%20Job%20Scheduling%20%e2%80%94%20TickerQ%20and%20Modern%20Architecture%20%26mdash%3b%20Daily%20DevOps%20%26%20.NET" target="_blank" rel="noopener external" aria-label="Share on LinkedIn" title="Share on LinkedIn" target="_blank"><i class="fa-brands fa-fw fa-linkedin-in fa-2x"></i></a>
<a class="icon bluesky" href="https://bsky.app/intent/compose?text=.NET%20Job%20Scheduling%20%e2%80%94%20TickerQ%20and%20Modern%20Architecture%20%26mdash%3b%20Daily%20DevOps%20%26%20.NET%20https%3a%2f%2fdaily-devops.net%2fposts%2fdotnet-job-scheduling-6-tickerq%2f" target="_blank" rel="noopener external" aria-label="Share on Bluesky" title="Share on Bluesky" target="_blank"><i class="fa-brands fa-fw fa-bluesky fa-2x"></i></a></section><section class="sidecar tags"><header><h2>Tags</h2></header><ul><li class="tag"><a href="/tags/dotnet/" hreflang="en" rel="tag" title=".NET"><i class="fas fa-tag"></i>&nbsp;.NET</a></li><li class="tag"><a href="/tags/architecture/" hreflang="en" rel="tag" title="Architecture"><i class="fas fa-tag"></i>&nbsp;Architecture</a></li><li class="tag"><a href="/tags/csharp/" hreflang="en" rel="tag" title="C#"><i class="fas fa-tag"></i>&nbsp;C#</a></li><li class="tag"><a href="/tags/nuget/" hreflang="en" rel="tag" title="NuGet"><i class="fas fa-tag"></i>&nbsp;NuGet</a></li><li class="tag"><a href="/tags/softwareengineering/" hreflang="en" rel="tag" title="Software Engineering"><i class="fas fa-tag"></i>&nbsp;Software Engineering</a></li></ul></section><section class="sidecar links"><header><h2>Additional links</h2></header><a href="https://github.com/MarvinKlein1508/TickerQ" title="TickerQ Documentation" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right"></i>&nbsp;
TickerQ Documentation
</a><a href="https://github.com/MarvinKlein1508/TickerQ" title="TickerQ on GitHub" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right"></i>&nbsp;
TickerQ on GitHub</a></section><section class="sidecar related"><header><h2>Related content</h2></header><article class="post"><figure class="square"><picture><source srcset="/images/nuget-scheduler-80x80.webp?v=4e5974129f045a8390e2e29b217f7ecc" type="image/webp"><source srcset="/images/nuget-scheduler-80x80.png?v=21983cb7d1aaee6a20b10806f639db1c" type="image/png"><img src="/images/nuget-scheduler.png?v=4159bfd7c08b58b0fc741782fe532741" alt=".NET Job Scheduling — NCronJob and Native Minimalism" loading="lazy" decoding="async" title=".NET Job Scheduling — NCronJob and Native Minimalism"></picture></figure><header><h2><a href="/posts/dotnet-job-scheduling-5-ncronjob/" rel="bookmark">.NET Job Scheduling — NCronJob and Native Minimalism</a></h2></header><section class="content">NCronJob leverages IHostedService for lightweight scheduling with zero external dependencies.
Understand when minimal infrastructure and native ASP.NET Core integration outweigh advanced features for cloud-native architectures.</section></article><article class="post"><figure class="square"><picture><source srcset="/images/nuget-scheduler-80x80.webp?v=4e5974129f045a8390e2e29b217f7ecc" type="image/webp"><source srcset="/images/nuget-scheduler-80x80.png?v=21983cb7d1aaee6a20b10806f639db1c" type="image/png"><img src="/images/nuget-scheduler.png?v=4159bfd7c08b58b0fc741782fe532741" alt=".NET Job Scheduling — Coravel and Fluent Simplicity" loading="lazy" decoding="async" title=".NET Job Scheduling — Coravel and Fluent Simplicity"></picture></figure><header><h2><a href="/posts/dotnet-job-scheduling-4-coravel/" rel="bookmark">.NET Job Scheduling — Coravel and Fluent Simplicity</a></h2></header><section class="content">Coravel prioritizes developer velocity with fluent APIs, zero infrastructure, and integrated features like queuing and caching.
Understand when convenience and rapid iteration trump persistence and clustering for practical application development.</section></article><article class="post"><figure class="square"><picture><source srcset="/images/nuget-scheduler-80x80.webp?v=4e5974129f045a8390e2e29b217f7ecc" type="image/webp"><source srcset="/images/nuget-scheduler-80x80.png?v=21983cb7d1aaee6a20b10806f639db1c" type="image/png"><img src="/images/nuget-scheduler.png?v=4159bfd7c08b58b0fc741782fe532741" alt=".NET Job Scheduling — Quartz.NET for Enterprise Scale" loading="lazy" decoding="async" title=".NET Job Scheduling — Quartz.NET for Enterprise Scale"></picture></figure><header><h2><a href="/posts/dotnet-job-scheduling-3-quartznet/" rel="bookmark">.NET Job Scheduling — Quartz.NET for Enterprise Scale</a></h2></header><section class="content">Quartz.NET provides advanced scheduling semantics, database-backed clustering, and flexible storage for systems demanding complex workflows.
Understand when enterprise features justify operational complexity and how Quartz.NET scales across distributed deployments.</section></article></section></aside><nav class="pager"><a class="next" href="/posts/dotnet-job-scheduling-7-comparative-review/" title=".NET Job Scheduling — Choosing the Right Framework" rel="next"><span class="sub"><i class="fas fa-backward"></i>&emsp;Next</span><p class="title">.NET Job Scheduling — Choosing the Right Framework</p></a><a class="prev" href="/posts/dotnet-power-of-ten-rules/" title="Power of Ten Rules: More Relevant Than Ever for .NET" rel="prev"><span class="sub">Previous&emsp;<i class="fas fa-forward"></i></span><p class="title">Power of Ten Rules: More Relevant Than Ever for .NET</p></a></nav></main><footer class="footer"><div class="divider"></div><nav><ul class="navigation"><li><a href="/tags/">Tags</a></li><li><a href="/legal-notice/">Legal notice</a></li></ul></nav><div class="copyright">&copy; 2023 - 2026 Daily DevOps & .NET</div></footer><script defer src="/js/below.min.a6ce9164454b6077f17ae856f280442d9f3a1e21f06189f71c21f75144b22a0c8cf32bafd61d440e9d90ca02bf738b6a8ef19f5ec20285d8ca574f98c91ebaf2.js" integrity="sha512-ps6RZEVLYHfxeuhW8oBELZ86HiHwYYn3HCH3UUSyKgyM8yuv1h1EDp2QygK/c4tqjvGfXsIChdjKV0+YyR668g==" crossorigin="anonymous"></script><img class="vgwort" src="https://vg06.met.vgwort.de/na/ee93f5098fc447caba6f62ed70269eeb" width="1" height="1" alt="VG Wort" title="VG Wort"></body></html>