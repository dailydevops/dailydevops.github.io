<!doctype html><html class="no-js" lang="en" dir="ltr"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="theme-color" content="#15a"><title>Power of Ten Rules: More Relevant Than Ever for .NET — Daily DevOps & .NET</title><meta name="description" content="Gerard Holzmann&rsquo;s Power of Ten rules prevented spacecraft failures and exposed Toyota&rsquo;s fatal throttle bugs.
Four rules transfer directly to C# …"><meta name="twitter:description" property="og:description" content="Gerard Holzmann&rsquo;s Power of Ten rules prevented spacecraft failures and exposed Toyota&rsquo;s fatal throttle bugs.
Four rules transfer directly to C# …"><meta name="author" content="Martin Stühmer"><link rel="icon" href="/logo.svg?v=b9e294dc5c6fa04439c8c803d8e981a9" sizes="any" type="image/svg+xml"><meta name="twitter:title" property="og:title" content="Power of Ten Rules: More Relevant Than Ever for .NET — Daily DevOps & .NET"><meta property="og:updated_time" content="2025-12-10T16:51:07+01:00"><meta property="article:modified_time" content="2025-12-10T16:51:07+01:00"><meta property="article:published_time" content="2025-12-10T16:45:00+01:00"><meta property="og:type" content="article"><meta property="og:site_name" content="Daily DevOps & .NET"><meta property="og:url" content="https://daily-devops.net/posts/dotnet-power-of-ten-rules/"><meta property="og:locale" content="en_US"><meta name="twitter:card" content="summary_large_image"><meta property="og:image" name="twitter:image" content="https://daily-devops.net/images/dotnet-1200x630.webp?v=6903350f28c8176a63e4ef2647398a74"><meta property="og:image:secure_url" content="https://daily-devops.net/images/dotnet-1200x630.webp?v=6903350f28c8176a63e4ef2647398a74"><meta property="og:image:alt" name="twitter:image:alt" content="Power of Ten Rules: More Relevant Than Ever for .NET"><meta property="og:image:type" content="image/webp"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta property="og:image" name="twitter:image" content="https://daily-devops.net/images/dotnet-1200x630.png?v=f24aeee339dcfec95b7e986627b47e80"><meta property="og:image:secure_url" content="https://daily-devops.net/images/dotnet-1200x630.png?v=f24aeee339dcfec95b7e986627b47e80"><meta property="og:image:alt" name="twitter:image:alt" content="Power of Ten Rules: More Relevant Than Ever for .NET"><meta property="og:image:type" content="image/png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><link rel="dns-prefetch" href="https://www.clarity.ms"><link rel="preconnect" href="https://www.clarity.ms" crossorigin><link rel="stylesheet" href="/css/style.min.0b2ef4378cd908eb695017aaa74603d244ff2b38c8068b4b51d76cad830c8ee5e3a40b67ab5b860a542c8bae73d8ba90cfbe9249b59c733a50de74cc32af818a.css" integrity="sha512-Cy70N4zZCOtpUBeqp0YD0kT/KzjIBotLUddsrYMMjuXjpAtnq1uGClQsi65z2LqQz76SSbWcczpQ3nTMMq+Big==" crossorigin="anonymous"><link rel="alternate" href='https://daily-devops.net/posts/dotnet-power-of-ten-rules/' hreflang="x-default" title="Power of Ten Rules: More Relevant Than Ever for .NET &mdash; Daily DevOps & .NET"><link rel="canonical" href="https://daily-devops.net/posts/dotnet-power-of-ten-rules/" hreflang="en-us" title="Power of Ten Rules: More Relevant Than Ever for .NET &mdash; Daily DevOps & .NET"><link rel="home" href="https://daily-devops.net/" hreflang="en-us" title="Daily DevOps & .NET"><link rel="next" href="https://daily-devops.net/posts/dotnet-job-scheduling-6-tickerq/" hreflang="en-us" title=".NET Job Scheduling — TickerQ and Modern Architecture"><link rel="prev" href="https://daily-devops.net/posts/aks-network-policies-zero-trust/" hreflang="en-us" title="AKS Network Policies: The Security Layer Your Cluster Is Missing"><link rel="author" href="https://daily-devops.net/authors/martin/" hreflang="en-us" title="Martin Stühmer &mdash; Daily DevOps & .NET"><meta name="giscus:backlink" content="https://daily-devops.net/posts/dotnet-power-of-ten-rules/"><script defer src="/js/above.min.cb42b2c9a453e49e278326637d72d2f01e7f32e3f91e9cdde8fb587793d05514efd2f5cc5021c9658ca0f73876dbdcd1f7cb4a37c0bebc9df01110926b6d7cba.js" integrity="sha512-y0KyyaRT5J4ngyZjfXLS8B5/MuP5Hpzd6PtYd5PQVRTv0vXMUCHJZYyg9zh229zR98tKN8C+vJ3wERCSa218ug==" crossorigin="anonymous"></script><script type="text/javascript">(function(e,t,n,s,o,i,a){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)},i=t.createElement(s),i.async=1,i.src="https://www.clarity.ms/tag/"+o,a=t.getElementsByTagName(s)[0],a.parentNode.insertBefore(i,a)})(window,document,"clarity","script","o0pr4n9gg3")</script></head><body class="container"><header class="header"><a class="logo" href="/" title="Daily DevOps & .NET" rel="home"><figure class="page-logo"><picture><img src="/logo.svg?v=b9e294dc5c6fa04439c8c803d8e981a9" alt="Daily DevOps & .NET" title="Daily DevOps & .NET"></picture></figure><span class="title">Daily DevOps & .NET</span></a><nav class="menu"><button class="burger" aria-haspopup="true" aria-expanded="false" tabindex="0">
<i class="fas fa-burger"></i></button><ul class="navigation"><li class="active"><a href="/posts/">Posts</a></li><li><a href="/authors/">About us</a></li></ul></nav><div class="divider"></div></header><main class="body"><figure class="hero"><picture><source srcset="/images/dotnet-544x136.webp?v=8deae240ab29a253fdd870ccc2522db1" type="image/webp" media="(max-width: 575.98px)"><source srcset="/images/dotnet-544x136.png?v=3ee89197eed7bfe6dc981d865bcf1af8" type="image/png" media="(max-width: 575.98px)"><source srcset="/images/dotnet-672x168.webp?v=907d94834044fd750eb572d059d7ce9d" type="image/webp" media="(max-width: 767.98px)"><source srcset="/images/dotnet-672x168.png?v=393604ada8c34129314827b16854f318" type="image/png" media="(max-width: 767.98px)"><source srcset="/images/dotnet-896x224.webp?v=674850ecabe1d54a4ba68fa31376f67c" type="image/webp" media="(max-width: 991.98px)"><source srcset="/images/dotnet-896x224.png?v=e3b0bdf6719172ac8988c564589ffab6" type="image/png" media="(max-width: 991.98px)"><source srcset="/images/dotnet-1104x276.webp?v=be9564bfc4831ceb622ce676a9ce18c6" type="image/webp" media="(max-width: 1199.98px)"><source srcset="/images/dotnet-1104x276.png?v=7cdf379a6bc3890089d499366537490c" type="image/png" media="(max-width: 1199.98px)"><source srcset="/images/dotnet-1444x361.webp?v=ed1846da367596f59bcffad3b47dd691" type="image/webp"><source srcset="/images/dotnet-1444x361.png?v=7df14a8b64cb56e90ecffdb6c55720c7" type="image/png"><img src="/images/dotnet.png?v=8142ec8a038ba14415ff0d0434c78182" alt="Power of Ten Rules: More Relevant Than Ever for .NET" loading="lazy" decoding="async" title="Power of Ten Rules: More Relevant Than Ever for .NET"></picture></figure><article class="post"><header><h1>Power of Ten Rules: More Relevant Than Ever for .NET</h1></header><section class="content"><p>When someone handed me <a href="https://spinroot.com/gerard/pdf/P10.pdf" target="_blank" rel="noopener external noreferrer">Gerard Holzmann&rsquo;s &ldquo;Power of Ten&rdquo;</a> rules and asked whether they still apply to C# 10/.NET, my answer was immediate: Absolutely, and we can enforce them better than Gerard Holzmann could have dreamed in 2006. The Power of Ten originated at NASA&rsquo;s Jet Propulsion Laboratory for safety-critical C code in spacecraft systems. Not academic theory—principles where violations kill people. NASA&rsquo;s <a href="https://users.ece.cmu.edu/~koopman/pubs/koopman14_toyota_ua_slides.pdf" target="_blank" rel="noopener external noreferrer">2010 technical assessment of Toyota&rsquo;s electronic throttle control</a> found 243 violations contributing to unintended acceleration deaths. When prosecutors examine catastrophic embedded failures, these ten rules are the baseline for &ldquo;did you even try?&rdquo;</p><p>What&rsquo;s changed in two decades? In 2006, following these rules meant discipline, manual code reviews, and static analysis tools at $5,000 per seat. You verified bounded loops by hand, tracked pointer indirection with spreadsheets, enforced function length through policy documents nobody read. I&rsquo;ve reviewed enough legacy embedded code to know most teams failed. The tooling wasn&rsquo;t there, and manual enforcement doesn&rsquo;t scale past three developers. Modern C# flips this completely. Roslyn analyzers catch violations at compile time—before code review, before testing, before anyone debugs at 2 AM wondering why the production system locked up. Nullable reference types enforce null-safety that C developers achieved through religious discipline and hope. The type system makes pointer arithmetic bugs physically impossible. Built into the compiler, zero additional cost, enforced automatically.</p><p>The catch—and there&rsquo;s always a catch—is that not every rule translates directly. The managed runtime fundamentally rewrites what&rsquo;s dangerous and what&rsquo;s safe. Dynamic allocation is forbidden in embedded systems but powers every .NET framework feature. Recursion crashes spacecraft but handles expression trees beautifully when the CLR manages your stack. The real question isn&rsquo;t &ldquo;do these rules apply to C#?&rdquo; It&rsquo;s &ldquo;how do modern language features enforce the underlying principles better than 2006 C ever could?&rdquo; Let&rsquo;s examine each rule systematically.</p><h2 id="rule-1-avoid-complex-control-flow-no-goto-setjmplongjmp-recursion"><a href="/posts/dotnet-power-of-ten-rules/#rule-1-avoid-complex-control-flow-no-goto-setjmplongjmp-recursion" title="Rule 1: Avoid Complex Control Flow (No goto, setjmp/longjmp, Recursion)">Rule 1: Avoid Complex Control Flow (No goto, setjmp/longjmp, Recursion)</a></h2><p><strong>Original Intent:</strong> Simplify static analysis and prevent unpredictable control flow in embedded systems.</p><p><strong>C#/.NET Applicability:</strong> Partially valid, but context matters.</p><h3 id="what-still-applies"><a href="/posts/dotnet-power-of-ten-rules/#what-still-applies" title="What Still Applies">What Still Applies</a></h3><p><code>goto</code> remains controversial in C#, though the language supports it. I&rsquo;ve seen developers defend it passionately in code reviews, and honestly, for breaking out of deeply nested loops, it&rsquo;s occasionally the least-bad option. But &ldquo;occasionally&rdquo; is doing a lot of work in that sentence:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="c1">// Acceptable use case: breaking out of nested loops</span>
</span></span><span class="line"><span class="cl"><span class="kd">private</span> <span class="kt">bool</span> <span class="n">TryFindPosition</span><span class="p">(</span><span class="kt">int</span><span class="p">[,]</span> <span class="n">matrix</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">,</span> <span class="k">out</span> <span class="p">(</span><span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="kt">int</span> <span class="n">col</span><span class="p">)</span> <span class="n">position</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">rows</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">j</span> <span class="p">&lt;</span> <span class="n">cols</span><span class="p">;</span> <span class="n">j</span><span class="p">++)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="p">==</span> <span class="n">target</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">found</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>But this is clearer:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="c1">// Better: extract to method with early return</span>
</span></span><span class="line"><span class="cl"><span class="kd">private</span> <span class="kt">bool</span> <span class="n">TryFindPosition</span><span class="p">(</span><span class="kt">int</span><span class="p">[,]</span> <span class="n">matrix</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">,</span> <span class="k">out</span> <span class="p">(</span><span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="kt">int</span> <span class="n">col</span><span class="p">)</span> <span class="n">position</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">matrix</span><span class="p">.</span><span class="n">GetLength</span><span class="p">(</span><span class="m">0</span><span class="p">);</span> <span class="n">i</span><span class="p">++)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">j</span> <span class="p">&lt;</span> <span class="n">matrix</span><span class="p">.</span><span class="n">GetLength</span><span class="p">(</span><span class="m">1</span><span class="p">);</span> <span class="n">j</span><span class="p">++)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="p">==</span> <span class="n">target</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">position</span> <span class="p">=</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">position</span> <span class="p">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="whats-different"><a href="/posts/dotnet-power-of-ten-rules/#whats-different" title="What&rsquo;s Different">What&rsquo;s Different</a></h3><p><strong>Recursion</strong> tells a completely different story. The JIT compiler doesn&rsquo;t guarantee tail-call optimization like F# does. Still valuable for tree structures, parsing, algorithms where iterative alternatives become unreadable spaghetti. Key difference? Stack overflows throw exceptions you can catch and handle. In embedded C, stack overflow crashes the spacecraft. No recovery, no logging, just silence.</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="c1">// Recursion is perfectly acceptable for bounded structures</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="n">TreeNode</span><span class="p">?</span> <span class="n">Find</span><span class="p">(</span><span class="n">TreeNode</span><span class="p">?</span> <span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="k">value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="p">==</span> <span class="kc">null</span><span class="p">)</span> <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">Value</span> <span class="p">==</span> <span class="k">value</span><span class="p">)</span> <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">Find</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">Left</span><span class="p">,</span> <span class="k">value</span><span class="p">)</span> <span class="p">??</span> <span class="n">Find</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">Right</span><span class="p">,</span> <span class="k">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>For deep recursion, modern C# offers alternatives:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="c1">// Convert to iteration with explicit stack</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="n">TreeNode</span><span class="p">?</span> <span class="n">Find</span><span class="p">(</span><span class="n">TreeNode</span><span class="p">?</span> <span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="k">value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="p">==</span> <span class="kc">null</span><span class="p">)</span> <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="kt">var</span> <span class="n">stack</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="p">&lt;</span><span class="n">TreeNode</span><span class="p">&gt;();</span>
</span></span><span class="line"><span class="cl">    <span class="n">stack</span><span class="p">.</span><span class="n">Push</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">stack</span><span class="p">.</span><span class="n">Count</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">var</span> <span class="n">current</span> <span class="p">=</span> <span class="n">stack</span><span class="p">.</span><span class="n">Pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">Value</span> <span class="p">==</span> <span class="k">value</span><span class="p">)</span> <span class="k">return</span> <span class="n">current</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">Right</span> <span class="p">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="n">stack</span><span class="p">.</span><span class="n">Push</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">Right</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">Left</span> <span class="p">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="n">stack</span><span class="p">.</span><span class="n">Push</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">Left</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>Verdict:</strong> Use recursion where it makes sense, but be aware of stack depth. Avoid <code>goto</code> unless you have a compelling reason. The .NET runtime gives you safety nets that embedded C never had.</p><h2 id="rule-2-all-loops-must-have-fixed-upper-bounds"><a href="/posts/dotnet-power-of-ten-rules/#rule-2-all-loops-must-have-fixed-upper-bounds" title="Rule 2: All Loops Must Have Fixed Upper Bounds">Rule 2: All Loops Must Have Fixed Upper Bounds</a></h2><p><strong>Original Intent:</strong> Enable static analysis to prove termination and prevent infinite loops.</p><p><strong>C#/.NET Applicability:</strong> The principle is sound, but enforcement differs dramatically.</p><h3 id="modern-interpretation"><a href="/posts/dotnet-power-of-ten-rules/#modern-interpretation" title="Modern Interpretation">Modern Interpretation</a></h3><p>Provable termination is still the goal, but .NET gives you runtime safety nets that embedded C never had:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="c1">// Bad: unbounded loop</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">var</span> <span class="n">item</span> <span class="p">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">Dequeue</span><span class="p">();</span> <span class="c1">// What if queue is empty?</span>
</span></span><span class="line"><span class="cl">    <span class="n">Process</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Better: explicit bound with timeout</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">cts</span> <span class="p">=</span> <span class="k">new</span> <span class="n">CancellationTokenSource</span><span class="p">(</span><span class="n">TimeSpan</span><span class="p">.</span><span class="n">FromMinutes</span><span class="p">(</span><span class="m">5</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="p">(!</span><span class="n">cts</span><span class="p">.</span><span class="n">Token</span><span class="p">.</span><span class="n">IsCancellationRequested</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">queue</span><span class="p">.</span><span class="n">TryDequeue</span><span class="p">(</span><span class="k">out</span> <span class="kt">var</span> <span class="n">item</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Process</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="n">Delay</span><span class="p">(</span><span class="m">100</span><span class="p">,</span> <span class="n">cts</span><span class="p">.</span><span class="n">Token</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Modern .NET provides powerful static analysis through <a href="https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/overview" target="_blank" rel="noopener external noreferrer">Roslyn analyzers</a> that can detect unbounded loops during compilation. Enable nullable reference types and the latest analysis level to catch these issues early:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="nt">&lt;PropertyGroup&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;Nullable&gt;</span>enable<span class="nt">&lt;/Nullable&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;AnalysisLevel&gt;</span>latest<span class="nt">&lt;/AnalysisLevel&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/PropertyGroup&gt;</span>
</span></span></code></pre></div><p><strong>Verdict:</strong> Always use bounded loops. Modern C# makes this easier with <code>foreach</code>, LINQ&rsquo;s <code>Take()</code>, and cancellation tokens. The difference from embedded C: Your loops can be bounded at runtime with safe defaults rather than requiring compile-time constants.</p><h2 id="rule-3-no-dynamic-memory-allocation-after-initialization"><a href="/posts/dotnet-power-of-ten-rules/#rule-3-no-dynamic-memory-allocation-after-initialization" title="Rule 3: No Dynamic Memory Allocation After Initialization">Rule 3: No Dynamic Memory Allocation After Initialization</a></h2><p><strong>Original Intent:</strong> Prevent memory exhaustion and fragmentation in systems without virtual memory.</p><p><strong>C#/.NET Applicability:</strong> Fundamentally incompatible with .NET&rsquo;s design philosophy.</p><h3 id="why-this-rule-doesnt-translate"><a href="/posts/dotnet-power-of-ten-rules/#why-this-rule-doesnt-translate" title="Why This Rule Doesn&rsquo;t Translate">Why This Rule Doesn&rsquo;t Translate</a></h3><p>The .NET garbage collector exists precisely to enable safe dynamic allocation. Forbidding dynamic allocation in .NET is like forbidding breathing—every framework feature depends on it:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="c1">// Standard .NET patterns rely on GC</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">results</span> <span class="p">=</span> <span class="k">await</span> <span class="n">httpClient</span><span class="p">.</span><span class="n">GetStringAsync</span><span class="p">(</span><span class="n">url</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">parsed</span> <span class="p">=</span> <span class="n">JsonSerializer</span><span class="p">.</span><span class="n">Deserialize</span><span class="p">&lt;</span><span class="n">MyData</span><span class="p">&gt;(</span><span class="n">results</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">filtered</span> <span class="p">=</span> <span class="n">parsed</span><span class="p">.</span><span class="n">Items</span><span class="p">.</span><span class="n">Where</span><span class="p">(</span><span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span><span class="p">.</span><span class="n">IsActive</span><span class="p">).</span><span class="n">ToList</span><span class="p">();</span>
</span></span></code></pre></div><h3 id="the-modern-equivalent-minimize-allocations"><a href="/posts/dotnet-power-of-ten-rules/#the-modern-equivalent-minimize-allocations" title="The Modern Equivalent: Minimize Allocations">The Modern Equivalent: Minimize Allocations</a></h3><p>Rather than avoiding allocation entirely, focus on reducing unnecessary allocations and GC pressure:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="c1">// Inefficient: allocates multiple intermediate strings</span>
</span></span><span class="line"><span class="cl"><span class="kt">string</span> <span class="n">result</span> <span class="p">=</span> <span class="s">&#34;&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">1000</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">result</span> <span class="p">+=</span> <span class="s">$&#34;Item {i}; &#34;</span><span class="p">;</span>  <span class="c1">// Allocates new string each iteration</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Efficient: single allocation, reusable buffer</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">sb</span> <span class="p">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="p">(</span><span class="n">capacity</span><span class="p">:</span> <span class="m">1000</span> <span class="p">*</span> <span class="m">15</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">1000</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">sb</span><span class="p">.</span><span class="n">Append</span><span class="p">(</span><span class="s">&#34;Item &#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">sb</span><span class="p">.</span><span class="n">Append</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">sb</span><span class="p">.</span><span class="n">Append</span><span class="p">(</span><span class="s">&#34;; &#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">string</span> <span class="n">result</span> <span class="p">=</span> <span class="n">sb</span><span class="p">.</span><span class="n">ToString</span><span class="p">();</span>
</span></span></code></pre></div><h3 id="stack-allocation-for-performance-critical-code"><a href="/posts/dotnet-power-of-ten-rules/#stack-allocation-for-performance-critical-code" title="Stack Allocation for Performance-Critical Code">Stack Allocation for Performance-Critical Code</a></h3><p>When allocation overhead matters, use <code>Span&lt;T></code> with <code>stackalloc</code>:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="c1">// Stack allocation for small, temporary buffers</span>
</span></span><span class="line"><span class="cl"><span class="n">Span</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">buffer</span> <span class="p">=</span> <span class="k">stackalloc</span> <span class="kt">int</span><span class="p">[</span><span class="m">256</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">buffer</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">ComputeValue</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">ProcessData</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
</span></span></code></pre></div><p><strong>Critical constraints:</strong> Stack allocations come with three important limitations. First, analyzer rule <a href="https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/quality-rules/ca2014" target="_blank" rel="noopener external noreferrer">CA2014</a> prevents using <code>stackalloc</code> inside loops to avoid stack overflow. Second, keep allocations small (under 1KB recommended) since stack space is limited. Third, <code>Span&lt;T></code> can&rsquo;t escape method scope: attempting to return it produces compiler error <a href="https://learn.microsoft.com/en-us/dotnet/csharp/misc/cs8347" target="_blank" rel="noopener external noreferrer">CS8347</a>. For data that needs to escape, use <code>Memory&lt;T></code> or arrays instead.</p><h3 id="object-pooling-for-hot-paths"><a href="/posts/dotnet-power-of-ten-rules/#object-pooling-for-hot-paths" title="Object Pooling for Hot Paths">Object Pooling for Hot Paths</a></h3><p>For high-throughput scenarios:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="c1">// Use ArrayPool for reusable buffers</span>
</span></span><span class="line"><span class="cl"><span class="kt">byte</span><span class="p">[]</span> <span class="n">buffer</span> <span class="p">=</span> <span class="n">ArrayPool</span><span class="p">&lt;</span><span class="kt">byte</span><span class="p">&gt;.</span><span class="n">Shared</span><span class="p">.</span><span class="n">Rent</span><span class="p">(</span><span class="m">4096</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">try</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">bytesRead</span> <span class="p">=</span> <span class="k">await</span> <span class="n">stream</span><span class="p">.</span><span class="n">ReadAsync</span><span class="p">(</span><span class="n">buffer</span><span class="p">.</span><span class="n">AsMemory</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">4096</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">ProcessBytes</span><span class="p">(</span><span class="n">buffer</span><span class="p">.</span><span class="n">AsSpan</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="n">bytesRead</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">finally</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ArrayPool</span><span class="p">&lt;</span><span class="kt">byte</span><span class="p">&gt;.</span><span class="n">Shared</span><span class="p">.</span><span class="n">Return</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>Verdict:</strong> Don&rsquo;t avoid allocation, manage it intelligently. Use <code>Span&lt;T></code>/<code>Memory&lt;T></code> for performance-critical code, <code>ArrayPool&lt;T></code> for reusable buffers, and profile before optimizing. I&rsquo;ve watched teams waste months optimizing allocations that consumed 2% of execution time while ignoring the database query running on every keystroke. The GC is your friend, not your enemy—but measure before you fight it.</p><h2 id="rule-4-no-function-longer-than-one-printed-page-60-lines"><a href="/posts/dotnet-power-of-ten-rules/#rule-4-no-function-longer-than-one-printed-page-60-lines" title="Rule 4: No Function Longer Than One Printed Page (~60 Lines)">Rule 4: No Function Longer Than One Printed Page (~60 Lines)</a></h2><p><strong>Original Intent:</strong> Keep functions digestible for human review and static analysis.</p><p><strong>C#/.NET Applicability:</strong> Absolutely valid, possibly even more important.</p><h3 id="why-this-rule-still-matters"><a href="/posts/dotnet-power-of-ten-rules/#why-this-rule-still-matters" title="Why This Rule Still Matters">Why This Rule Still Matters</a></h3><p>In 15 years across finance, healthcare, and industrial control systems, I&rsquo;ve never once regretted breaking a long method into smaller pieces. I&rsquo;ve regretted plenty of 500-line monsters—particularly the one in a reporting visualization that took three developers two weeks to debug because nobody could hold the entire state machine in their head:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="c1">// Bad: 250-line method doing everything</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">OrderResult</span><span class="p">&gt;</span> <span class="n">ProcessOrder</span><span class="p">(</span><span class="n">OrderRequest</span> <span class="n">request</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Validate customer</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Check inventory</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Calculate pricing</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Apply discounts</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Process payment</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Update inventory</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Send notifications</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Log everything</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Handle 12 different error cases</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 200 more lines</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Modern C# actually makes this rule easier to enforce:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="c1">// Good: orchestration method with clear intent</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">OrderResult</span><span class="p">&gt;</span> <span class="n">ProcessOrder</span><span class="p">(</span><span class="n">OrderRequest</span> <span class="n">request</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">var</span> <span class="n">customer</span> <span class="p">=</span> <span class="k">await</span> <span class="n">ValidateCustomer</span><span class="p">(</span><span class="n">request</span><span class="p">.</span><span class="n">CustomerId</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">var</span> <span class="n">availability</span> <span class="p">=</span> <span class="k">await</span> <span class="n">CheckInventory</span><span class="p">(</span><span class="n">request</span><span class="p">.</span><span class="n">Items</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(!</span><span class="n">availability</span><span class="p">.</span><span class="n">AllAvailable</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">OrderResult</span><span class="p">.</span><span class="n">OutOfStock</span><span class="p">(</span><span class="n">availability</span><span class="p">.</span><span class="n">UnavailableItems</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="kt">var</span> <span class="n">pricing</span> <span class="p">=</span> <span class="n">CalculatePricing</span><span class="p">(</span><span class="n">request</span><span class="p">.</span><span class="n">Items</span><span class="p">,</span> <span class="n">customer</span><span class="p">.</span><span class="n">Tier</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">var</span> <span class="n">payment</span> <span class="p">=</span> <span class="k">await</span> <span class="n">ProcessPayment</span><span class="p">(</span><span class="n">customer</span><span class="p">,</span> <span class="n">pricing</span><span class="p">.</span><span class="n">Total</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(!</span><span class="n">payment</span><span class="p">.</span><span class="n">Succeeded</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">OrderResult</span><span class="p">.</span><span class="n">PaymentFailed</span><span class="p">(</span><span class="n">payment</span><span class="p">.</span><span class="n">Reason</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">await</span> <span class="n">UpdateInventory</span><span class="p">(</span><span class="n">request</span><span class="p">.</span><span class="n">Items</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">await</span> <span class="n">SendConfirmation</span><span class="p">(</span><span class="n">customer</span><span class="p">,</span> <span class="n">request</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">OrderResult</span><span class="p">.</span><span class="n">Success</span><span class="p">(</span><span class="n">payment</span><span class="p">.</span><span class="n">TransactionId</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="modern-enforcement-tools"><a href="/posts/dotnet-power-of-ten-rules/#modern-enforcement-tools" title="Modern Enforcement Tools">Modern Enforcement Tools</a></h3><p>Unlike 2006 C, modern tooling enforces this automatically. The <a href="https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/quality-rules/ca1505" target="_blank" rel="noopener external noreferrer">CA1505 analyzer rule</a> flags unmaintainable code based on cyclomatic complexity and maintainability index. Configure it in <code>.editorconfig</code> to treat violations as warnings, ensuring your team maintains digestible function sizes without manual review.</p><p><strong>Local functions</strong> reduce the need for small private methods:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="kd">public</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Order</span><span class="p">&gt;</span> <span class="n">GetRecentOrders</span><span class="p">(</span><span class="n">Customer</span> <span class="n">customer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">var</span> <span class="n">cutoffDate</span> <span class="p">=</span> <span class="n">DateTime</span><span class="p">.</span><span class="n">UtcNow</span><span class="p">.</span><span class="n">AddDays</span><span class="p">(-</span><span class="m">30</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">customer</span><span class="p">.</span><span class="n">Orders</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">Where</span><span class="p">(</span><span class="n">IsRecent</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">OrderByDescending</span><span class="p">(</span><span class="n">o</span> <span class="p">=&gt;</span> <span class="n">o</span><span class="p">.</span><span class="n">Date</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">IsRecent</span><span class="p">(</span><span class="n">Order</span> <span class="n">order</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">order</span><span class="p">.</span><span class="n">Date</span> <span class="p">&gt;=</span> <span class="n">cutoffDate</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>Verdict:</strong> If anything, aim for shorter than 60 lines. With expression-bodied members, local functions, and LINQ, there&rsquo;s no excuse for bloated methods. Enable analyzers to enforce it.</p><h2 id="rule-5-assertion-density-of-two-per-function"><a href="/posts/dotnet-power-of-ten-rules/#rule-5-assertion-density-of-two-per-function" title="Rule 5: Assertion Density of Two Per Function">Rule 5: Assertion Density of Two Per Function</a></h2><p><strong>Original Intent:</strong> Catch anomalous conditions early with runtime checks.</p><p><strong>C#/.NET Applicability:</strong> Valid principle, but modern C# offers better mechanisms.</p><h3 id="the-modern-equivalent-multiple-layers-of-defense"><a href="/posts/dotnet-power-of-ten-rules/#the-modern-equivalent-multiple-layers-of-defense" title="The Modern Equivalent: Multiple Layers of Defense">The Modern Equivalent: Multiple Layers of Defense</a></h3><p>NASA wanted two runtime assertions per function. C# gives you something better—multiple enforcement layers, starting at compile time:</p><p><strong>1. Compile-Time Checks: Nullable Reference Types</strong></p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="cp">#nullable</span> <span class="n">enable</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">class</span> <span class="nc">OrderProcessor</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Compiler enforces non-null at compile time</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">OrderResult</span> <span class="n">Process</span><span class="p">(</span><span class="n">Order</span> <span class="n">order</span><span class="p">,</span> <span class="n">Customer</span> <span class="n">customer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// No runtime null check needed - compiler guarantees non-null</span>
</span></span><span class="line"><span class="cl">        <span class="kt">var</span> <span class="n">total</span> <span class="p">=</span> <span class="n">order</span><span class="p">.</span><span class="n">Items</span><span class="p">.</span><span class="n">Sum</span><span class="p">(</span><span class="n">i</span> <span class="p">=&gt;</span> <span class="n">i</span><span class="p">.</span><span class="n">Price</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// Nullable warns if customer.Email might be null</span>
</span></span><span class="line"><span class="cl">        <span class="n">SendReceipt</span><span class="p">(</span><span class="n">customer</span><span class="p">.</span><span class="n">Email</span><span class="p">,</span> <span class="n">total</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">OrderResult</span><span class="p">.</span><span class="n">Success</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="k">void</span> <span class="n">SendReceipt</span><span class="p">(</span><span class="kt">string</span> <span class="n">email</span><span class="p">,</span> <span class="kt">decimal</span> <span class="n">amount</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// email is guaranteed non-null by caller contract</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>2. Parameter Validation: Guard Clauses</strong></p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">void</span> <span class="n">ProcessPayment</span><span class="p">(</span><span class="kt">decimal</span> <span class="n">amount</span><span class="p">,</span> <span class="n">PaymentMethod</span> <span class="n">method</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ArgumentNullException</span><span class="p">.</span><span class="n">ThrowIfNull</span><span class="p">(</span><span class="n">method</span><span class="p">);</span>  <span class="c1">// .NET 6+</span>
</span></span><span class="line"><span class="cl">    <span class="n">ArgumentOutOfRangeException</span><span class="p">.</span><span class="n">ThrowIfNegativeOrZero</span><span class="p">(</span><span class="n">amount</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Business logic here</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Pre-.NET 6 equivalent</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">void</span> <span class="n">ProcessPayment</span><span class="p">(</span><span class="kt">decimal</span> <span class="n">amount</span><span class="p">,</span> <span class="n">PaymentMethod</span> <span class="n">method</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">method</span> <span class="k">is</span> <span class="kc">null</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">throw</span> <span class="k">new</span> <span class="n">ArgumentNullException</span><span class="p">(</span><span class="n">nameof</span><span class="p">(</span><span class="n">method</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">amount</span> <span class="p">&lt;=</span> <span class="m">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">throw</span> <span class="k">new</span> <span class="n">ArgumentOutOfRangeException</span><span class="p">(</span><span class="n">nameof</span><span class="p">(</span><span class="n">amount</span><span class="p">),</span> <span class="s">&#34;Amount must be positive&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Business logic here</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>3. Debug Assertions for Internal Invariants</strong></p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">System.Diagnostics</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">void</span> <span class="n">UpdateBalance</span><span class="p">(</span><span class="n">Account</span> <span class="n">account</span><span class="p">,</span> <span class="kt">decimal</span> <span class="n">delta</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Debug</span><span class="p">.</span><span class="n">Assert</span><span class="p">(</span><span class="n">account</span> <span class="p">!=</span> <span class="kc">null</span><span class="p">,</span> <span class="s">&#34;Account should never be null here&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Debug</span><span class="p">.</span><span class="n">Assert</span><span class="p">(!</span><span class="n">account</span><span class="p">.</span><span class="n">IsClosed</span><span class="p">,</span> <span class="s">&#34;Should not update closed accounts&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">account</span><span class="p">.</span><span class="n">Balance</span> <span class="p">+=</span> <span class="n">delta</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">Debug</span><span class="p">.</span><span class="n">Assert</span><span class="p">(</span><span class="n">account</span><span class="p">.</span><span class="n">Balance</span> <span class="p">&gt;=</span> <span class="m">0</span><span class="p">,</span> <span class="s">&#34;Balance should never go negative&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>Key difference:</strong> <code>Debug.Assert</code> is removed in Release builds, making it suitable for checking invariants during development without runtime cost. For mission-critical code, consider <a href="https://learn.microsoft.com/en-us/dotnet/framework/debug-trace-profile/code-contracts" target="_blank" rel="noopener external noreferrer">Code Contracts</a> which provide formal preconditions, postconditions, and object invariants with static verification support.</p><h3 id="pattern-matching-for-exhaustiveness"><a href="/posts/dotnet-power-of-ten-rules/#pattern-matching-for-exhaustiveness" title="Pattern Matching for Exhaustiveness">Pattern Matching for Exhaustiveness</a></h3><p>Modern C# can enforce completeness at compile time:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kt">string</span> <span class="n">GetStatusMessage</span><span class="p">(</span><span class="n">OrderStatus</span> <span class="n">status</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">status</span> <span class="k">switch</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">OrderStatus</span><span class="p">.</span><span class="n">Pending</span> <span class="p">=&gt;</span> <span class="s">&#34;Order is pending&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">OrderStatus</span><span class="p">.</span><span class="n">Processing</span> <span class="p">=&gt;</span> <span class="s">&#34;Order is being processed&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">OrderStatus</span><span class="p">.</span><span class="n">Shipped</span> <span class="p">=&gt;</span> <span class="s">&#34;Order has been shipped&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">OrderStatus</span><span class="p">.</span><span class="n">Delivered</span> <span class="p">=&gt;</span> <span class="s">&#34;Order delivered&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">OrderStatus</span><span class="p">.</span><span class="n">Cancelled</span> <span class="p">=&gt;</span> <span class="s">&#34;Order cancelled&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Compiler error if any enum value is missing (with warnings enabled)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>Verdict:</strong> Use nullable reference types for compile-time null safety, guard clauses for parameter validation, and <code>Debug.Assert</code> for invariants. This gives you better than &ldquo;two assertions per function&rdquo;: you get enforcement at compile time where possible, and runtime checks where needed.</p><h2 id="rule-6-declare-data-at-smallest-possible-scope"><a href="/posts/dotnet-power-of-ten-rules/#rule-6-declare-data-at-smallest-possible-scope" title="Rule 6: Declare Data at Smallest Possible Scope">Rule 6: Declare Data at Smallest Possible Scope</a></h2><p><strong>Original Intent:</strong> Minimize variable lifetime and potential misuse.</p><p><strong>C#/.NET Applicability:</strong> Completely valid and reinforced by modern language features.</p><h3 id="modern-c-makes-this-easier"><a href="/posts/dotnet-power-of-ten-rules/#modern-c-makes-this-easier" title="Modern C# Makes This Easier">Modern C# Makes This Easier</a></h3><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="c1">// Bad: variables declared too early</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">void</span> <span class="n">ProcessData</span><span class="p">(</span><span class="kt">int</span><span class="p">[]</span> <span class="n">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">sum</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">count</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">average</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">max</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 50 lines later...</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">data</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">sum</span> <span class="p">+=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">count</span><span class="p">++;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">average</span> <span class="p">=</span> <span class="n">sum</span> <span class="p">/</span> <span class="n">count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Another 30 lines...</span>
</span></span><span class="line"><span class="cl">    <span class="n">max</span> <span class="p">=</span> <span class="n">data</span><span class="p">.</span><span class="n">Max</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Good: declare at point of use</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">void</span> <span class="n">ProcessData</span><span class="p">(</span><span class="kt">int</span><span class="p">[]</span> <span class="n">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ... other logic ...</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">sum</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="k">value</span> <span class="k">in</span> <span class="n">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">sum</span> <span class="p">+=</span> <span class="k">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">average</span> <span class="p">=</span> <span class="n">sum</span> <span class="p">/</span> <span class="n">data</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// ... other logic ...</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">max</span> <span class="p">=</span> <span class="n">data</span><span class="p">.</span><span class="n">Max</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="pattern-matching-limits-scope-automatically"><a href="/posts/dotnet-power-of-ten-rules/#pattern-matching-limits-scope-automatically" title="Pattern Matching Limits Scope Automatically">Pattern Matching Limits Scope Automatically</a></h3><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="c1">// Scope limited to when pattern matches</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">obj</span> <span class="k">is</span> <span class="n">Customer</span> <span class="p">{</span> <span class="n">IsActive</span><span class="p">:</span> <span class="kc">true</span> <span class="p">}</span> <span class="n">customer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// &#39;customer&#39; only exists in this block</span>
</span></span><span class="line"><span class="cl">    <span class="n">ProcessCustomer</span><span class="p">(</span><span class="n">customer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#39;customer&#39; doesn&#39;t exist here</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Switch expressions with declaration patterns</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">discount</span> <span class="p">=</span> <span class="n">order</span> <span class="k">switch</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span> <span class="n">Total</span><span class="p">:</span> <span class="p">&gt;</span> <span class="m">1000</span> <span class="p">}</span> <span class="n">largeOrder</span> <span class="p">=&gt;</span> <span class="n">largeOrder</span><span class="p">.</span><span class="n">Total</span> <span class="p">*</span> <span class="m">0.1</span><span class="n">m</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span> <span class="n">Customer</span><span class="p">.</span><span class="n">IsPremium</span><span class="p">:</span> <span class="kc">true</span> <span class="p">}</span> <span class="n">premiumOrder</span> <span class="p">=&gt;</span> <span class="n">premiumOrder</span><span class="p">.</span><span class="n">Total</span> <span class="p">*</span> <span class="m">0.05</span><span class="n">m</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">_</span> <span class="p">=&gt;</span> <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h3 id="using-declarations-for-resource-management"><a href="/posts/dotnet-power-of-ten-rules/#using-declarations-for-resource-management" title="Using Declarations for Resource Management">Using Declarations for Resource Management</a></h3><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="c1">// Bad: resource scope too broad</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">ReadConfig</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">var</span> <span class="n">stream</span> <span class="p">=</span> <span class="n">File</span><span class="p">.</span><span class="n">OpenRead</span><span class="p">(</span><span class="s">&#34;config.json&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">try</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 100 lines of code</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">await</span> <span class="n">ReadFromStream</span><span class="p">(</span><span class="n">stream</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">finally</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">stream</span><span class="p">.</span><span class="n">Dispose</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Good: using declaration limits scope</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">ReadConfig</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">stream</span> <span class="p">=</span> <span class="n">File</span><span class="p">.</span><span class="n">OpenRead</span><span class="p">(</span><span class="s">&#34;config.json&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">await</span> <span class="n">ReadFromStream</span><span class="p">(</span><span class="n">stream</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// stream disposed here, not at method end</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Even better: compact using declaration (C# 8+)</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">ReadConfig</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="nn">var</span> <span class="n">stream</span> <span class="p">=</span> <span class="n">File</span><span class="p">.</span><span class="n">OpenRead</span><span class="p">(</span><span class="s">&#34;config.json&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">await</span> <span class="n">ReadFromStream</span><span class="p">(</span><span class="n">stream</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// stream disposed at end of method automatically</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>Verdict:</strong> More relevant than ever. Pattern matching limits scope automatically. Using declarations prevent resource leaks. Block-scoped variables can&rsquo;t escape their intended lifetime. C# 10&rsquo;s file-scoped namespaces extend this principle to namespace declarations—one less level of indentation, one less place for variables to hide.</p><h2 id="rule-7-check-return-values-and-parameter-validity"><a href="/posts/dotnet-power-of-ten-rules/#rule-7-check-return-values-and-parameter-validity" title="Rule 7: Check Return Values and Parameter Validity">Rule 7: Check Return Values and Parameter Validity</a></h2><p><strong>Original Intent:</strong> Never ignore potential failures; validate all inputs.</p><p><strong>C#/.NET Applicability:</strong> Absolutely critical, but mechanisms differ.</p><h3 id="return-value-checking-exceptions-vs-result-types"><a href="/posts/dotnet-power-of-ten-rules/#return-value-checking-exceptions-vs-result-types" title="Return Value Checking: Exceptions vs. Result Types">Return Value Checking: Exceptions vs. Result Types</a></h3><p>.NET uses exceptions for error conditions, unlike C&rsquo;s return codes:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="c1">// .NET idiomatic: exception-based</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">void</span> <span class="n">SaveCustomer</span><span class="p">(</span><span class="n">Customer</span> <span class="n">customer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ArgumentNullException</span><span class="p">.</span><span class="n">ThrowIfNull</span><span class="p">(</span><span class="n">customer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">try</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">database</span><span class="p">.</span><span class="n">SaveChanges</span><span class="p">();</span>  <span class="c1">// Throws on error</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">catch</span> <span class="p">(</span><span class="n">DbUpdateException</span> <span class="n">ex</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">logger</span><span class="p">.</span><span class="n">LogError</span><span class="p">(</span><span class="n">ex</span><span class="p">,</span> <span class="s">&#34;Failed to save customer {CustomerId}&#34;</span><span class="p">,</span> <span class="n">customer</span><span class="p">.</span><span class="n">Id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">throw</span><span class="p">;</span>  <span class="c1">// Re-throw or wrap in domain exception</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>But C#&rsquo;s <code>Try*</code> pattern provides explicit success/failure:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="c1">// When failure is expected and not exceptional</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(!</span><span class="kt">int</span><span class="p">.</span><span class="n">TryParse</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="k">out</span> <span class="kt">int</span> <span class="k">value</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;Invalid number format&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(!</span><span class="n">inventory</span><span class="p">.</span><span class="n">TryReserve</span><span class="p">(</span><span class="n">productId</span><span class="p">,</span> <span class="n">quantity</span><span class="p">,</span> <span class="k">out</span> <span class="kt">var</span> <span class="n">reservation</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">OrderResult</span><span class="p">.</span><span class="n">InsufficientStock</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="modern-pattern-result-types"><a href="/posts/dotnet-power-of-ten-rules/#modern-pattern-result-types" title="Modern Pattern: Result Types">Modern Pattern: Result Types</a></h3><p>When failure is a normal business outcome rather than an exceptional condition, exceptions feel wrong. Result types make success and failure explicit:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">record</span> <span class="nc">Result</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">bool</span> <span class="n">Success</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">init</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">T</span><span class="p">?</span> <span class="n">Value</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">init</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">string?</span> <span class="n">Error</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">init</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Result</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">Ok</span><span class="p">(</span><span class="n">T</span> <span class="k">value</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="k">new</span><span class="p">()</span> <span class="p">{</span> <span class="n">Success</span> <span class="p">=</span> <span class="kc">true</span><span class="p">,</span> <span class="n">Value</span> <span class="p">=</span> <span class="k">value</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Result</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">Fail</span><span class="p">(</span><span class="kt">string</span> <span class="n">error</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="k">new</span><span class="p">()</span> <span class="p">{</span> <span class="n">Success</span> <span class="p">=</span> <span class="kc">false</span><span class="p">,</span> <span class="n">Error</span> <span class="p">=</span> <span class="n">error</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">Result</span><span class="p">&lt;</span><span class="n">Order</span><span class="p">&gt;&gt;</span> <span class="n">PlaceOrder</span><span class="p">(</span><span class="n">OrderRequest</span> <span class="n">request</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">var</span> <span class="n">validationResult</span> <span class="p">=</span> <span class="n">ValidateRequest</span><span class="p">(</span><span class="n">request</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(!</span><span class="n">validationResult</span><span class="p">.</span><span class="n">Success</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">Result</span><span class="p">&lt;</span><span class="n">Order</span><span class="p">&gt;.</span><span class="n">Fail</span><span class="p">(</span><span class="n">validationResult</span><span class="p">.</span><span class="n">Error</span><span class="p">!);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="kt">var</span> <span class="n">paymentResult</span> <span class="p">=</span> <span class="k">await</span> <span class="n">ProcessPayment</span><span class="p">(</span><span class="n">request</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(!</span><span class="n">paymentResult</span><span class="p">.</span><span class="n">Success</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">Result</span><span class="p">&lt;</span><span class="n">Order</span><span class="p">&gt;.</span><span class="n">Fail</span><span class="p">(</span><span class="n">paymentResult</span><span class="p">.</span><span class="n">Error</span><span class="p">!);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">Result</span><span class="p">&lt;</span><span class="n">Order</span><span class="p">&gt;.</span><span class="n">Ok</span><span class="p">(</span><span class="n">CreateOrder</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">paymentResult</span><span class="p">.</span><span class="n">Value</span><span class="p">!));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="parameter-validation-multiple-strategies"><a href="/posts/dotnet-power-of-ten-rules/#parameter-validation-multiple-strategies" title="Parameter Validation: Multiple Strategies">Parameter Validation: Multiple Strategies</a></h3><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">class</span> <span class="nc">OrderService</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 1. Constructor validation</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">OrderService</span><span class="p">(</span><span class="n">IOrderRepository</span> <span class="n">repository</span><span class="p">,</span> <span class="n">ILogger</span> <span class="n">logger</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ArgumentNullException</span><span class="p">.</span><span class="n">ThrowIfNull</span><span class="p">(</span><span class="n">repository</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">ArgumentNullException</span><span class="p">.</span><span class="n">ThrowIfNull</span><span class="p">(</span><span class="n">logger</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="n">_repository</span> <span class="p">=</span> <span class="n">repository</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">_logger</span> <span class="p">=</span> <span class="n">logger</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 2. Method parameter validation</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Order</span> <span class="n">CreateOrder</span><span class="p">(</span><span class="n">Customer</span> <span class="n">customer</span><span class="p">,</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">OrderItem</span><span class="p">&gt;</span> <span class="n">items</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ArgumentNullException</span><span class="p">.</span><span class="n">ThrowIfNull</span><span class="p">(</span><span class="n">customer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">ArgumentNullException</span><span class="p">.</span><span class="n">ThrowIfNull</span><span class="p">(</span><span class="n">items</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">items</span><span class="p">.</span><span class="n">Count</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">throw</span> <span class="k">new</span> <span class="n">ArgumentException</span><span class="p">(</span><span class="s">&#34;Order must contain at least one item&#34;</span><span class="p">,</span> <span class="n">nameof</span><span class="p">(</span><span class="n">items</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">items</span><span class="p">.</span><span class="n">Any</span><span class="p">(</span><span class="n">i</span> <span class="p">=&gt;</span> <span class="n">i</span><span class="p">.</span><span class="n">Quantity</span> <span class="p">&lt;=</span> <span class="m">0</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="k">throw</span> <span class="k">new</span> <span class="n">ArgumentException</span><span class="p">(</span><span class="s">&#34;All items must have positive quantity&#34;</span><span class="p">,</span> <span class="n">nameof</span><span class="p">(</span><span class="n">items</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// Business logic</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="analyzer-support"><a href="/posts/dotnet-power-of-ten-rules/#analyzer-support" title="Analyzer Support">Analyzer Support</a></h3><p>Roslyn analyzers automatically detect unchecked return values. Enable <a href="https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/quality-rules/ca1806" target="_blank" rel="noopener external noreferrer">CA1806</a> to catch ignored method results and <a href="https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/style-rules/ide0058" target="_blank" rel="noopener external noreferrer">IDE0058</a> to flag unused expression values. These analyzers ensure your team never silently discards important return information.</p><p><strong>Verdict:</strong> Always validate parameters. Always handle exceptions or check return values. Use <code>ArgumentNullException.ThrowIfNull()</code> for parameter checks, <code>Try*</code> methods for expected failures, and exceptions for exceptional conditions.</p><h2 id="rule-8-limited-preprocessor-use"><a href="/posts/dotnet-power-of-ten-rules/#rule-8-limited-preprocessor-use" title="Rule 8: Limited Preprocessor Use">Rule 8: Limited Preprocessor Use</a></h2><p><strong>Original Intent:</strong> Avoid complex macros that obscure code meaning and hinder analysis.</p><p><strong>C#/.NET Applicability:</strong> Largely irrelevant: C# preprocessor is far more constrained.</p><h3 id="what-c-doesnt-have-thank-goodness"><a href="/posts/dotnet-power-of-ten-rules/#what-c-doesnt-have-thank-goodness" title="What C# Doesn&rsquo;t Have (Thank Goodness)">What C# Doesn&rsquo;t Have (Thank Goodness)</a></h3><p>C# preprocessor directives can&rsquo;t:</p><ul><li>Define function-like macros</li><li>Perform token pasting</li><li>Create recursive macros</li><li>Hide complex logic</li></ul><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="c1">// This is NOT possible in C#:</span>
</span></span><span class="line"><span class="cl"><span class="c1">// #define MAX(a, b) ((a) &gt; (b) ? (a) : (b))   // No function-like macros</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// What C# DOES support:</span>
</span></span><span class="line"><span class="cl"><span class="cp">#define</span> <span class="n">DEBUG_LOGGING</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if</span> <span class="n">DEBUG_LOGGING</span>
</span></span><span class="line"><span class="cl">    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;Debug information&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif</span>
</span></span></code></pre></div><h3 id="the-real-concern-conditional-compilation-abuse"><a href="/posts/dotnet-power-of-ten-rules/#the-real-concern-conditional-compilation-abuse" title="The Real Concern: Conditional Compilation Abuse">The Real Concern: Conditional Compilation Abuse</a></h3><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="c1">// Bad: excessive conditional compilation</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">class</span> <span class="nc">ConfigService</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">string</span> <span class="n">GetConnectionString</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="cp">#if</span> <span class="n">PRODUCTION</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="s">&#34;Production connection string&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="cp">#elif</span> <span class="n">STAGING</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="s">&#34;Staging connection string&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="cp">#elif</span> <span class="n">DEVELOPMENT</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="s">&#34;Development connection string&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="cp">#else</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="s">&#34;Local connection string&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="cp">#endif</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Good: configuration-based approach</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">class</span> <span class="nc">ConfigService</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="k">readonly</span> <span class="n">IConfiguration</span> <span class="n">_config</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">ConfigService</span><span class="p">(</span><span class="n">IConfiguration</span> <span class="n">config</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">_config</span> <span class="p">=</span> <span class="n">config</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">string</span> <span class="n">GetConnectionString</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">_config</span><span class="p">.</span><span class="n">GetConnectionString</span><span class="p">(</span><span class="s">&#34;DefaultConnection&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="legitimate-uses"><a href="/posts/dotnet-power-of-ten-rules/#legitimate-uses" title="Legitimate Uses">Legitimate Uses</a></h3><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="c1">// Acceptable: Debug-only code</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">void</span> <span class="n">ProcessData</span><span class="p">(</span><span class="kt">int</span><span class="p">[]</span> <span class="n">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cp">#if</span> <span class="n">DEBUG</span>
</span></span><span class="line"><span class="cl">    <span class="n">Debug</span><span class="p">.</span><span class="n">Assert</span><span class="p">(</span><span class="n">data</span> <span class="p">!=</span> <span class="kc">null</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Debug</span><span class="p">.</span><span class="n">Assert</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">Length</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="cp">#endif</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Production code</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">sum</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="k">value</span> <span class="k">in</span> <span class="n">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">sum</span> <span class="p">+=</span> <span class="k">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Acceptable: Platform-specific code</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if</span> <span class="n">WINDOWS</span>
</span></span><span class="line"><span class="cl"><span class="na">    [DllImport(&#34;user32.dll&#34;)]</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">extern</span> <span class="kt">bool</span> <span class="n">ShowWindow</span><span class="p">(</span><span class="n">IntPtr</span> <span class="n">hWnd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nCmdShow</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#elif</span> <span class="n">LINUX</span>
</span></span><span class="line"><span class="cl"><span class="na">    [DllImport(&#34;libX11.so&#34;)]</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">extern</span> <span class="kt">int</span> <span class="n">XOpenDisplay</span><span class="p">(</span><span class="kt">string</span> <span class="n">display_name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif</span>
</span></span></code></pre></div><p><strong>Verdict:</strong> C#&rsquo;s preprocessor is already minimal by design. Use it for debug-only code and platform-specific implementations. For everything else, use dependency injection and configuration.</p><h2 id="rule-9-restrict-pointer-use-max-one-level-of-dereferencing"><a href="/posts/dotnet-power-of-ten-rules/#rule-9-restrict-pointer-use-max-one-level-of-dereferencing" title="Rule 9: Restrict Pointer Use (Max One Level of Dereferencing)">Rule 9: Restrict Pointer Use (Max One Level of Dereferencing)</a></h2><p><strong>Original Intent:</strong> Prevent complex pointer arithmetic and double-pointer confusion.</p><p><strong>C#/.NET Applicability:</strong> Mostly irrelevant: managed code eliminates most pointer usage.</p><h3 id="the-net-alternative-references-are-not-pointers"><a href="/posts/dotnet-power-of-ten-rules/#the-net-alternative-references-are-not-pointers" title="The .NET Alternative: References Are Not Pointers">The .NET Alternative: References Are Not Pointers</a></h3><p>In managed C#, you work with references, not pointers:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="c1">// Safe by default - no pointer arithmetic</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">class</span> <span class="nc">Customer</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">string</span> <span class="n">Name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Reference semantics, but no pointer manipulation</span>
</span></span><span class="line"><span class="cl"><span class="n">Customer</span> <span class="n">customer</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Customer</span> <span class="p">{</span> <span class="n">Name</span> <span class="p">=</span> <span class="s">&#34;John&#34;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">Customer</span> <span class="n">same</span> <span class="p">=</span> <span class="n">customer</span><span class="p">;</span>  <span class="c1">// same reference, not a copy</span>
</span></span><span class="line"><span class="cl"><span class="n">same</span><span class="p">.</span><span class="n">Name</span> <span class="p">=</span> <span class="s">&#34;Jane&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">customer</span><span class="p">.</span><span class="n">Name</span><span class="p">);</span>  <span class="c1">// Outputs: Jane</span>
</span></span></code></pre></div><h3 id="unsafe-code-when-you-actually-need-pointers"><a href="/posts/dotnet-power-of-ten-rules/#unsafe-code-when-you-actually-need-pointers" title="Unsafe Code: When You Actually Need Pointers">Unsafe Code: When You Actually Need Pointers</a></h3><p>Rare, but sometimes unavoidable for interop or extreme performance:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="c1">// Performance-critical unsafe code - use sparingly</span>
</span></span><span class="line"><span class="cl"><span class="kd">unsafe</span> <span class="k">void</span> <span class="n">ProcessBuffer</span><span class="p">(</span><span class="kt">byte</span><span class="p">[]</span> <span class="n">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">fixed</span> <span class="p">(</span><span class="kt">byte</span><span class="p">*</span> <span class="n">ptr</span> <span class="p">=</span> <span class="n">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// One level of indirection - NASA would approve</span>
</span></span><span class="line"><span class="cl">        <span class="kt">byte</span><span class="p">*</span> <span class="n">current</span> <span class="p">=</span> <span class="n">ptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">data</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="p">*</span><span class="n">current</span> <span class="p">=</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)(*</span><span class="n">current</span> <span class="p">*</span> <span class="m">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">current</span><span class="p">++;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="modern-safe-alternative-span"><a href="/posts/dotnet-power-of-ten-rules/#modern-safe-alternative-span" title="Modern Safe Alternative: Span">Modern Safe Alternative: Span<t></a></h3><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="c1">// Safe, zero-allocation, pointer-like performance</span>
</span></span><span class="line"><span class="cl"><span class="k">void</span> <span class="n">ProcessBuffer</span><span class="p">(</span><span class="n">Span</span><span class="p">&lt;</span><span class="kt">byte</span><span class="p">&gt;</span> <span class="n">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">data</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">*</span> <span class="m">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Or even better:</span>
</span></span><span class="line"><span class="cl"><span class="k">void</span> <span class="n">ProcessBuffer</span><span class="p">(</span><span class="n">Span</span><span class="p">&lt;</span><span class="kt">byte</span><span class="p">&gt;</span> <span class="n">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">foreach</span> <span class="p">(</span><span class="k">ref</span> <span class="kt">byte</span> <span class="k">value</span> <span class="k">in</span> <span class="n">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">value</span> <span class="p">=</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)(</span><span class="k">value</span> <span class="p">*</span> <span class="m">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="refinout-managed-pointer-like-semantics"><a href="/posts/dotnet-power-of-ten-rules/#refinout-managed-pointer-like-semantics" title="ref/in/out: Managed &ldquo;Pointer-Like&rdquo; Semantics">ref/in/out: Managed &ldquo;Pointer-Like&rdquo; Semantics</a></h3><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="c1">// Pass by reference without pointers</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">void</span> <span class="n">UpdateCustomer</span><span class="p">(</span><span class="k">ref</span> <span class="n">Customer</span> <span class="n">customer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">customer</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Customer</span> <span class="p">{</span> <span class="n">Name</span> <span class="p">=</span> <span class="s">&#34;Updated&#34;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Read-only reference (no copying large structs)</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kt">decimal</span> <span class="n">CalculateTotal</span><span class="p">(</span><span class="k">in</span> <span class="n">LargeStruct</span> <span class="n">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">data</span><span class="p">.</span><span class="n">Value1</span> <span class="p">+</span> <span class="n">data</span><span class="p">.</span><span class="n">Value2</span><span class="p">;</span>  <span class="c1">// No defensive copy</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Output parameter</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kt">bool</span> <span class="n">TryGetCustomer</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="k">out</span> <span class="n">Customer</span> <span class="n">customer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>Verdict:</strong> You rarely need unsafe code in modern C#. Use <code>Span&lt;T></code>/<code>Memory&lt;T></code> for performance-critical buffer manipulation. Use <code>ref</code>/<code>in</code>/<code>out</code> for reference semantics. Reserve <code>unsafe</code> for true interop scenarios.</p><h2 id="rule-10-enable-all-compiler-warnings-and-use-static-analysis"><a href="/posts/dotnet-power-of-ten-rules/#rule-10-enable-all-compiler-warnings-and-use-static-analysis" title="Rule 10: Enable All Compiler Warnings and Use Static Analysis">Rule 10: Enable All Compiler Warnings and Use Static Analysis</a></h2><p><strong>Original Intent:</strong> Catch bugs early through automated checking.</p><p><strong>C#/.NET Applicability:</strong> Not just valid: vastly more powerful than 2006 C tooling.</p><h3 id="modern-tooling-is-incomparably-better"><a href="/posts/dotnet-power-of-ten-rules/#modern-tooling-is-incomparably-better" title="Modern Tooling Is Incomparably Better">Modern Tooling Is Incomparably Better</a></h3><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="c">&lt;!-- Essential .csproj settings --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;PropertyGroup&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="c">&lt;!-- Treat all warnings as errors --&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;TreatWarningsAsErrors&gt;</span>true<span class="nt">&lt;/TreatWarningsAsErrors&gt;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c">&lt;!-- Enable nullable reference types --&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;Nullable&gt;</span>enable<span class="nt">&lt;/Nullable&gt;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c">&lt;!-- Enable latest code analysis --&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;AnalysisLevel&gt;</span>latest<span class="nt">&lt;/AnalysisLevel&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;EnforceCodeStyleInBuild&gt;</span>true<span class="nt">&lt;/EnforceCodeStyleInBuild&gt;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c">&lt;!-- Enable specific analyzer categories --&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;AnalysisMode&gt;</span>All<span class="nt">&lt;/AnalysisMode&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/PropertyGroup&gt;</span>
</span></span></code></pre></div><h3 id="roslyn-analyzers-static-analysis-built-in"><a href="/posts/dotnet-power-of-ten-rules/#roslyn-analyzers-static-analysis-built-in" title="Roslyn Analyzers: Static Analysis Built In">Roslyn Analyzers: Static Analysis Built In</a></h3><p>Unlike 2006 C compilers, <a href="https://learn.microsoft.com/en-us/visualstudio/code-quality/roslyn-analyzers-overview" target="_blank" rel="noopener external noreferrer">Roslyn analyzers</a> provide deep semantic analysis. Rules like <a href="https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/quality-rules/ca2000" target="_blank" rel="noopener external noreferrer">CA2000</a> catch undisposed resources, <a href="https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/quality-rules/ca1806" target="_blank" rel="noopener external noreferrer">CA1806</a> flags ignored return values, and <a href="https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/quality-rules/ca1062" target="_blank" rel="noopener external noreferrer">CA1062</a> enforces parameter validation: all without running your code. This compile-time safety net would have been science fiction to NASA&rsquo;s 2006 C developers.</p><h3 id="editorconfig-for-team-standards"><a href="/posts/dotnet-power-of-ten-rules/#editorconfig-for-team-standards" title="EditorConfig for Team Standards">EditorConfig for Team Standards</a></h3><p><a href="https://editorconfig.org/" target="_blank" rel="noopener external noreferrer">EditorConfig files</a> let you enforce code style and quality rules across your team. Beyond basic formatting, you can control diagnostic severity for specific analyzer rules: turning <a href="https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/quality-rules/ca1062" target="_blank" rel="noopener external noreferrer">CA1062</a> (validate arguments) into build errors while suppressing overly strict rules like <a href="https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/quality-rules/ca1303" target="_blank" rel="noopener external noreferrer">CA1303</a> (localized strings). This ensures consistent standards without lengthy code review discussions about style preferences.</p><h3 id="multiple-layers-of-analysis"><a href="/posts/dotnet-power-of-ten-rules/#multiple-layers-of-analysis" title="Multiple Layers of Analysis">Multiple Layers of Analysis</a></h3><p>Modern .NET provides defense in depth: compiler warnings catch syntax issues, <a href="https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/overview" target="_blank" rel="noopener external noreferrer">Roslyn analyzers</a> enforce code quality (<a href="https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/quality-rules/" target="_blank" rel="noopener external noreferrer">CA* rules</a>) and style (<a href="https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/style-rules/" target="_blank" rel="noopener external noreferrer">IDE* rules</a>). Extend this with third-party analyzers like <a href="https://security-code-scan.github.io/" target="_blank" rel="noopener external noreferrer">SecurityCodeScan</a> for security vulnerabilities, <a href="https://github.com/semihokur/AsyncFixer" target="_blank" rel="noopener external noreferrer">AsyncFixer</a> for async/await pitfalls, or <a href="https://github.com/microsoft/vs-threading/blob/main/doc/analyzers/index.md" target="_blank" rel="noopener external noreferrer">Microsoft.VisualStudio.Threading.Analyzers</a> for threading issues. For enterprise scenarios, <a href="https://www.sonarsource.com/products/sonarqube/" target="_blank" rel="noopener external noreferrer">SonarQube</a> and <a href="https://docs.github.com/en/code-security/code-scanning/introduction-to-code-scanning/about-code-scanning-with-codeql" target="_blank" rel="noopener external noreferrer">GitHub Advanced Security</a> with CodeQL provide continuous security scanning.</p><h3 id="automated-code-review"><a href="/posts/dotnet-power-of-ten-rules/#automated-code-review" title="Automated Code Review">Automated Code Review</a></h3><p>Integrate analysis into CI/CD pipelines with <a href="https://docs.github.com/en/actions" target="_blank" rel="noopener external noreferrer">GitHub Actions</a>, <a href="https://learn.microsoft.com/en-us/azure/devops/pipelines/" target="_blank" rel="noopener external noreferrer">Azure Pipelines</a>, or similar platforms. Configure builds to treat warnings as errors (<code>/p:TreatWarningsAsErrors=true</code>) so quality issues block merges automatically. This transforms static analysis from optional developer tooling into enforced team standards.</p><p><strong>Verdict:</strong> This is the one rule where C# developers have it absurdly better than 2006 C developers. I&rsquo;ve reviewed codebases where enabling <code>TreatWarningsAsErrors</code> found 47 bugs in 30 seconds—bugs that had been sitting there for months. Enable everything: compiler warnings, Roslyn analyzers, nullable reference types. Use <code>.editorconfig</code> to enforce team standards. Automate it in CI/CD so quality gates can&rsquo;t be ignored when the deadline looms. There&rsquo;s no excuse not to.</p><h2 id="summary-translation-guide"><a href="/posts/dotnet-power-of-ten-rules/#summary-translation-guide" title="Summary: Translation Guide">Summary: Translation Guide</a></h2><table class="striped"><thead><tr><th>Power of Ten Rule</th><th>C#/.NET Status</th><th>Modern Equivalent</th></tr></thead><tbody><tr><td>1. Simple control flow</td><td>Partially valid</td><td>Avoid <code>goto</code>; recursion OK with care</td></tr><tr><td>2. Bounded loops</td><td>Valid</td><td>Use <code>foreach</code>, LINQ <code>Take()</code>, <code>CancellationToken</code></td></tr><tr><td>3. No dynamic allocation</td><td>Not applicable</td><td>Minimize allocations with <code>Span&lt;T></code>, <a href="https://learn.microsoft.com/en-us/dotnet/api/system.buffers.arraypool-1" target="_blank" rel="noopener external noreferrer"><code>ArrayPool&lt;T></code></a></td></tr><tr><td>4. Max 60 lines per function</td><td><strong>Absolutely valid</strong></td><td>Enable <a href="https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/quality-rules/ca1505" target="_blank" rel="noopener external noreferrer">CA1505</a>, use local functions, extract methods</td></tr><tr><td>5. Two assertions per function</td><td>Valid principle</td><td><a href="https://learn.microsoft.com/en-us/dotnet/csharp/nullable-references" target="_blank" rel="noopener external noreferrer">Nullable types</a> + guard clauses + <a href="https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.debug.assert" target="_blank" rel="noopener external noreferrer"><code>Debug.Assert</code></a></td></tr><tr><td>6. Minimal variable scope</td><td><strong>Absolutely valid</strong></td><td>Pattern matching, using declarations, block scope</td></tr><tr><td>7. Check all returns</td><td><strong>Absolutely valid</strong></td><td>Validate parameters, handle exceptions, use <code>Try*</code> pattern</td></tr><tr><td>8. Limited preprocessor</td><td>Mostly irrelevant</td><td>C# preprocessor already constrained; use DI for config</td></tr><tr><td>9. Restrict pointers</td><td>Mostly irrelevant</td><td>Use <a href="https://learn.microsoft.com/en-us/dotnet/api/system.span-1" target="_blank" rel="noopener external noreferrer"><code>Span&lt;T></code></a>, <code>ref</code>/<code>in</code>/<code>out</code>; reserve <code>unsafe</code> for interop</td></tr><tr><td>10. All warnings + static analysis</td><td><strong>Emphatically valid</strong></td><td>Enable <a href="https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/overview" target="_blank" rel="noopener external noreferrer">all analyzers</a>, nullable types, treat warnings as errors</td></tr></tbody></table><h2 id="the-verdict-timeless-principles-modern-implementation"><a href="/posts/dotnet-power-of-ten-rules/#the-verdict-timeless-principles-modern-implementation" title="The Verdict: Timeless Principles, Modern Implementation">The Verdict: Timeless Principles, Modern Implementation</a></h2><p>Four rules (4, 6, 7, and 10) transfer directly with superior tooling. Function length limits, minimal scope, return value checking, static analysis—all work better in 2025 than 2006 C. Three rules (3, 8, 9) become largely irrelevant because .NET&rsquo;s managed runtime provides better abstractions than manual memory management or preprocessor macros. The remaining rules (1, 2, 5) require contextual interpretation. Their principles remain sound, but modern C#&rsquo;s language features and runtime safety nets fundamentally change implementation.</p><p>Gerard Holzmann&rsquo;s rules weren&rsquo;t about C syntax. They encoded deeper principles—predictability, analyzability, defensive programming—that transcend any specific language. What&rsquo;s different in 2025? Modern C# gives you powerful tools to enforce these principles without bare-metal constraints. <a href="https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/overview" target="_blank" rel="noopener external noreferrer">Roslyn analyzers</a> catch bugs at compile time that required runtime assertions in embedded C. <a href="https://learn.microsoft.com/en-us/dotnet/csharp/nullable-references" target="_blank" rel="noopener external noreferrer">Nullable reference types</a> prevent null dereferences before code runs. <a href="https://learn.microsoft.com/en-us/dotnet/api/system.span-1" target="_blank" rel="noopener external noreferrer"><code>Span&lt;T></code></a> delivers pointer-like performance with array-like safety.</p><p>For safety-critical C# code—medical devices, financial systems, industrial control—absolutely adopt these principles. Enable every analyzer. Enforce short functions. Validate everything. Treat warnings as errors. But don&rsquo;t cargo-cult embedded C constraints just because NASA used them. Embrace the GC when it makes sense, use modern abstractions that eliminate entire bug categories, and let the type system catch errors at compile time instead of in production. Your code will be safer, more maintainable, and more correct. Which is what Gerard Holzmann wanted all along.</p></section><h2>Comments</h2><aside class="giscus"></aside><script src="https://giscus.app/client.js" data-repo="dailydevops/dailydevops.github.io" data-repo-id="R_kgDOHA8eFg" data-category="Announcements" data-category-id="DIC_kwDOHA8eFs4COIqL" data-mapping="pathname" data-strict="1" data-reactions-enabled="0" data-emit-metadata="0" data-input-position="bottom" data-theme="light" data-lang="en" crossorigin="anonymous" async></script></article><aside class="sidebar divider"><section class="sidecar info"><ul><li><time datetime="2025-12-10T16:45:00+01:00">Published on 12/10/25 4:45 pm</time></li><li>Read in 19 minutes</li></ul></section><section class="sidecar series"><header><h2>Series content</h2></header><a href="https://daily-devops.net/posts/dotnet-10-released/" title=".NET 10: Boring by Design, Reliable by Default
" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right"></i>&nbsp;
.NET 10: Boring by Design, Reliable by Default
</a><a href="https://daily-devops.net/posts/dotnet-10-testing/" title=".NET 10 Testing: Microsoft Finally Fixed the Test Runner (Mostly)
" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right"></i>&nbsp;
.NET 10 Testing: Microsoft Finally Fixed the Test Runner (Mostly)
</a><a href="https://daily-devops.net/posts/dotnet-power-of-ten-rules/" title="Power of Ten Rules: More Relevant Than Ever for .NET" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right"></i>&nbsp;
Power of Ten Rules: More Relevant Than Ever for .NET
</a><a href="https://daily-devops.net/posts/dotnet-10-cli-devops/" title=".NET CLI 10 – Microsoft Finally Realizes DevOps Exists" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right"></i>&nbsp;
.NET CLI 10 – Microsoft Finally Realizes DevOps Exists</a></section><section class="sidecar author"><header><h2><a href="/authors/martin/" rel="author" title="Martin Stühmer">Author Martin Stühmer</a></h2></header><figure class="round"><picture><img src="https://www.gravatar.com/avatar/6da4a47ff9cc2b750452225fdb2582f7?d=identicon&amp;s=200" alt="Martin Stühmer" loading="lazy" decoding="async" title="Martin Stühmer"></picture></figure><section class="content">Martin is a software architect and developer who has spent nearly two decades navigating the .NET ecosystem from Framework 2.0 to modern .NET 10. As Director Consulting Services at CGI and a Microsoft Certified Trainer, he specializes in cloud-native solutions, enterprise architecture, and Risk and Cost Driven Architecture (RCDA). His mission is straightforward - help teams build quality software that survives contact with production. He contributes to open-source communities through NuGet packages, writes about pragmatic software engineering on this blog, and trains developers who want substance over buzzwords.</section><a class="link" href="/authors/martin/" rel="author" title="Martin Stühmer"></a></section><section class="sidecar social"><header><h2>Social media</h2></header><a class="icon bluesky" href="https://bsky.app/profile/samtrion.net" rel="noopener external" title="Follow me on Bluesky" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-bluesky fa-stack-1x fa-inverse"></i>
</span></a><a class="icon github" href="https://github.com/samtrion" rel="noopener external" title="Follow me on GitHub" target="_blank"><i class="fa-brands fa-fw fa-github fa-2x"></i></a>
<a class="icon linkedin" href="https://www.linkedin.com/in/martin-stuehmer" rel="noopener external" title="Follow me on LinkedIn" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-linkedin-in fa-stack-1x fa-inverse"></i>
</span></a><a class="icon stackoverflow" href="https://stackoverflow.com/users/10574963" rel="noopener external" title="Follow me on Stack Overflow" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-stack-overflow fa-stack-1x fa-inverse"></i>
</span></a><a class="icon mail" href="mailto:martin@daily-devops.net" title="Contact me by e-mail" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
</span></a><a class="icon feed" href="/authors/martin/feed.rss" title="My RSS feed" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></section><section class="sidecar share"><header><h2>Share this content</h2></header><a class="icon linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fdaily-devops.net%2fposts%2fdotnet-power-of-ten-rules%2f&text=Power%20of%20Ten%20Rules%3a%20More%20Relevant%20Than%20Ever%20for%20.NET%20%26mdash%3b%20Daily%20DevOps%20%26%20.NET" target="_blank" rel="noopener external" aria-label="Share on LinkedIn" title="Share on LinkedIn" target="_blank"><i class="fa-brands fa-fw fa-linkedin-in fa-2x"></i></a>
<a class="icon bluesky" href="https://bsky.app/intent/compose?text=Power%20of%20Ten%20Rules%3a%20More%20Relevant%20Than%20Ever%20for%20.NET%20%26mdash%3b%20Daily%20DevOps%20%26%20.NET%20https%3a%2f%2fdaily-devops.net%2fposts%2fdotnet-power-of-ten-rules%2f" target="_blank" rel="noopener external" aria-label="Share on Bluesky" title="Share on Bluesky" target="_blank"><i class="fa-brands fa-fw fa-bluesky fa-2x"></i></a></section><section class="sidecar tags"><header><h2>Tags</h2></header><ul><li class="tag"><a href="/tags/dotnet/" hreflang="en" rel="tag" title=".NET"><i class="fas fa-tag"></i>&nbsp;.NET</a></li><li class="tag"><a href="/tags/bestpractices/" hreflang="en" rel="tag" title="Best Practices"><i class="fas fa-tag"></i>&nbsp;Best Practices</a></li><li class="tag"><a href="/tags/csharp/" hreflang="en" rel="tag" title="C#"><i class="fas fa-tag"></i>&nbsp;C#</a></li><li class="tag"><a href="/tags/codequality/" hreflang="en" rel="tag" title="Code Quality"><i class="fas fa-tag"></i>&nbsp;Code Quality</a></li><li class="tag"><a href="/tags/softwareengineering/" hreflang="en" rel="tag" title="Software Engineering"><i class="fas fa-tag"></i>&nbsp;Software Engineering</a></li></ul></section><section class="sidecar links"><header><h2>Additional links</h2></header><a href="https://spinroot.com/gerard/pdf/P10.pdf" title="Gerard Holzmann&rsquo;s “Power of Ten”" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right"></i>&nbsp;
Gerard Holzmann&rsquo;s “Power of Ten”</a></section><section class="sidecar related"><header><h2>Related content</h2></header><article class="post"><figure class="square"><picture><source srcset="/images/csharp-80x80.webp?v=0f7110ee2851196f14d99463a855759d" type="image/webp"><source srcset="/images/csharp-80x80.png?v=c5d685b0d4fa9ec69bd959ee04beb903" type="image/png"><img src="/images/csharp.png?v=21ff9dcf5d1da7bfa80141c972c117da" alt="Code Metrics and Configuration: Beyond the Numbers Game" loading="lazy" decoding="async" title="Code Metrics and Configuration: Beyond the Numbers Game"></picture></figure><header><h2><a href="/posts/code-metrics-configuration/" rel="bookmark">Code Metrics and Configuration: Beyond the Numbers Game</a></h2></header><section class="content"><p>Code metrics have become a standard feature in modern development environments, yet their implementation and interpretation often leave much to be desired. While Visual Studio and .NET provide comprehensive code metrics analysis, the way these metrics are configured, presented, and (more critically) acted upon reveals a fundamental disconnect between measurement and meaningful improvement.</p><p>What code metrics actually measure, how to configure them properly, and (more importantly) why blindly following thresholds without understanding context is, frankly, a recipe for misguided refactoring efforts that waste your team&rsquo;s time and actively damage your codebase.</p></section></article><article class="post"><figure class="square"><picture><source srcset="/images/technical-debt-80x80.webp?v=d4b6750fc74794c27703f1eaa447efe7" type="image/webp"><source srcset="/images/technical-debt-80x80.png?v=89bb5046cc0b986270c06c1c4de9e797" type="image/png"><img src="/images/technical-debt.png?v=67ddb8f47e467b6ae8d570696cc5f79d" alt="Clean Code: A Lip Service, Not a Standard
" loading="lazy" decoding="async" title="Clean Code: A Lip Service, Not a Standard
"></picture></figure><header><h2><a href="/posts/clean-code-lip-service-not-a-standard/" rel="bookmark">Clean Code: A Lip Service, Not a Standard</a></h2></header><section class="content">Clean Code is often praised but rarely practiced effectively. This article explores how misunderstood ideals and over-engineering harm .NET systems, how to recognize such failures early, and which C# best practices and official guidelines truly support maintainable software.</section></article><article class="post"><figure class="square"><picture><source srcset="/images/dotnet-80x80.webp?v=1d4b2dd465d7c025d943b4468cbf1985" type="image/webp"><source srcset="/images/dotnet-80x80.png?v=98376a285f07b0021d3118e0523d147a" type="image/png"><img src="/images/dotnet.png?v=8142ec8a038ba14415ff0d0434c78182" alt="Buzzword-Driven Development vs. Fundamental Software Quality" loading="lazy" decoding="async" title="Buzzword-Driven Development vs. Fundamental Software Quality"></picture></figure><header><h2><a href="/posts/buzzword-driven-development/" rel="bookmark">Buzzword-Driven Development vs. Fundamental Software Quality</a></h2></header><section class="content">Explore why fundamental software quality practices in .NET must never be overlooked for trendy buzzwords, including recommended analyzers and project settings for managing technical debt effectively.</section></article></section></aside><nav class="pager"><a class="next" href="/posts/dotnet-job-scheduling-6-tickerq/" title=".NET Job Scheduling — TickerQ and Modern Architecture" rel="next"><span class="sub"><i class="fas fa-backward"></i>&emsp;Next</span><p class="title">.NET Job Scheduling — TickerQ and Modern Architecture</p></a><a class="prev" href="/posts/aks-network-policies-zero-trust/" title="AKS Network Policies: The Security Layer Your Cluster Is Missing" rel="prev"><span class="sub">Previous&emsp;<i class="fas fa-forward"></i></span><p class="title">AKS Network Policies: The Security Layer Your Cluster Is Missing</p></a></nav></main><footer class="footer"><div class="divider"></div><nav><ul class="navigation"><li><a href="/tags/">Tags</a></li><li><a href="/legal-notice/">Legal notice</a></li></ul></nav><div class="copyright">&copy; 2023 - 2026 Daily DevOps & .NET</div></footer><script defer src="/js/below.min.a6ce9164454b6077f17ae856f280442d9f3a1e21f06189f71c21f75144b22a0c8cf32bafd61d440e9d90ca02bf738b6a8ef19f5ec20285d8ca574f98c91ebaf2.js" integrity="sha512-ps6RZEVLYHfxeuhW8oBELZ86HiHwYYn3HCH3UUSyKgyM8yuv1h1EDp2QygK/c4tqjvGfXsIChdjKV0+YyR668g==" crossorigin="anonymous"></script><img class="vgwort" src="https://vg06.met.vgwort.de/na/ce95cd43e3184142bc4439577f14a252" width="1" height="1" alt="VG Wort" title="VG Wort"></body></html>