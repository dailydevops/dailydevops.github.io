<!doctype html><html class="no-js" lang="en" dir="ltr"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="theme-color" content="#15a"><title>Stop Parsing the Same String Twice: CompositeFormat in .NET — Daily DevOps & .NET</title><meta name="description" content="Every time you call string.Format() with the same format string, .NET parses it again. And again. And again. CompositeFormat changes that: parse …"><meta name="twitter:description" property="og:description" content="Every time you call string.Format() with the same format string, .NET parses it again. And again. And again. CompositeFormat changes that: parse …"><meta name="author" content="Martin Stühmer"><link rel="icon" href="/logo.svg?v=b9e294dc5c6fa04439c8c803d8e981a9" sizes="any" type="image/svg+xml"><meta name="twitter:title" property="og:title" content="Stop Parsing the Same String Twice: CompositeFormat in .NET — Daily DevOps & .NET"><meta property="og:updated_time" content="2025-11-11T00:40:32+01:00"><meta property="article:modified_time" content="2025-11-11T00:40:32+01:00"><meta property="article:published_time" content="2025-10-23T17:00:00+02:00"><meta property="og:type" content="article"><meta property="og:site_name" content="Daily DevOps & .NET"><meta property="og:url" content="https://daily-devops.net/posts/compositeformat-performance-boost/"><meta property="og:locale" content="en_US"><meta name="twitter:card" content="summary_large_image"><meta property="og:image" name="twitter:image" content="https://daily-devops.net/images/csharp-1200x630.webp?v=fc7f536d0ab1066147edde28d3d7c9f2"><meta property="og:image:secure_url" content="https://daily-devops.net/images/csharp-1200x630.webp?v=fc7f536d0ab1066147edde28d3d7c9f2"><meta property="og:image:alt" name="twitter:image:alt" content="Stop Parsing the Same String Twice: CompositeFormat in .NET"><meta property="og:image:type" content="image/webp"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta property="og:image" name="twitter:image" content="https://daily-devops.net/images/csharp-1200x630.png?v=547760eed18b566792e92844110e5c96"><meta property="og:image:secure_url" content="https://daily-devops.net/images/csharp-1200x630.png?v=547760eed18b566792e92844110e5c96"><meta property="og:image:alt" name="twitter:image:alt" content="Stop Parsing the Same String Twice: CompositeFormat in .NET"><meta property="og:image:type" content="image/png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><link rel="dns-prefetch" href="https://www.clarity.ms"><link rel="preconnect" href="https://www.clarity.ms" crossorigin><link rel="stylesheet" href="/css/style.min.0b2ef4378cd908eb695017aaa74603d244ff2b38c8068b4b51d76cad830c8ee5e3a40b67ab5b860a542c8bae73d8ba90cfbe9249b59c733a50de74cc32af818a.css" integrity="sha512-Cy70N4zZCOtpUBeqp0YD0kT/KzjIBotLUddsrYMMjuXjpAtnq1uGClQsi65z2LqQz76SSbWcczpQ3nTMMq+Big==" crossorigin="anonymous"><link rel="alternate" href='https://daily-devops.net/posts/compositeformat-performance-boost/' hreflang="x-default" title="Stop Parsing the Same String Twice: CompositeFormat in .NET &mdash; Daily DevOps & .NET"><link rel="canonical" href="https://daily-devops.net/posts/compositeformat-performance-boost/" hreflang="en-us" title="Stop Parsing the Same String Twice: CompositeFormat in .NET &mdash; Daily DevOps & .NET"><link rel="home" href="https://daily-devops.net/" hreflang="en-us" title="Daily DevOps & .NET"><link rel="next" href="https://daily-devops.net/posts/netevolve-healthchecks/" hreflang="en-us" title="Configuration-First Health Checks for Modern .NET"><link rel="prev" href="https://daily-devops.net/posts/searchvalues-saved-us-from-scaling-hell/" hreflang="en-us" title="How SearchValues<T> Saved Us From Scaling Hell"><link rel="author" href="https://daily-devops.net/authors/martin/" hreflang="en-us" title="Martin Stühmer &mdash; Daily DevOps & .NET"><meta name="giscus:backlink" content="https://daily-devops.net/posts/compositeformat-performance-boost/"><script defer src="/js/above.min.cb42b2c9a453e49e278326637d72d2f01e7f32e3f91e9cdde8fb587793d05514efd2f5cc5021c9658ca0f73876dbdcd1f7cb4a37c0bebc9df01110926b6d7cba.js" integrity="sha512-y0KyyaRT5J4ngyZjfXLS8B5/MuP5Hpzd6PtYd5PQVRTv0vXMUCHJZYyg9zh229zR98tKN8C+vJ3wERCSa218ug==" crossorigin="anonymous"></script><script type="text/javascript">(function(e,t,n,s,o,i,a){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)},i=t.createElement(s),i.async=1,i.src="https://www.clarity.ms/tag/"+o,a=t.getElementsByTagName(s)[0],a.parentNode.insertBefore(i,a)})(window,document,"clarity","script","o0pr4n9gg3")</script></head><body class="container"><header class="header"><a class="logo" href="/" title="Daily DevOps & .NET" rel="home"><figure class="page-logo"><picture><img src="/logo.svg?v=b9e294dc5c6fa04439c8c803d8e981a9" alt="Daily DevOps & .NET" title="Daily DevOps & .NET"></picture></figure><span class="title">Daily DevOps & .NET</span></a><nav class="menu"><button class="burger" aria-haspopup="true" aria-expanded="false" tabindex="0">
<i class="fas fa-burger"></i></button><ul class="navigation"><li class="active"><a href="/posts/">Posts</a></li><li><a href="/authors/">About us</a></li></ul></nav><div class="divider"></div></header><main class="body"><figure class="hero"><picture><source srcset="/images/csharp-544x136.webp?v=e5f5a99e0e8a1378e60917fc901ddac6" type="image/webp" media="(max-width: 575.98px)"><source srcset="/images/csharp-544x136.png?v=038bf53dc3518576014653d5dda06a5e" type="image/png" media="(max-width: 575.98px)"><source srcset="/images/csharp-672x168.webp?v=878e0845de89143e2d988d3ccda245e7" type="image/webp" media="(max-width: 767.98px)"><source srcset="/images/csharp-672x168.png?v=a18b6001d35dd946ef8b9a47af6e86ed" type="image/png" media="(max-width: 767.98px)"><source srcset="/images/csharp-896x224.webp?v=d1ce45309167db27c2b3d026b3c6c0a1" type="image/webp" media="(max-width: 991.98px)"><source srcset="/images/csharp-896x224.png?v=7eb31dd18bd53b0bf209074e79eb8f2f" type="image/png" media="(max-width: 991.98px)"><source srcset="/images/csharp-1104x276.webp?v=c7160af5b84bca2787cf782c4d341229" type="image/webp" media="(max-width: 1199.98px)"><source srcset="/images/csharp-1104x276.png?v=b760a9ea4f05629aa6cd15bbdcdf9d16" type="image/png" media="(max-width: 1199.98px)"><source srcset="/images/csharp-1444x361.webp?v=0f4c3768d314f21695bf9d28bcc05f27" type="image/webp"><source srcset="/images/csharp-1444x361.png?v=e71fca8a8b32ef8c283bb0b4c8af95fb" type="image/png"><img src="/images/csharp.png?v=21ff9dcf5d1da7bfa80141c972c117da" alt="Stop Parsing the Same String Twice: CompositeFormat in .NET" loading="lazy" decoding="async" title="Stop Parsing the Same String Twice: CompositeFormat in .NET"></picture></figure><article class="post"><header><h1>Stop Parsing the Same String Twice: CompositeFormat in .NET</h1></header><section class="content"><p>String formatting is everywhere in .NET applications: logging, debugging, user messages, dynamic content. Methods like <a href="https://learn.microsoft.com/en-us/dotnet/api/system.string.format" target="_blank" rel="noopener external noreferrer"><code>string.Format</code></a> and interpolated strings are convenient, but they have a cost: <strong>parsing overhead</strong>.</p><p>Every time you call <code>string.Format()</code>, the runtime parses that format string to understand its structure, find placeholders, and figure out how to substitute values. When you use the same format string repeatedly (loops, logging, request handling), this parsing is pure waste. You&rsquo;re doing the same work over and over.</p><p>Enter <a href="https://learn.microsoft.com/en-us/dotnet/api/system.text.compositeformat" target="_blank" rel="noopener external noreferrer"><code>CompositeFormat</code></a>, introduced in .NET 8. Parse a format string (<strong>see</strong>: <a href="https://learn.microsoft.com/en-us/dotnet/standard/base-types/composite-formatting" target="_blank" rel="noopener external noreferrer">Composite formatting</a>) <strong>once</strong>, reuse it many times. No more repeated parsing, better performance. Simple concept, real impact.</p><h2 id="the-problem-repeated-parsing-overhead"><a href="/posts/compositeformat-performance-boost/#the-problem-repeated-parsing-overhead" title="The Problem: Repeated Parsing Overhead">The Problem: Repeated Parsing Overhead</a></h2><p>Consider a typical logging scenario:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">10000</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">string</span> <span class="n">message</span> <span class="p">=</span> <span class="kt">string</span><span class="p">.</span><span class="n">Format</span><span class="p">(</span><span class="s">&#34;Processing item {0} of {1}&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="m">10000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Log or use the message</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>In this example, the format string <code>"Processing item {0} of {1}"</code> gets parsed 10,000 times. Same string, 10,000 parses. Each parse scans for placeholders, extracts format specifiers, validates structure, builds an internal representation. In a high-throughput app (web server, batch processor, real-time system), this adds up fast.</p><h2 id="the-solution-compositeformat"><a href="/posts/compositeformat-performance-boost/#the-solution-compositeformat" title="The Solution: CompositeFormat">The Solution: CompositeFormat</a></h2><p><code>CompositeFormat</code> separates parsing from formatting:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="c1">// Parse the format string once</span>
</span></span><span class="line"><span class="cl"><span class="n">CompositeFormat</span> <span class="n">format</span> <span class="p">=</span> <span class="n">CompositeFormat</span><span class="p">.</span><span class="n">Parse</span><span class="p">(</span><span class="s">&#34;Processing item {0} of {1}&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">10000</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Reuse the parsed format many times</span>
</span></span><span class="line"><span class="cl">    <span class="kt">string</span> <span class="n">message</span> <span class="p">=</span> <span class="kt">string</span><span class="p">.</span><span class="n">Format</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="n">format</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="m">10000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Log or use the message</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Parse once, reuse the <code>CompositeFormat</code> instance. You just cut out 9,999 redundant operations.</p><h2 id="how-compositeformat-works"><a href="/posts/compositeformat-performance-boost/#how-compositeformat-works" title="How CompositeFormat Works">How CompositeFormat Works</a></h2><p>The internals are straightforward. <code>CompositeFormat</code> uses the same parsing logic as <code>string.Format()</code>, but stores the result for reuse.</p><p>When you call <code>CompositeFormat.Parse(string)</code>, the runtime scans the format string, validates it, and builds an internal representation (literal text + placeholders). That&rsquo;s it, done once. When you call <code>string.Format(IFormatProvider, CompositeFormat, ...)</code>, the runtime skips parsing entirely and just substitutes values.</p><p>The <code>CompositeFormat</code> instance is immutable and thread-safe, so you can reuse it anywhere, even across threads. Classic .NET philosophy: if you&rsquo;re doing the same thing repeatedly, don&rsquo;t pay the cost every time.</p><h2 id="performance-benchmarks-real-world-impact"><a href="/posts/compositeformat-performance-boost/#performance-benchmarks-real-world-impact" title="Performance Benchmarks: Real-World Impact">Performance Benchmarks: Real-World Impact</a></h2><p>Benchmarks from the .NET runtime team show 15-30% reduction in execution time for repeated formatting operations, fewer allocations, less GC pressure, higher throughput in logging-heavy workloads.</p><p>These gains matter in high-frequency scenarios: logging frameworks processing thousands of messages per second, request handlers, batch processing, telemetry systems.</p><p>Take a web API handling 50,000 requests per minute. Reduce formatting overhead by 20%, and you might handle 10,000 more requests on the same hardware. Lower CPU usage, lower latency. That&rsquo;s real money saved.</p><h2 id="when-to-use-compositeformat"><a href="/posts/compositeformat-performance-boost/#when-to-use-compositeformat" title="When to Use CompositeFormat">When to Use CompositeFormat</a></h2><p>Use <code>CompositeFormat</code> when the same format string gets used repeatedly: loops, hot paths, frequently called methods. It makes sense when performance matters (CPU-bound operations, latency reduction, high-throughput systems) and when you control the format string at compile time.</p><p>High-frequency logging is perfect for this. Parse once, reuse across thousands of log calls. Request/response handling, batch processing, performance-critical libraries—all good candidates.</p><p>Don&rsquo;t use it for one-off formatting. Creating the <code>CompositeFormat</code> instance costs more than you save. Skip it for dynamic format strings that change at runtime. And for simple interpolated strings, just use <code>$"..."</code>. Readability matters.</p><h2 id="usage-examples"><a href="/posts/compositeformat-performance-boost/#usage-examples" title="Usage Examples">Usage Examples</a></h2><h3 id="basic-pattern"><a href="/posts/compositeformat-performance-boost/#basic-pattern" title="Basic Pattern">Basic Pattern</a></h3><p>Parse your format string once with <code>CompositeFormat.Parse()</code>, store it as <code>static readonly</code>, reuse it:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="c1">// Parse format string once</span>
</span></span><span class="line"><span class="cl"><span class="kd">private</span> <span class="kd">static</span> <span class="k">readonly</span> <span class="n">CompositeFormat</span> <span class="n">LogFormat</span> <span class="p">=</span> 
</span></span><span class="line"><span class="cl">    <span class="n">CompositeFormat</span><span class="p">.</span><span class="n">Parse</span><span class="p">(</span><span class="s">&#34;User {0} logged in at {1:yyyy-MM-dd HH:mm:ss}&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Reuse many times</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">userId</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span> <span class="n">userId</span> <span class="p">&lt;=</span> <span class="m">1000</span><span class="p">;</span> <span class="n">userId</span><span class="p">++)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">string</span> <span class="n">message</span> <span class="p">=</span> <span class="kt">string</span><span class="p">.</span><span class="n">Format</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="n">LogFormat</span><span class="p">,</span> <span class="n">userId</span><span class="p">,</span> <span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="integration-pattern"><a href="/posts/compositeformat-performance-boost/#integration-pattern" title="Integration Pattern">Integration Pattern</a></h3><p>For larger apps, put all your format templates in one place:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="k">class</span> <span class="nc">MessageFormats</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="k">readonly</span> <span class="n">CompositeFormat</span> <span class="n">ErrorFormat</span> <span class="p">=</span> 
</span></span><span class="line"><span class="cl">        <span class="n">CompositeFormat</span><span class="p">.</span><span class="n">Parse</span><span class="p">(</span><span class="s">&#34;Error: {0} occurred at {1}&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="k">readonly</span> <span class="n">CompositeFormat</span> <span class="n">SuccessFormat</span> <span class="p">=</span> 
</span></span><span class="line"><span class="cl">        <span class="n">CompositeFormat</span><span class="p">.</span><span class="n">Parse</span><span class="p">(</span><span class="s">&#34;Success: Operation {0} completed with result {1}&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Usage across your application</span>
</span></span><span class="line"><span class="cl"><span class="kt">string</span> <span class="n">errorMessage</span> <span class="p">=</span> <span class="kt">string</span><span class="p">.</span><span class="n">Format</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="n">MessageFormats</span><span class="p">.</span><span class="n">ErrorFormat</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">    <span class="n">exception</span><span class="p">.</span><span class="n">Message</span><span class="p">,</span> <span class="n">DateTime</span><span class="p">.</span><span class="n">UtcNow</span><span class="p">);</span>
</span></span></code></pre></div><p>Works well with dependency injection, keeps formatting consistent across your app.</p><h2 id="integration-with-existing-code"><a href="/posts/compositeformat-performance-boost/#integration-with-existing-code" title="Integration with Existing Code">Integration with Existing Code</a></h2><p>You don&rsquo;t need to rewrite everything. Profile your code (dotTrace, <a href="https://github.com/microsoft/perfview" target="_blank" rel="noopener external noreferrer">PerfView</a>), find the hot format strings, extract them to <code>static readonly</code> fields, swap the method calls. Benchmark before and after.</p><p>Migration is usually just extracting a string literal and changing a method call. Small change, real impact.</p><h2 id="best-practices"><a href="/posts/compositeformat-performance-boost/#best-practices" title="Best Practices">Best Practices</a></h2><p>Cache instances as <code>static readonly</code> fields. Focus on hot paths: loops, high-frequency methods, performance-critical code. Benchmark with BenchmarkDotNet. Keep format strings simple. Thread-safe by default. Combine with <code>StringBuilder</code> when building complex strings.</p><h2 id="the-bigger-picture"><a href="/posts/compositeformat-performance-boost/#the-bigger-picture" title="The Bigger Picture">The Bigger Picture</a></h2><p><code>CompositeFormat</code> fits into .NET&rsquo;s broader push for zero-cost abstractions. <code>Span&lt;T></code> and <code>Memory&lt;T></code> for zero-allocation slicing. <code>ArrayPool&lt;T></code> for object pooling. <code>ValueTask&lt;T></code> for allocation-free async. Source generators for compile-time code generation. Native AOT for faster startup.</p><p>The pattern is consistent: control over performance without sacrificing usability. Opt-in when you need it, invisible when you don&rsquo;t.</p><h2 id="evolution-across-net-versions"><a href="/posts/compositeformat-performance-boost/#evolution-across-net-versions" title="Evolution Across .NET Versions">Evolution Across .NET Versions</a></h2><p><code>CompositeFormat</code> landed in .NET 8. Each release since has made it better.</p><p><strong>.NET 9</strong> optimized internals. Same API, faster formatting engine. Fewer allocations, especially with many placeholders. Less GC pressure.</p><p><strong>.NET 10</strong> improved JIT compiler understanding. More aggressive inlining for repeated formatting. Better interop with <code>Span&lt;char></code> and <code>Memory&lt;char></code> for allocation-free scenarios.</p><p>Upgrading from .NET 6 or 7 to .NET 8+ gets you <code>CompositeFormat</code> plus a faster runtime overall.</p><h2 id="conclusion"><a href="/posts/compositeformat-performance-boost/#conclusion" title="Conclusion">Conclusion</a></h2><p><code>CompositeFormat</code> is small but effective. Parse once, format many times. Less CPU, fewer allocations, better throughput.</p><p>The gains are real: logging, request handling, batch processing all benefit. It&rsquo;s opt-in, so adopt it incrementally without breaking existing code.</p><p>Profile your hot paths, find repeated formatting, switch to <code>CompositeFormat</code>.</p><blockquote><p>Simple change, <strong>measurable results.</strong></p></blockquote></section><h2>Comments</h2><aside class="giscus"></aside><script src="https://giscus.app/client.js" data-repo="dailydevops/dailydevops.github.io" data-repo-id="R_kgDOHA8eFg" data-category="Announcements" data-category-id="DIC_kwDOHA8eFs4COIqL" data-mapping="pathname" data-strict="1" data-reactions-enabled="0" data-emit-metadata="0" data-input-position="bottom" data-theme="light" data-lang="en" crossorigin="anonymous" async></script></article><aside class="sidebar divider"><section class="sidecar info"><ul><li><time datetime="2025-10-23T17:00:00+02:00">Published on 10/23/25 5:00 pm</time></li><li>Read in 5 minutes</li></ul></section><section class="sidecar author"><header><h2><a href="/authors/martin/" rel="author" title="Martin Stühmer">Author Martin Stühmer</a></h2></header><figure class="round"><picture><img src="https://www.gravatar.com/avatar/6da4a47ff9cc2b750452225fdb2582f7?d=identicon&amp;s=200" alt="Martin Stühmer" loading="lazy" decoding="async" title="Martin Stühmer"></picture></figure><section class="content">Martin is a software architect and developer who has spent nearly two decades navigating the .NET ecosystem from Framework 2.0 to modern .NET 10. As Director Consulting Services at CGI and a Microsoft Certified Trainer, he specializes in cloud-native solutions, enterprise architecture, and Risk and Cost Driven Architecture (RCDA). His mission is straightforward - help teams build quality software that survives contact with production. He contributes to open-source communities through NuGet packages, writes about pragmatic software engineering on this blog, and trains developers who want substance over buzzwords.</section><a class="link" href="/authors/martin/" rel="author" title="Martin Stühmer"></a></section><section class="sidecar social"><header><h2>Social media</h2></header><a class="icon bluesky" href="https://bsky.app/profile/samtrion.net" rel="noopener external" title="Follow me on Bluesky" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-bluesky fa-stack-1x fa-inverse"></i>
</span></a><a class="icon github" href="https://github.com/samtrion" rel="noopener external" title="Follow me on GitHub" target="_blank"><i class="fa-brands fa-fw fa-github fa-2x"></i></a>
<a class="icon linkedin" href="https://www.linkedin.com/in/martin-stuehmer" rel="noopener external" title="Follow me on LinkedIn" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-linkedin-in fa-stack-1x fa-inverse"></i>
</span></a><a class="icon stackoverflow" href="https://stackoverflow.com/users/10574963" rel="noopener external" title="Follow me on Stack Overflow" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-stack-overflow fa-stack-1x fa-inverse"></i>
</span></a><a class="icon mail" href="mailto:martin@daily-devops.net" title="Contact me by e-mail" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
</span></a><a class="icon feed" href="/authors/martin/feed.rss" title="My RSS feed" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></section><section class="sidecar share"><header><h2>Share this content</h2></header><a class="icon linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fdaily-devops.net%2fposts%2fcompositeformat-performance-boost%2f&text=Stop%20Parsing%20the%20Same%20String%20Twice%3a%20CompositeFormat%20in%20.NET%20%26mdash%3b%20Daily%20DevOps%20%26%20.NET" target="_blank" rel="noopener external" aria-label="Share on LinkedIn" title="Share on LinkedIn" target="_blank"><i class="fa-brands fa-fw fa-linkedin-in fa-2x"></i></a>
<a class="icon bluesky" href="https://bsky.app/intent/compose?text=Stop%20Parsing%20the%20Same%20String%20Twice%3a%20CompositeFormat%20in%20.NET%20%26mdash%3b%20Daily%20DevOps%20%26%20.NET%20https%3a%2f%2fdaily-devops.net%2fposts%2fcompositeformat-performance-boost%2f" target="_blank" rel="noopener external" aria-label="Share on Bluesky" title="Share on Bluesky" target="_blank"><i class="fa-brands fa-fw fa-bluesky fa-2x"></i></a></section><section class="sidecar tags"><header><h2>Tags</h2></header><ul><li class="tag"><a href="/tags/dotnet/" hreflang="en" rel="tag" title=".NET"><i class="fas fa-tag"></i>&nbsp;.NET</a></li><li class="tag"><a href="/tags/bestpractices/" hreflang="en" rel="tag" title="Best Practices"><i class="fas fa-tag"></i>&nbsp;Best Practices</a></li><li class="tag"><a href="/tags/csharp/" hreflang="en" rel="tag" title="C#"><i class="fas fa-tag"></i>&nbsp;C#</a></li><li class="tag"><a href="/tags/hidden-gems/" hreflang="en" rel="tag" title="Hidden Gems"><i class="fas fa-tag"></i>&nbsp;Hidden Gems</a></li><li class="tag"><a href="/tags/performance/" hreflang="en" rel="tag" title="Performance"><i class="fas fa-tag"></i>&nbsp;Performance</a></li><li class="tag"><a href="/tags/softwareengineering/" hreflang="en" rel="tag" title="Software Engineering"><i class="fas fa-tag"></i>&nbsp;Software Engineering</a></li></ul></section><section class="sidecar links"><header><h2>Additional links</h2></header><a href="https://learn.microsoft.com/en-us/dotnet/api/system.text.compositeformat" title="System.Text.CompositeFormat (Microsoft Docs)" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right"></i>&nbsp;
System.Text.CompositeFormat (Microsoft Docs)
</a><a href="https://learn.microsoft.com/en-us/dotnet/standard/base-types/composite-formatting" title="Composite formatting (.NET)" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right"></i>&nbsp;
Composite formatting (.NET)
</a><a href="https://learn.microsoft.com/en-us/dotnet/core/extensions/logging" title="Logging in .NET" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right"></i>&nbsp;
Logging in .NET
</a><a href="https://learn.microsoft.com/en-us/dotnet/core/deploying/native-aot" title="Native AOT (overview)" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right"></i>&nbsp;
Native AOT (overview)</a></section><section class="sidecar related"><header><h2>Related content</h2></header><article class="post"><figure class="square"><picture><source srcset="/images/csharp-80x80.webp?v=0f7110ee2851196f14d99463a855759d" type="image/webp"><source srcset="/images/csharp-80x80.png?v=c5d685b0d4fa9ec69bd959ee04beb903" type="image/png"><img src="/images/csharp.png?v=21ff9dcf5d1da7bfa80141c972c117da" alt="How SearchValues Saved Us From Scaling Hell" loading="lazy" decoding="async" title="How SearchValues Saved Us From Scaling Hell"></picture></figure><header><h2><a href="/posts/searchvalues-saved-us-from-scaling-hell/" rel="bookmark">How SearchValues<t> Saved Us From Scaling Hell</a></h2></header><section class="content"><p>While you&rsquo;re busy optimizing database queries and adding cache layers, thousands of string searches per second are quietly eating your CPU budget. The problem isn&rsquo;t visible in your APM dashboard because it&rsquo;s distributed across every request. But it&rsquo;s there. Compounding. Scaling linearly with load.</p><p>I discovered this the hard way when a log processing API started choking under production traffic. The bottleneck? String validation and sanitization. The fix? A .NET 8 feature that delivered a <strong>5x performance improvement</strong> and let us shut down servers instead of adding them. And it&rsquo;s gotten even better in .NET 9 and 10.</p></section></article><article class="post"><figure class="square"><picture><source srcset="/images/dotnet-80x80.webp?v=1d4b2dd465d7c025d943b4468cbf1985" type="image/webp"><source srcset="/images/dotnet-80x80.png?v=98376a285f07b0021d3118e0523d147a" type="image/png"><img src="/images/dotnet.png?v=8142ec8a038ba14415ff0d0434c78182" alt="ConstantExpectedAttribute: Unlocking Performance Through Compiler Awareness" loading="lazy" decoding="async" title="ConstantExpectedAttribute: Unlocking Performance Through Compiler Awareness"></picture></figure><header><h2><a href="/posts/constant-expected-attribute/" rel="bookmark">ConstantExpectedAttribute: Unlocking Performance Through Compiler Awareness</a></h2></header><section class="content">The ConstantExpectedAttribute, introduced in .NET 7, provides a powerful mechanism to signal compiler expectations about constant values. This enables better performance optimizations, enhanced IDE tooling, and clearer API contracts. Learn how to leverage this attribute to build more efficient and maintainable .NET applications.</section></article><article class="post"><figure class="square"><picture><source srcset="/images/vibecoding-80x80.webp?v=3f8c50e71c82a10bfe515499996ebab4" type="image/webp"><source srcset="/images/vibecoding-80x80.png?v=7617a55dbdf6bd7939238821b77c1a82" type="image/png"><img src="/images/vibecoding.png?v=9a36076d86533930bbd6319c257968b9" alt="Vibe Coding in .NET: Creative Catalyst or Maintenance Risk?" loading="lazy" decoding="async" title="Vibe Coding in .NET: Creative Catalyst or Maintenance Risk?"></picture></figure><header><h2><a href="/posts/vibe-coding-isnt-wrong-its-unfinished/" rel="bookmark">Vibe Coding in .NET: Creative Catalyst or Maintenance Risk?</a></h2></header><section class="content"><p>In the world of software development, there’s a recurring tension between <strong>discipline and improvisation</strong>. Somewhere along that spectrum lies a phenomenon increasingly referred to as <strong>Vibe Coding</strong>. The term evokes a style of development where engineers follow intuition and momentum rather than formal plans, processes, or design patterns.</p><p>It’s fast, fluid, and occasionally brilliant. But is it sustainable in a .NET-based enterprise context?</p></section></article></section></aside><nav class="pager"><a class="next" href="/posts/netevolve-healthchecks/" title="Configuration-First Health Checks for Modern .NET" rel="next"><span class="sub"><i class="fas fa-backward"></i>&emsp;Next</span><p class="title">Configuration-First Health Checks for Modern .NET</p></a><a class="prev" href="/posts/searchvalues-saved-us-from-scaling-hell/" title="How SearchValues Saved Us From Scaling Hell" rel="prev"><span class="sub">Previous&emsp;<i class="fas fa-forward"></i></span><p class="title">How SearchValues<t> Saved Us From Scaling Hell</p></a></nav></main><footer class="footer"><div class="divider"></div><nav><ul class="navigation"><li><a href="/tags/">Tags</a></li><li><a href="/legal-notice/">Legal notice</a></li></ul></nav><div class="copyright">&copy; 2023 - 2026 Daily DevOps & .NET</div></footer><script defer src="/js/below.min.a6ce9164454b6077f17ae856f280442d9f3a1e21f06189f71c21f75144b22a0c8cf32bafd61d440e9d90ca02bf738b6a8ef19f5ec20285d8ca574f98c91ebaf2.js" integrity="sha512-ps6RZEVLYHfxeuhW8oBELZ86HiHwYYn3HCH3UUSyKgyM8yuv1h1EDp2QygK/c4tqjvGfXsIChdjKV0+YyR668g==" crossorigin="anonymous"></script><img class="vgwort" src="https://vg06.met.vgwort.de/na/96db5b8dd62b417e99151e24e768b8dc" width="1" height="1" alt="VG Wort" title="VG Wort"></body></html>