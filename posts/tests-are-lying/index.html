<!doctype html><html class="no-js" lang="en" dir="ltr"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="theme-color" content="#15a"><title>Your Tests Are Lying — Mutation Testing in .NET — Daily DevOps & .NET</title><meta name="description" content="It begins like many stories in software: a well-intentioned developer joining a project, determined to do things properly. You arrive at a codebase that has …"><meta name="twitter:description" property="og:description" content="It begins like many stories in software: a well-intentioned developer joining a project, determined to do things properly. You arrive at a codebase that has …"><meta name="author" content="Martin Stühmer"><link rel="icon" href="/logo.svg?v=b9e294dc5c6fa04439c8c803d8e981a9" sizes="any" type="image/svg+xml"><meta name="twitter:title" property="og:title" content="Your Tests Are Lying — Mutation Testing in .NET — Daily DevOps & .NET"><meta property="og:updated_time" content="2025-11-10T23:32:11+01:00"><meta property="article:modified_time" content="2025-11-10T23:32:11+01:00"><meta property="article:published_time" content="2025-10-30T18:00:00+02:00"><meta property="og:type" content="article"><meta property="og:site_name" content="Daily DevOps & .NET"><meta property="og:url" content="https://daily-devops.net/posts/tests-are-lying/"><meta property="og:locale" content="en_US"><meta name="twitter:card" content="summary_large_image"><meta property="og:image" name="twitter:image" content="https://daily-devops.net/images/testing-1200x630.webp?v=11225a0943500976e3e5f7c2b677d757"><meta property="og:image:secure_url" content="https://daily-devops.net/images/testing-1200x630.webp?v=11225a0943500976e3e5f7c2b677d757"><meta property="og:image:alt" name="twitter:image:alt" content="Your Tests Are Lying — Mutation Testing in .NET"><meta property="og:image:type" content="image/webp"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta property="og:image" name="twitter:image" content="https://daily-devops.net/images/testing-1200x630.png?v=a28cd5249c70dee66af43d4bdcf5f51a"><meta property="og:image:secure_url" content="https://daily-devops.net/images/testing-1200x630.png?v=a28cd5249c70dee66af43d4bdcf5f51a"><meta property="og:image:alt" name="twitter:image:alt" content="Your Tests Are Lying — Mutation Testing in .NET"><meta property="og:image:type" content="image/png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><link rel="dns-prefetch" href="https://www.clarity.ms"><link rel="preconnect" href="https://www.clarity.ms" crossorigin><link rel="stylesheet" href="/css/style.min.5ccb118d2a61a152205e83121806e681df83c9be30dc661b5c2ac97f257aa206825d04398f912d6763f44f402cb983be17b797fa6f45bf2df44dcf69583f808a.css" integrity="sha512-XMsRjSphoVIgXoMSGAbmgd+Dyb4w3GYbXCrJfyV6ogaCXQQ5j5EtZ2P0T0AsuYO+F7eX+m9Fvy30Tc9pWD+Aig==" crossorigin="anonymous"><link rel="alternate" href='https://daily-devops.net/posts/tests-are-lying/' hreflang="x-default" title="Your Tests Are Lying — Mutation Testing in .NET &mdash; Daily DevOps & .NET"><link rel="canonical" href="https://daily-devops.net/posts/tests-are-lying/" hreflang="en-us" title="Your Tests Are Lying — Mutation Testing in .NET &mdash; Daily DevOps & .NET"><link rel="home" href="https://daily-devops.net/" hreflang="en-us" title="Daily DevOps & .NET"><link rel="next" href="https://daily-devops.net/posts/modern-defensive-programming/" hreflang="en-us" title="Modern Defensive Programming in .NET — Unified Throw-Helpers and Multi-Framework Compatibility"><link rel="prev" href="https://daily-devops.net/posts/nuget-packagedownload-functionality/" hreflang="en-us" title="PackageDownload: NuGet's Forgotten Power Tool
"><link rel="author" href="https://daily-devops.net/authors/martin/" hreflang="en-us" title="Martin Stühmer &mdash; Daily DevOps & .NET"><meta name="giscus:backlink" content="https://daily-devops.net/posts/tests-are-lying/"><script defer src="/js/above.min.cb42b2c9a453e49e278326637d72d2f01e7f32e3f91e9cdde8fb587793d05514efd2f5cc5021c9658ca0f73876dbdcd1f7cb4a37c0bebc9df01110926b6d7cba.js" integrity="sha512-y0KyyaRT5J4ngyZjfXLS8B5/MuP5Hpzd6PtYd5PQVRTv0vXMUCHJZYyg9zh229zR98tKN8C+vJ3wERCSa218ug==" crossorigin="anonymous"></script><script type="text/javascript">(function(e,t,n,s,o,i,a){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)},i=t.createElement(s),i.async=1,i.src="https://www.clarity.ms/tag/"+o,a=t.getElementsByTagName(s)[0],a.parentNode.insertBefore(i,a)})(window,document,"clarity","script","o0pr4n9gg3")</script></head><body class="container"><header class="header"><a class="logo" href="/" title="Daily DevOps & .NET" rel="home"><figure class="page-logo"><picture><img src="/logo.svg?v=b9e294dc5c6fa04439c8c803d8e981a9" alt="Daily DevOps & .NET" title="Daily DevOps & .NET"></picture></figure><span class="title">Daily DevOps & .NET</span></a><nav class="menu"><button class="burger" aria-haspopup="true" aria-expanded="false" tabindex="0">
<i class="fas fa-burger"></i></button><ul class="navigation"><li class="active"><a href="/posts/">Posts</a></li><li><a href="/authors/">About us</a></li></ul></nav><div class="divider"></div></header><main class="body"><figure class="hero"><picture><source srcset="/images/testing-544x136.webp?v=9e43172386ca3a1a7cb2ed1dedb92f71" type="image/webp" media="(max-width: 575.98px)"><source srcset="/images/testing-544x136.png?v=74049cc1fb40f4c2cd5e531ca64973b5" type="image/png" media="(max-width: 575.98px)"><source srcset="/images/testing-672x168.webp?v=0a4d1a600f529dbd7c54751db85dfb02" type="image/webp" media="(max-width: 767.98px)"><source srcset="/images/testing-672x168.png?v=fd265c0aeafc6176dc3a7f2450df4876" type="image/png" media="(max-width: 767.98px)"><source srcset="/images/testing-896x224.webp?v=a50ee127c49de14a7e6d7b6bbc3ef508" type="image/webp" media="(max-width: 991.98px)"><source srcset="/images/testing-896x224.png?v=b67e19722bc7192b893b7813d9efd5c8" type="image/png" media="(max-width: 991.98px)"><source srcset="/images/testing-1104x276.webp?v=431ee9e26c4e7350916b23cce330c1a7" type="image/webp" media="(max-width: 1199.98px)"><source srcset="/images/testing-1104x276.png?v=68df2a69058e5a6659c9ef0d7fd03526" type="image/png" media="(max-width: 1199.98px)"><source srcset="/images/testing-1444x361.webp?v=1d0993cf9fb3035df65de30b9de5a869" type="image/webp"><source srcset="/images/testing-1444x361.png?v=71658576413e8dd3a0d4efb1fe90beee" type="image/png"><img src="/images/testing.png?v=f76bce2e46f2702a98d85c6e3877291b" alt="Your Tests Are Lying — Mutation Testing in .NET" loading="lazy" decoding="async" title="Your Tests Are Lying — Mutation Testing in .NET"></picture></figure><article class="post"><header><h1>Your Tests Are Lying — Mutation Testing in .NET</h1></header><section class="content"><p>It begins like many stories in software: a well-intentioned developer joining a project, determined to do things properly. You arrive at a codebase that has grown organically, perhaps even chaotically. You decide you will bring order. You set up unit testing, you configure continuous integration, you measure code coverage. You write dozens or hundreds of tests. Every public method is touched, every branch is at least executed. The dashboard lights up green. You feel, quite frankly, on top of things.</p><p>Then one day, you discover a bug in production — a subtle logic error that wasn’t caught by any of your tests. The code that failed had a test. The test passed. The coverage tool declared that line covered. The build pipeline gave its all-clear. And yet, a customer faced an error and frustration ensued.</p><p>In that moment you realize something simple: <strong>coverage only tells you that your code was executed, not that your tests are meaningful</strong>. Your tests may run the code, but they may never actually verify its behavior, its intent or correctness. They claim safety, but they often deliver little more than comfort.</p><p>This is precisely where Mutation Testing enters the story. It casts a harsh light on test suites that pass unquestioned, and forces them to prove their worth.</p><h2 id="what-mutation-testing-actually-does"><a href="/posts/tests-are-lying/#what-mutation-testing-actually-does" title="What Mutation Testing Actually Does">What Mutation Testing Actually Does</a></h2><p>Unlike standard coverage analysis, Mutation Testing asks a deeper question: <em>&ldquo;If this code were slightly wrong, would my tests notice?&rdquo;</em> In practice, a mutation-testing engine picks up your production code and introduces small, controlled modifications — called <strong>mutants</strong>. For example, it might change a comparison operator (<code>>=</code> becomes <code>></code>), invert a Boolean, replace a constant value, or alter a logical branch.</p><p>Your existing tests are then run against that mutated code. If a test fails, the mutation is considered <strong>killed</strong> — your suite correctly caught the change. If a test still passes, the mutation <strong>survives</strong> — meaning your tests failed to detect a behavioral change. The ratio of killed versus surviving mutants gives you a <strong>mutation score</strong>, which is arguably a much more honest indicator of test quality than mere execution coverage.</p><p>The virtue of this method is that it forces test suites to defend correctness rather than just confirm code paths. As the official Stryker.NET documentation puts it: <em>a mutant is a small change in your code … if the tests still pass, the mutant survived. If your tests are good they should catch the change and fail.</em></p><h3 id="a-more-complex-example--real-world-business-logic-trap"><a href="/posts/tests-are-lying/#a-more-complex-example--real-world-business-logic-trap" title="A More Complex Example — Real-World Business Logic Trap">A More Complex Example — Real-World Business Logic Trap</a></h3><p>To illustrate more fully, consider a slightly more elaborate example that might exist in an enterprise system. Suppose you have an employee pay-out logic in a service or domain layer.</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kt">decimal</span> <span class="n">CalculatePayout</span><span class="p">(</span><span class="n">Employee</span> <span class="n">employee</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">employee</span><span class="p">.</span><span class="n">IsManager</span> <span class="p">&amp;&amp;</span> <span class="n">employee</span><span class="p">.</span><span class="n">PerformanceRating</span> <span class="p">&gt;=</span> <span class="m">4</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">employee</span><span class="p">.</span><span class="n">BaseSalary</span> <span class="p">*</span> <span class="m">1.25</span><span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">employee</span><span class="p">.</span><span class="n">IsManager</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">employee</span><span class="p">.</span><span class="n">BaseSalary</span> <span class="p">*</span> <span class="m">1.10</span><span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">employee</span><span class="p">.</span><span class="n">PerformanceRating</span> <span class="p">&gt;=</span> <span class="m">4</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">employee</span><span class="p">.</span><span class="n">BaseSalary</span> <span class="p">*</span> <span class="m">1.05</span><span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">employee</span><span class="p">.</span><span class="n">BaseSalary</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>At first glance, this code appears straightforward. You write tests such as:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="na">[Fact]</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">void</span> <span class="n">ManagerWithHighRatingGetsTopBonus</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">var</span> <span class="n">e</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Employee</span> <span class="p">{</span> <span class="n">IsManager</span> <span class="p">=</span> <span class="kc">true</span><span class="p">,</span> <span class="n">PerformanceRating</span> <span class="p">=</span> <span class="m">5</span><span class="p">,</span> <span class="n">BaseSalary</span> <span class="p">=</span> <span class="m">5000</span><span class="n">m</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">Assert</span><span class="p">.</span><span class="n">Equal</span><span class="p">(</span><span class="m">6250</span><span class="n">m</span><span class="p">,</span> <span class="n">CalculatePayout</span><span class="p">(</span><span class="n">e</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="na">
</span></span></span><span class="line"><span class="cl"><span class="na">[Fact]</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">void</span> <span class="n">RegularEmployeeGetsNoBonus</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">var</span> <span class="n">e</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Employee</span> <span class="p">{</span> <span class="n">IsManager</span> <span class="p">=</span> <span class="kc">false</span><span class="p">,</span> <span class="n">PerformanceRating</span> <span class="p">=</span> <span class="m">2</span><span class="p">,</span> <span class="n">BaseSalary</span> <span class="p">=</span> <span class="m">4000</span><span class="n">m</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">Assert</span><span class="p">.</span><span class="n">Equal</span><span class="p">(</span><span class="m">4000</span><span class="n">m</span><span class="p">,</span> <span class="n">CalculatePayout</span><span class="p">(</span><span class="n">e</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Both tests pass. You’re covered, right? The coverage tool shows nearly 100 % for this method. You feel confident.</p><p>Then a mutation testing run kicks in. Stryker mutates the code: it changes <code>>= 4</code> into <code>> 4</code>, or it alters the multiplier <code>1.25m</code> into <code>1.10m</code>, or perhaps it flips the order in which branches are evaluated. Your tests still pass. The mutation survives. That means your test suite did not notice the logic change. So your &ldquo;complete coverage&rdquo; was a mirage.</p><p>To correct that you might need an additional test such as:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="na">[Fact]</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">void</span> <span class="n">ManagerWithRatingExactlyAtBoundaryStillGetsTopBonus</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">var</span> <span class="n">e</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Employee</span> <span class="p">{</span> <span class="n">IsManager</span> <span class="p">=</span> <span class="kc">true</span><span class="p">,</span> <span class="n">PerformanceRating</span> <span class="p">=</span> <span class="m">4</span><span class="p">,</span> <span class="n">BaseSalary</span> <span class="p">=</span> <span class="m">5000</span><span class="n">m</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">Assert</span><span class="p">.</span><span class="n">Equal</span><span class="p">(</span><span class="m">6250</span><span class="n">m</span><span class="p">,</span> <span class="n">CalculatePayout</span><span class="p">(</span><span class="n">e</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>With that boundary test in place, the mutation turning <code>>= 4</code> into <code>> 4</code> would produce a test failure. This demonstrates how mutation testing forces you to think in terms of <strong>behavioral correctness</strong> rather than simply in terms of &ldquo;executing lines&rdquo;.</p><h2 id="my-wake-up-call-with-strykernet"><a href="/posts/tests-are-lying/#my-wake-up-call-with-strykernet" title="My Wake-Up Call with Stryker.NET">My Wake-Up Call with Stryker.NET</a></h2><p>Let me share a personal story: I applied Stryker.NET to one of our flagship services. We had dozens of tests, coverage hovering at 95%+, and high confidence. I thought we were &ldquo;done&rdquo;.</p><p>We ran Stryker. The results were sobering. We ran roughly <em>8,500 unit tests</em>, a very large number of possible mutants. Out of all those tests, we had a survival rate of nearly 23% mutants. In other words, nearly one quarter of potential logical changes would go undetected by our tests.</p><p>It felt like a punch in the gut. But it also felt like a gift. Because what followed was not shame but improvement. We began reviewing the surviving mutants, identifying which logic paths were untested or under-tested, and writing tests explicitly for them. Over subsequent runs the survival rate dropped, our mutation score improved, and our confidence increased — not because we chased a number, but because we improved our test suite’s behavior.</p><p>At the end of this process, we found <strong>12 undetected bugs</strong> in our solution and a lot of additional edge cases that we hadn’t considered before. Every single minute we spent on this effort paid off in increased quality and reliability.</p><h2 id="strykernet-for-net--tooling-and-support"><a href="/posts/tests-are-lying/#strykernet-for-net--tooling-and-support" title="Stryker.NET for .NET — Tooling and Support">Stryker.NET for .NET — Tooling and Support</a></h2><p>Stryker.NET is the de-facto propulsion engine for mutation testing in .NET. It supports .NET Core and .NET Framework projects, integrates with xUnit, NUnit, MSTest and TUnit, and is easy to install:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">dotnet tool install -g dotnet-stryker
</span></span></code></pre></div><p>In your test project directory you run:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">dotnet stryker
</span></span></code></pre></div><p>By default it will mutate your code, run your suite repeatedly, and generate an HTML report in the <code>StrykerOutput</code> directory.</p><p>Under the hood it uses the Roslyn syntax tree to identify code constructs and apply mutation operators (arithmetic, logical, string, etc.). The tool’s own documentation emphasises: &ldquo;For most projects no configuration is needed. Simply run stryker and it will find your source project to mutate.&rdquo;</p><p>Stryker supports various mutation operator types: equivalent operator changes, arithmetic, logical, string replacements and more.</p><p>The key point is: <strong>this tool tests the tests themselves.</strong></p><h2 id="realistic-devops-integration--balancing-insight-with-cost"><a href="/posts/tests-are-lying/#realistic-devops-integration--balancing-insight-with-cost" title="Realistic DevOps Integration — Balancing Insight with Cost">Realistic DevOps Integration — Balancing Insight with Cost</a></h2><p>Here is where many teams stumble: integrating mutation testing into your DevOps pipeline sensibly. Most articles might say &ldquo;run it in CI on every pull request&rdquo;, but the truth is more nuanced.</p><p>Mutation testing is <strong>resource-intensive</strong>. It doesn’t execute your test suite once — it executes many times, with small code mutations each time. On a large codebase with thousands of tests, this means hours of build time, heavy CPU usage, and long delays. A paper on mutation testing at scale shows that sheer volume of mutants has been a barrier to adoption.</p><p>In practice you want to adopt a measured approach. A workable pattern could be:</p><ol><li><p>Schedule Stryker.NET runs nightly or weekly when build agents are idle.</p></li><li><p>Treat the mutation report as a diagnostic tool, not a blocking gate for every commit.</p></li><li><p>Store HTML reports as build artifacts and share them with the team; review early in the next working day.</p></li><li><p>Use incremental mutation testing for pull-requests:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">dotnet stryker --since main
</span></span></code></pre></div><p>This limits the scope of mutation to changed files and reduces runtime.</p></li><li><p>Define a trend-based metric rather than a rigid threshold: track mutation score over time rather than failing the build at 100%. Use, say, 75 % or 80 % as a warning boundary, not a hard stop.</p></li><li><p>Focus mutation testing on critical modules — domain logic, validation rules, calculation services — rather than boilerplate, auto-generated code or trivial getters.</p></li></ol><p>I once attempted to run Stryker on every single pull request in our organization. The result was slow pipelines, frustrated engineers, and team pushes to bypass tests. We switched to a weekly schedule, freed up CI capacity, and made the reporting part of our Monday morning health check. The result: higher buy-in, better tests, and a steady drop in survived mutants.</p><p>It is also important to communicate clearly that mutation testing is <strong>not about speed</strong>, but about <strong>quality insight</strong>. Teams need to know that runs take time — sometimes hours, depending on repository size — and that the value lies in what you learn, rather than whether the build stays green quickly.</p><h3 id="managing-scope-complexity-and-equivalent-mutants"><a href="/posts/tests-are-lying/#managing-scope-complexity-and-equivalent-mutants" title="Managing Scope, Complexity and Equivalent Mutants">Managing Scope, Complexity and Equivalent Mutants</a></h3><p>Mutation testing brings its own practical complexities. Among them:</p><ul><li><strong>Equivalent mutants</strong>: mutants that alter code but not behavior. They survive but don’t indicate a real deficiency. A recent empirical study found that correctly identifying equivalent mutants remains a challenge.</li><li><strong>Large mutant counts</strong>: Without filtering, you may generate thousands of mutants. A paper on mutation testing at scale recommends incremental mutation and filtering.</li><li><strong>Performance tuning</strong>: Stryker.NET offers options for parallel execution, mutation exclusion, and threshold configuration. Use these to keep runtime manageable.</li><li><strong>Test suite quality prerequisite</strong>: If you have almost no tests, mutation testing will bury you. It is most effective when you already have a reasonable baseline of tests. One blog notes: &ldquo;if a team has difficulty finding time to write any tests at all, mutation testing is probably something that should take a backseat.&rdquo;</li></ul><p>Even with these caveats, the benefit is clear: you find gaps you would not otherwise know existed, and you improve your test suite’s resilience.</p><h2 id="the-honest-metric"><a href="/posts/tests-are-lying/#the-honest-metric" title="The Honest Metric">The Honest Metric</a></h2><p>In the end, Mutation Testing offers an honest metric: it does not flatter you. It does not congratulate you for 97% coverage. It simply tells you how many logical changes your test suite would <em>detect</em>. And often, that number is far lower than you expect.</p><p>Stryker.NET brings that evaluation to the .NET ecosystem, supporting xUnit, NUnit, MSTest and TUnit. Whether you run it weekly, monthly or as part of a scheduled build, the insight remains meaningful.</p><p>It forces you to shift your mindset: from simply running tests to <strong>defending logic</strong>, from coverage numbers to <strong>behavioral assurance</strong>. Instead of asking &ldquo;did my code run?&rdquo; you begin to ask &ldquo;if I changed the code, would my tests notice?&rdquo;</p><p>At the end of the day, green test suites are comfortable. Mutation-tested suites are trustworthy. And in a world where defects cost time, money and reputation, trust is what matters most.</p></section><h2>Comments</h2><aside class="giscus"></aside><script src="https://giscus.app/client.js" data-repo="dailydevops/dailydevops.github.io" data-repo-id="R_kgDOHA8eFg" data-category="Announcements" data-category-id="DIC_kwDOHA8eFs4COIqL" data-mapping="pathname" data-strict="1" data-reactions-enabled="0" data-emit-metadata="0" data-input-position="bottom" data-theme="light" data-lang="en" crossorigin="anonymous" async></script></article><aside class="sidebar divider"><section class="sidecar info"><ul><li><time datetime="2025-10-30T18:00:00+02:00">Published on 10/30/25 6:00 pm</time></li><li>Read in 9 minutes</li></ul></section><section class="sidecar author"><header><h2><a href="/authors/martin/" rel="author" title="Martin Stühmer">Author Martin Stühmer</a></h2></header><figure class="round"><picture><img src="https://www.gravatar.com/avatar/6da4a47ff9cc2b750452225fdb2582f7?d=identicon&amp;s=200" alt="Martin Stühmer" loading="lazy" decoding="async" title="Martin Stühmer"></picture></figure><section class="content">Martin is a seasoned software architect and developer based in the Cologne/Bonn area, with over 15 years of experience in utilizing .NET and Microsoft technologies in his work. His expertise lies in enhancing the quality and performance of development teams, optimizing software solutions for target environments, and maximizing application efficiency. Currently serving as the Director Consulting Services at CGI, he specializes in cloud-native and .NET solutions, while also providing training in cloud and software architecture. Beyond his professional endeavors, Martin actively contributes to open-source communities by offering various NuGet packages. In 2021, he achieved certifications as an IHK instructor and Microsoft certified trainer, furthering his commitment to continuous learning. Additionally, he became a certified trainer for CGI’s Risk and Cost Driven Architecture program in 2022.</section><a class="link" href="/authors/martin/" rel="author" title="Martin Stühmer"></a></section><section class="sidecar social"><header><h2>Social media</h2></header><a class="icon bluesky" href="https://bsky.app/profile/samtrion.net" rel="noopener external" title="Follow me on Bluesky" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-bluesky fa-stack-1x fa-inverse"></i>
</span></a><a class="icon github" href="https://github.com/samtrion" rel="noopener external" title="Follow me on GitHub" target="_blank"><i class="fa-brands fa-fw fa-github fa-2x"></i></a>
<a class="icon linkedin" href="https://www.linkedin.com/in/martin-stuehmer" rel="noopener external" title="Follow me on LinkedIn" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-linkedin-in fa-stack-1x fa-inverse"></i>
</span></a><a class="icon stackoverflow" href="https://stackoverflow.com/users/10574963" rel="noopener external" title="Follow me on Stack Overflow" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-stack-overflow fa-stack-1x fa-inverse"></i>
</span></a><a class="icon mail" href="mailto:martin@daily-devops.net" title="Contact me by e-mail" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
</span></a><a class="icon feed" href="/authors/martin/feed.rss" title="My RSS feed" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></section><section class="sidecar share"><header><h2>Share this content</h2></header><a class="icon linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fdaily-devops.net%2fposts%2ftests-are-lying%2f&text=Your%20Tests%20Are%20Lying%20%e2%80%94%20Mutation%20Testing%20in%20.NET%20%26mdash%3b%20Daily%20DevOps%20%26%20.NET" target="_blank" rel="noopener external" aria-label="Share on LinkedIn" title="Share on LinkedIn" target="_blank"><i class="fa-brands fa-fw fa-linkedin-in fa-2x"></i></a>
<a class="icon bluesky" href="https://bsky.app/intent/compose?text=Your%20Tests%20Are%20Lying%20%e2%80%94%20Mutation%20Testing%20in%20.NET%20%26mdash%3b%20Daily%20DevOps%20%26%20.NET%20https%3a%2f%2fdaily-devops.net%2fposts%2ftests-are-lying%2f" target="_blank" rel="noopener external" aria-label="Share on Bluesky" title="Share on Bluesky" target="_blank"><i class="fa-brands fa-fw fa-bluesky fa-2x"></i></a></section><section class="sidecar tags"><header><h2>Tags</h2></header><ul><li class="tag"><a href="/tags/dotnet/" hreflang="en" rel="tag" title=".NET"><i class="fas fa-tag"></i>&nbsp;.NET</a></li><li class="tag"><a href="/tags/csharp/" hreflang="en" rel="tag" title="C#"><i class="fas fa-tag"></i>&nbsp;C#</a></li><li class="tag"><a href="/tags/nuget/" hreflang="en" rel="tag" title="NuGet"><i class="fas fa-tag"></i>&nbsp;NuGet</a></li><li class="tag"><a href="/tags/technicaldebt/" hreflang="en" rel="tag" title="Technical Debt"><i class="fas fa-tag"></i>&nbsp;Technical Debt</a></li><li class="tag"><a href="/tags/testing/" hreflang="en" rel="tag" title="Testing"><i class="fas fa-tag"></i>&nbsp;Testing</a></li></ul></section><section class="sidecar related"><header><h2>Related content</h2></header><article class="post"><figure class="square"><picture><source srcset="/images/dotnet-80x80.webp?v=362353a62d867b7e3a0f33ec80e2eebf" type="image/webp"><source srcset="/images/dotnet-80x80.png?v=98376a285f07b0021d3118e0523d147a" type="image/png"><img src="/images/dotnet.png?v=8142ec8a038ba14415ff0d0434c78182" alt="Buzzword-Driven Development vs. Fundamental Software Quality" loading="lazy" decoding="async" title="Buzzword-Driven Development vs. Fundamental Software Quality"></picture></figure><header><h2><a href="/posts/buzzword-driven-development/" rel="bookmark">Buzzword-Driven Development vs. Fundamental Software Quality</a></h2></header><section class="content">Explore why fundamental software quality practices in .NET must never be overlooked for trendy buzzwords, including recommended analyzers and project settings for managing technical debt effectively.</section></article><article class="post"><figure class="square"><picture><source srcset="/images/vibecoding-80x80.webp?v=627bd7d4bf89f079951c78503a124358" type="image/webp"><source srcset="/images/vibecoding-80x80.png?v=7617a55dbdf6bd7939238821b77c1a82" type="image/png"><img src="/images/vibecoding.png?v=9a36076d86533930bbd6319c257968b9" alt="Vibe Coding in .NET: Creative Catalyst or Maintenance Risk?" loading="lazy" decoding="async" title="Vibe Coding in .NET: Creative Catalyst or Maintenance Risk?"></picture></figure><header><h2><a href="/posts/vibe-coding-isnt-wrong-its-unfinished/" rel="bookmark">Vibe Coding in .NET: Creative Catalyst or Maintenance Risk?</a></h2></header><section class="content"><p>In the world of software development, there’s a recurring tension between <strong>discipline and improvisation</strong>. Somewhere along that spectrum lies a phenomenon increasingly referred to as <strong>Vibe Coding</strong>. The term evokes a style of development where engineers follow intuition and momentum rather than formal plans, processes, or design patterns.</p><p>It’s fast, fluid, and occasionally brilliant. But is it sustainable in a .NET-based enterprise context?</p></section></article><article class="post"><figure class="square"><picture><source srcset="/images/package-manager-80x80.webp?v=3e26abc13094811c467aceb9c6cc4403" type="image/webp"><source srcset="/images/package-manager-80x80.png?v=e2d9bba485820dc0336d1253eb4dd7a1" type="image/png"><img src="/images/package-manager.png?v=19ac8eda9b0cc3394a0da24151d44079" alt="Manage NuGet Packages Centrally" loading="lazy" decoding="async" title="Manage NuGet Packages Centrally"></picture></figure><header><h2><a href="/posts/manage-nuget-packages-centrally/" rel="bookmark">Manage NuGet Packages Centrally</a></h2></header><section class="content"><p>For over 12 years, NuGet package management has been part of the .NET ecosystem with direct integrations to various IDEs, CLIs and build systems. But a feature took 12 years before it appeared and certainly needs some more maintenance until it is mature!</p></section></article></section></aside><nav class="pager"><a class="next" href="/posts/modern-defensive-programming/" title="Modern Defensive Programming in .NET — Unified Throw-Helpers and Multi-Framework Compatibility" rel="next"><span class="sub"><i class="fas fa-backward"></i>&emsp;Next</span><p class="title">Modern Defensive Programming in .NET — Unified Throw-Helpers and Multi-Framework Compatibility</p></a><a class="prev" href="/posts/nuget-packagedownload-functionality/" title="PackageDownload: NuGet's Forgotten Power Tool
" rel="prev"><span class="sub">Previous&emsp;<i class="fas fa-forward"></i></span><p class="title">PackageDownload: NuGet's Forgotten Power Tool</p></a></nav></main><footer class="footer"><div class="divider"></div><nav><ul class="navigation"><li><a href="/tags/">Tags</a></li><li><a href="/legal-notice/">Legal notice</a></li></ul></nav><div class="copyright">&copy; 2023 - 2025 Daily DevOps & .NET</div></footer><script defer src="/js/below.min.a6ce9164454b6077f17ae856f280442d9f3a1e21f06189f71c21f75144b22a0c8cf32bafd61d440e9d90ca02bf738b6a8ef19f5ec20285d8ca574f98c91ebaf2.js" integrity="sha512-ps6RZEVLYHfxeuhW8oBELZ86HiHwYYn3HCH3UUSyKgyM8yuv1h1EDp2QygK/c4tqjvGfXsIChdjKV0+YyR668g==" crossorigin="anonymous"></script><img class="vgwort" src="https://vg06.met.vgwort.de/na/f06014cabb744dc2a9990c33a80e74b0" width="1" height="1" alt="VG Wort" title="VG Wort"></body></html>