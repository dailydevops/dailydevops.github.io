<!doctype html><html class="no-js" lang="en" dir="ltr"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="theme-color" content="#15a"><title>.NET Job Scheduling — NCronJob and Native Minimalism — Daily DevOps & .NET</title><meta name="description" content="NCronJob leverages IHostedService for lightweight scheduling with zero external dependencies.
Understand when minimal infrastructure and native ASP.NET Core …"><meta name="twitter:description" property="og:description" content="NCronJob leverages IHostedService for lightweight scheduling with zero external dependencies.
Understand when minimal infrastructure and native ASP.NET Core …"><meta name="author" content="Martin Stühmer"><link rel="icon" href="/logo.svg?v=b9e294dc5c6fa04439c8c803d8e981a9" sizes="any" type="image/svg+xml"><meta name="twitter:title" property="og:title" content=".NET Job Scheduling — NCronJob and Native Minimalism — Daily DevOps & .NET"><meta property="og:updated_time" content="2026-01-05T12:05:23+01:00"><meta property="article:modified_time" content="2026-01-05T12:05:23+01:00"><meta property="article:published_time" content="2025-12-09T17:00:00+01:00"><meta property="og:type" content="article"><meta property="og:site_name" content="Daily DevOps & .NET"><meta property="og:url" content="https://daily-devops.net/posts/dotnet-job-scheduling-5-ncronjob/"><meta property="og:locale" content="en"><meta name="twitter:card" content="summary_large_image"><meta property="og:image" name="twitter:image" content="https://daily-devops.net/images/nuget-scheduler-1200x630.webp?v=6c873165478edaa8fb2094739dd364cb"><meta property="og:image:secure_url" content="https://daily-devops.net/images/nuget-scheduler-1200x630.webp?v=6c873165478edaa8fb2094739dd364cb"><meta property="og:image:alt" name="twitter:image:alt" content=".NET Job Scheduling — NCronJob and Native Minimalism"><meta property="og:image:type" content="image/webp"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta property="og:image" name="twitter:image" content="https://daily-devops.net/images/nuget-scheduler-1200x630.png?v=16dd667ddd31353e2d9ebc222586164d"><meta property="og:image:secure_url" content="https://daily-devops.net/images/nuget-scheduler-1200x630.png?v=16dd667ddd31353e2d9ebc222586164d"><meta property="og:image:alt" name="twitter:image:alt" content=".NET Job Scheduling — NCronJob and Native Minimalism"><meta property="og:image:type" content="image/png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><link rel="dns-prefetch" href="https://www.clarity.ms"><link rel="preconnect" href="https://www.clarity.ms" crossorigin><link rel="stylesheet" href="/css/style.min.0b2ef4378cd908eb695017aaa74603d244ff2b38c8068b4b51d76cad830c8ee5e3a40b67ab5b860a542c8bae73d8ba90cfbe9249b59c733a50de74cc32af818a.css" integrity="sha512-Cy70N4zZCOtpUBeqp0YD0kT/KzjIBotLUddsrYMMjuXjpAtnq1uGClQsi65z2LqQz76SSbWcczpQ3nTMMq+Big==" crossorigin="anonymous"><link rel="alternate" href='https://daily-devops.net/posts/dotnet-job-scheduling-5-ncronjob/' hreflang="x-default" title=".NET Job Scheduling — NCronJob and Native Minimalism &mdash; Daily DevOps & .NET"><link rel="alternate" href="https://daily-devops.net/en/posts/dotnet-job-scheduling-5-ncronjob" hreflang="en" title=".NET Job Scheduling — NCronJob and Native Minimalism &mdash; Daily DevOps & .NET"><link rel="canonical" href="https://daily-devops.net/posts/dotnet-job-scheduling-5-ncronjob/" hreflang="en" title=".NET Job Scheduling — NCronJob and Native Minimalism &mdash; Daily DevOps & .NET"><link rel="home" href="https://daily-devops.net/" hreflang="en" title="Daily DevOps & .NET"><link rel="next" href="https://daily-devops.net/posts/aks-network-policies-zero-trust/" hreflang="en" title="AKS Network Policies: The Security Layer Your Cluster Is Missing"><link rel="prev" href="https://daily-devops.net/posts/dotnet-job-scheduling-4-coravel/" hreflang="en" title=".NET Job Scheduling — Coravel and Fluent Simplicity"><link rel="author" href="https://daily-devops.net/authors/martin/" hreflang="en" title="Martin Stühmer &mdash; Daily DevOps & .NET"><meta name="giscus:backlink" content="https://daily-devops.net/posts/dotnet-job-scheduling-5-ncronjob/"><script defer src="/js/above.min.cb42b2c9a453e49e278326637d72d2f01e7f32e3f91e9cdde8fb587793d05514efd2f5cc5021c9658ca0f73876dbdcd1f7cb4a37c0bebc9df01110926b6d7cba.js" integrity="sha512-y0KyyaRT5J4ngyZjfXLS8B5/MuP5Hpzd6PtYd5PQVRTv0vXMUCHJZYyg9zh229zR98tKN8C+vJ3wERCSa218ug==" crossorigin="anonymous"></script><script type="text/javascript">(function(e,t,n,s,o,i,a){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)},i=t.createElement(s),i.async=1,i.src="https://www.clarity.ms/tag/"+o,a=t.getElementsByTagName(s)[0],a.parentNode.insertBefore(i,a)})(window,document,"clarity","script","o0pr4n9gg3")</script><script src="https://analytics.ahrefs.com/analytics.js" data-key="C5Iv+2Rb9el+FLJqVw2QGA" async></script></head><body class="container"><header class="header"><a class="logo" href="/" title="Daily DevOps & .NET" rel="home"><figure class="page-logo"><picture><img src="/logo.svg?v=b9e294dc5c6fa04439c8c803d8e981a9" alt="Daily DevOps & .NET" title="Daily DevOps & .NET"></picture></figure><span class="title">Daily DevOps & .NET</span></a><nav class="menu" aria-label="Main navigation"><button class="burger" type="button" aria-haspopup="menu" aria-expanded="false" aria-label="Toggle menu">
<i class="fas fa-burger" aria-hidden="true"></i></button><ul class="navigation"><li class="active"><a href="/posts/">Posts</a></li><li><a href="/authors/">About us</a></li></ul></nav><div class="divider"></div></header><main class="body"><figure class="hero"><picture><source srcset="/images/nuget-scheduler-544x136.webp?v=d14137f6a7f3ac87850b22ccf6e2d736" type="image/webp" media="(max-width: 575.98px)"><source srcset="/images/nuget-scheduler-544x136.png?v=f24f4c05bcbce7421f53568505a29f42" type="image/png" media="(max-width: 575.98px)"><source srcset="/images/nuget-scheduler-672x168.webp?v=b53468458c676d5ddd8d4e220ca54ece" type="image/webp" media="(max-width: 767.98px)"><source srcset="/images/nuget-scheduler-672x168.png?v=9081a48ed39bbcf72048c71e59f757bf" type="image/png" media="(max-width: 767.98px)"><source srcset="/images/nuget-scheduler-896x224.webp?v=7fd7b2374cc4875444a5047edf53c947" type="image/webp" media="(max-width: 991.98px)"><source srcset="/images/nuget-scheduler-896x224.png?v=2e6bb71535af5f7bbaa14618564af8db" type="image/png" media="(max-width: 991.98px)"><source srcset="/images/nuget-scheduler-1104x276.webp?v=bf81fcb69172ac96987ce3ab02c004a5" type="image/webp" media="(max-width: 1199.98px)"><source srcset="/images/nuget-scheduler-1104x276.png?v=13c4fd9c98192929ddcca480ea783609" type="image/png" media="(max-width: 1199.98px)"><source srcset="/images/nuget-scheduler-1444x361.webp?v=bb6c9fd14d89f50cd92121c3c8eef97b" type="image/webp"><source srcset="/images/nuget-scheduler-1444x361.png?v=5e8383f2e2acb3de1df045ebc65e458d" type="image/png"><img src="/images/nuget-scheduler.png?v=4159bfd7c08b58b0fc741782fe532741" alt=".NET Job Scheduling — NCronJob and Native Minimalism" loading="lazy" decoding="async" title=".NET Job Scheduling — NCronJob and Native Minimalism"></picture></figure><article class="post"><header><h1>.NET Job Scheduling — NCronJob and Native Minimalism</h1></header><section class="content" role="region"><p>Your microservice runs in a Kubernetes cluster, processing events from a message queue. Every hour, it purges stale cache entries. Every morning at 6 AM, it triggers a health check against downstream services. The service is stateless, ephemeral, and designed to scale horizontally based on load—we&rsquo;ve seen it scale from 3 pods to 45 during traffic spikes.</p><p>You need scheduled tasks, but adding a database for job persistence? That violates the entire stateless design principle. External schedulers like Kubernetes CronJobs? We tried that. Managing separate YAML manifests, container image versioning, and lifecycle coupling between the CronJob and the main deployment became a maintenance nightmare. When we needed to update the health check logic, we had to deploy both the main service <em>and</em> the CronJob separately. Teams kept forgetting the second step.</p><p>NCronJob addresses this by embedding scheduling directly into the application using ASP.NET Core&rsquo;s <code>IHostedService</code>. Jobs run in-process, require zero external dependencies, and scale with the application. The scheduler is lightweight—hundreds of lines of code, not thousands—and integrates seamlessly with dependency injection. The trade-off: jobs don&rsquo;t persist, horizontal scaling can cause duplication, and advanced features like clustering or dashboards don&rsquo;t exist.</p><p>For microservices, containerized applications, or systems prioritizing simplicity over feature richness, NCronJob removes friction. For applications needing persistence, retry policies, or distributed coordination, alternative architectural approaches merit evaluation.</p><h2 id="architecture-ihostedservice-integration"><a href="/posts/dotnet-job-scheduling-5-ncronjob/#architecture-ihostedservice-integration" title="Architecture: IHostedService Integration">Architecture: IHostedService Integration</a></h2><p>NCronJob builds on <code>IHostedService</code>, the ASP.NET Core primitive for long-running background operations. When the application starts, NCronJob&rsquo;s hosted service initializes, parses cron expressions, calculates next execution times, and schedules jobs using <code>System.Threading.Timer</code>. When execution times arrive, the scheduler invokes jobs via dependency injection, passing parameters if configured.</p><p>The design is intentionally minimal. There&rsquo;s no database, no external storage, no worker coordination beyond single-process execution. Jobs are defined as classes implementing <code>IJob</code> or via inline lambda expressions. The scheduler maintains an in-memory list of job definitions and fires them based on cron schedules.</p><p>This simplicity makes NCronJob ideal for:</p><ul><li><strong>Microservices</strong>: Each service schedules its own tasks without shared infrastructure.</li><li><strong>Containerized deployments</strong>: Stateless containers start, execute scheduled tasks, and terminate without persisting job state.</li><li><strong>Internal tools</strong>: Applications where background tasks are secondary concerns, not architectural focal points.</li></ul><p>NCronJob also supports instant jobs—one-time executions triggered programmatically, useful for workflows where scheduled tasks need manual activation or dependent tasks chain together.</p><h2 id="configuration-and-integration"><a href="/posts/dotnet-job-scheduling-5-ncronjob/#configuration-and-integration" title="Configuration and Integration">Configuration and Integration</a></h2><p>Integrating NCronJob requires minimal setup. Install the NuGet package:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">dotnet add package NCronJob
</span></span></code></pre></div><p>Register jobs and schedules in <code>Program.cs</code>:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="n">builder</span><span class="p">.</span><span class="n">Services</span><span class="p">.</span><span class="n">AddNCronJob</span><span class="p">(</span><span class="n">options</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">options</span><span class="p">.</span><span class="n">AddJob</span><span class="p">&lt;</span><span class="n">CacheCleanupJob</span><span class="p">&gt;(</span><span class="n">job</span> <span class="p">=&gt;</span> <span class="n">job</span><span class="p">.</span><span class="n">WithCronExpression</span><span class="p">(</span><span class="s">&#34;0 * * * *&#34;</span><span class="p">));</span> <span class="c1">// Hourly</span>
</span></span><span class="line"><span class="cl">    <span class="n">options</span><span class="p">.</span><span class="n">AddJob</span><span class="p">&lt;</span><span class="n">HealthCheckJob</span><span class="p">&gt;(</span><span class="n">job</span> <span class="p">=&gt;</span> <span class="n">job</span><span class="p">.</span><span class="n">WithCronExpression</span><span class="p">(</span><span class="s">&#34;0 6 * * *&#34;</span><span class="p">));</span>  <span class="c1">// Daily at 6 AM</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">app</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="k">await</span> <span class="n">app</span><span class="p">.</span><span class="n">UseNCronJobAsync</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">app</span><span class="p">.</span><span class="n">Run</span><span class="p">();</span>
</span></span></code></pre></div><p>Jobs implement <code>IJob</code>:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">class</span> <span class="nc">CacheCleanupJob</span> <span class="p">:</span> <span class="n">IJob</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="k">readonly</span> <span class="n">ICacheService</span> <span class="n">_cache</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">CacheCleanupJob</span><span class="p">(</span><span class="n">ICacheService</span> <span class="n">cache</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">_cache</span> <span class="p">=</span> <span class="n">cache</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">async</span> <span class="n">Task</span> <span class="n">RunAsync</span><span class="p">(</span><span class="n">IJobExecutionContext</span> <span class="n">context</span><span class="p">,</span> <span class="n">CancellationToken</span> <span class="n">token</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">await</span> <span class="n">_cache</span><span class="p">.</span><span class="n">RemoveExpiredEntriesAsync</span><span class="p">(</span><span class="n">token</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>NCronJob resolves dependencies from the DI container and injects them into jobs. The <code>IJobExecutionContext</code> provides metadata—execution time, parameters, cancellation tokens—enabling context-aware job logic.</p><p>Inline jobs reduce boilerplate for simple tasks:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="n">options</span><span class="p">.</span><span class="n">AddJob</span><span class="p">((</span><span class="n">ILogger</span><span class="p">&lt;</span><span class="n">Program</span><span class="p">&gt;</span> <span class="n">logger</span><span class="p">)</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">logger</span><span class="p">.</span><span class="n">LogInformation</span><span class="p">(</span><span class="s">&#34;Heartbeat at {Time}&#34;</span><span class="p">,</span> <span class="n">DateTime</span><span class="p">.</span><span class="n">UtcNow</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">},</span> <span class="s">&#34;*/5 * * * *&#34;</span><span class="p">);</span> <span class="c1">// Every 5 minutes</span>
</span></span></code></pre></div><p>This fluent API mirrors Minimal APIs in ASP.NET Core, where route handlers are inline delegates with parameter injection. The consistency reduces cognitive load for developers familiar with modern .NET conventions.</p><h2 id="cron-expressions-and-scheduling-semantics"><a href="/posts/dotnet-job-scheduling-5-ncronjob/#cron-expressions-and-scheduling-semantics" title="Cron Expressions and Scheduling Semantics">Cron Expressions and Scheduling Semantics</a></h2><p>NCronJob uses standard five-field cron syntax:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">* * * * *
</span></span><span class="line"><span class="cl">│ │ │ │ │
</span></span><span class="line"><span class="cl">│ │ │ │ └─── Day of week <span class="o">(</span>0-7, where <span class="m">0</span> and <span class="m">7</span> are Sunday<span class="o">)</span>
</span></span><span class="line"><span class="cl">│ │ │ └───── Month <span class="o">(</span>1-12<span class="o">)</span>
</span></span><span class="line"><span class="cl">│ │ └─────── Day of month <span class="o">(</span>1-31<span class="o">)</span>
</span></span><span class="line"><span class="cl">│ └───────── Hour <span class="o">(</span>0-23<span class="o">)</span>
</span></span><span class="line"><span class="cl">└─────────── Minute <span class="o">(</span>0-59<span class="o">)</span>
</span></span></code></pre></div><p>Examples:</p><ul><li><code>0 * * * *</code>: Every hour at minute 0.</li><li><code>0 6 * * *</code>: Daily at 6 AM.</li><li><code>0 0 1 * *</code>: Monthly on the 1st at midnight.</li><li><code>*/15 * * * *</code>: Every 15 minutes.</li></ul><p>Cron expressions are parsed at startup. Invalid expressions cause application startup failures, preventing silent misconfigurations. This fail-fast behavior aligns with modern cloud-native principles: catch configuration errors early, not in production.</p><p>NCronJob supports timezone-aware scheduling:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">TimeZoneConverter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">options</span><span class="p">.</span><span class="n">AddJob</span><span class="p">&lt;</span><span class="n">ReportJob</span><span class="p">&gt;(</span><span class="n">job</span> <span class="p">=&gt;</span> <span class="n">job</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">WithCronExpression</span><span class="p">(</span><span class="s">&#34;0 9 * * *&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">WithTimeZone</span><span class="p">(</span><span class="n">TZConvert</span><span class="p">.</span><span class="n">GetTimeZoneInfo</span><span class="p">(</span><span class="s">&#34;America/New_York&#34;</span><span class="p">)));</span>
</span></span></code></pre></div><p>This ensures jobs fire at correct local times regardless of server timezone settings—critical for multi-region deployments or applications serving global users.</p><h2 id="job-parameters-and-instant-execution"><a href="/posts/dotnet-job-scheduling-5-ncronjob/#job-parameters-and-instant-execution" title="Job Parameters and Instant Execution">Job Parameters and Instant Execution</a></h2><p>Jobs often need parameters—identifiers, configuration values, dynamic inputs. NCronJob passes parameters via the execution context:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="n">options</span><span class="p">.</span><span class="n">AddJob</span><span class="p">&lt;</span><span class="n">DataImportJob</span><span class="p">&gt;(</span><span class="n">job</span> <span class="p">=&gt;</span> <span class="n">job</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">WithCronExpression</span><span class="p">(</span><span class="s">&#34;0 2 * * *&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">WithParameter</span><span class="p">(</span><span class="s">&#34;source&#34;</span><span class="p">,</span> <span class="s">&#34;external-api&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">class</span> <span class="nc">DataImportJob</span> <span class="p">:</span> <span class="n">IJob</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">async</span> <span class="n">Task</span> <span class="n">RunAsync</span><span class="p">(</span><span class="n">IJobExecutionContext</span> <span class="n">context</span><span class="p">,</span> <span class="n">CancellationToken</span> <span class="n">token</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">var</span> <span class="n">source</span> <span class="p">=</span> <span class="n">context</span><span class="p">.</span><span class="n">Parameter</span> <span class="k">as</span> <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">await</span> <span class="n">ImportDataAsync</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">token</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>For workflows requiring manual job execution, NCronJob provides instant jobs via <code>IInstantJobRegistry</code>:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">class</span> <span class="nc">OrderService</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="k">readonly</span> <span class="n">IInstantJobRegistry</span> <span class="n">_registry</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">OrderService</span><span class="p">(</span><span class="n">IInstantJobRegistry</span> <span class="n">registry</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">_registry</span> <span class="p">=</span> <span class="n">registry</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">async</span> <span class="n">Task</span> <span class="n">CompleteOrderAsync</span><span class="p">(</span><span class="kt">int</span> <span class="n">orderId</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Process order logic...</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">await</span> <span class="n">_registry</span><span class="p">.</span><span class="n">RunInstantJobAsync</span><span class="p">&lt;</span><span class="n">SendConfirmationJob</span><span class="p">&gt;(</span><span class="n">orderId</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Instant jobs execute immediately on background threads, decoupling them from HTTP request lifetimes. This pattern suits scenarios where scheduled tasks need programmatic triggers—user-initiated reports, dependent workflows, or event-driven processing.</p><h2 id="job-dependencies-and-chaining"><a href="/posts/dotnet-job-scheduling-5-ncronjob/#job-dependencies-and-chaining" title="Job Dependencies and Chaining">Job Dependencies and Chaining</a></h2><p>NCronJob supports job dependencies, enabling workflows where job B executes only after job A succeeds or fails:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="n">options</span><span class="p">.</span><span class="n">AddJob</span><span class="p">&lt;</span><span class="n">ImportDataJob</span><span class="p">&gt;(</span><span class="n">job</span> <span class="p">=&gt;</span> <span class="n">job</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">WithCronExpression</span><span class="p">(</span><span class="s">&#34;0 2 * * *&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">ExecuteWhen</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">success</span><span class="p">:</span> <span class="n">s</span> <span class="p">=&gt;</span> <span class="n">s</span><span class="p">.</span><span class="n">RunJob</span><span class="p">&lt;</span><span class="n">TransformDataJob</span><span class="p">&gt;(),</span>
</span></span><span class="line"><span class="cl">        <span class="n">faulted</span><span class="p">:</span> <span class="n">s</span> <span class="p">=&gt;</span> <span class="n">s</span><span class="p">.</span><span class="n">RunJob</span><span class="p">&lt;</span><span class="n">NotifyFailureJob</span><span class="p">&gt;()));</span>
</span></span></code></pre></div><p>When <code>ImportDataJob</code> succeeds, <code>TransformDataJob</code> executes automatically. If it fails, <code>NotifyFailureJob</code> handles the error. This declarative approach simplifies common workflows without custom orchestration logic.</p><p>Job chaining also supports inline delegates:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="n">options</span><span class="p">.</span><span class="n">AddJob</span><span class="p">&lt;</span><span class="n">ProcessFileJob</span><span class="p">&gt;(</span><span class="n">job</span> <span class="p">=&gt;</span> <span class="n">job</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">WithCronExpression</span><span class="p">(</span><span class="s">&#34;0 3 * * *&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">ExecuteWhen</span><span class="p">(</span><span class="n">success</span><span class="p">:</span> <span class="n">s</span> <span class="p">=&gt;</span> <span class="n">s</span><span class="p">.</span><span class="n">RunJob</span><span class="p">(</span><span class="kd">async</span> <span class="p">(</span><span class="n">INotificationService</span> <span class="n">notifier</span><span class="p">)</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">await</span> <span class="n">notifier</span><span class="p">.</span><span class="n">SendAsync</span><span class="p">(</span><span class="s">&#34;File processed successfully&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">})));</span>
</span></span></code></pre></div><p>This fluency reduces boilerplate for simple dependent tasks, keeping configuration concise.</p><h2 id="startup-jobs-and-application-lifecycle"><a href="/posts/dotnet-job-scheduling-5-ncronjob/#startup-jobs-and-application-lifecycle" title="Startup Jobs and Application Lifecycle">Startup Jobs and Application Lifecycle</a></h2><p>Some tasks must run immediately when the application starts—cache warming, database migrations, configuration validation. NCronJob supports startup jobs:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="n">options</span><span class="p">.</span><span class="n">AddJob</span><span class="p">&lt;</span><span class="n">CacheWarmupJob</span><span class="p">&gt;(</span><span class="n">job</span> <span class="p">=&gt;</span> <span class="n">job</span><span class="p">.</span><span class="n">RunAtStartup</span><span class="p">());</span>
</span></span></code></pre></div><p>The <code>UseNCronJobAsync()</code> method executes startup jobs before the application begins serving requests, ensuring initialization completes synchronously. This prevents race conditions where HTTP requests arrive before background tasks finish preparing the system.</p><p>Startup jobs block application startup. If they fail, the application doesn&rsquo;t start—matching fail-fast principles. For long-running initialization, consider splitting startup tasks into instant jobs triggered asynchronously after startup.</p><h2 id="stateless-design-and-cloud-native-fit"><a href="/posts/dotnet-job-scheduling-5-ncronjob/#stateless-design-and-cloud-native-fit" title="Stateless Design and Cloud-Native Fit">Stateless Design and Cloud-Native Fit</a></h2><p>NCronJob&rsquo;s stateless design aligns with cloud-native architectures. Jobs run in-process without external dependencies, making deployments trivial: package the application, deploy it, and scheduling works. There&rsquo;s no database to provision, no connection strings to manage, no external services to monitor.</p><p>This simplicity shines in Kubernetes environments. Deploy multiple replicas of a service, and each runs its own scheduler. For idempotent tasks—cache cleanup, health checks—duplicate execution across replicas is harmless. For tasks requiring exactly-once execution, use external coordination mechanisms like distributed locks (e.g., <code>DistributedLock</code> NuGet package) or delegate scheduling to Kubernetes CronJobs.</p><p>NCronJob&rsquo;s minimal footprint also reduces resource consumption. No database polling, no network I/O for coordination, no persistent storage writes. Jobs execute with negligible overhead, suitable for resource-constrained environments like edge devices or cost-sensitive cloud deployments.</p><h2 id="limitations-and-trade-offs"><a href="/posts/dotnet-job-scheduling-5-ncronjob/#limitations-and-trade-offs" title="Limitations and Trade-offs">Limitations and Trade-offs</a></h2><p>NCronJob&rsquo;s simplicity imposes constraints:</p><p><strong>No persistence</strong>: Jobs don&rsquo;t survive application restarts. If a scheduled task should have executed while the application was down, it won&rsquo;t run upon restart. For workflows requiring guaranteed execution, Hangfire or TickerQ provide persistence.</p><p><strong>No clustering</strong>: Multiple instances execute jobs independently. Without external coordination, duplicate execution occurs. For tasks that must run exactly once across a cluster, use distributed locks or alternative schedulers.</p><p><strong>No dashboard</strong>: Observability relies on application logging and external monitoring tools. Teams needing real-time job visibility should consider Hangfire or TickerQ.</p><p><strong>No automatic retries</strong>: Failed jobs don&rsquo;t retry unless explicitly coded. Hangfire&rsquo;s built-in retry policies and Quartz.NET&rsquo;s misfire handling don&rsquo;t exist in NCronJob.</p><p>These limitations aren&rsquo;t flaws—they&rsquo;re intentional design choices favoring simplicity. For applications where jobs are transient, observability comes from logs, and horizontal scaling doesn&rsquo;t require coordination, NCronJob&rsquo;s constraints are acceptable.</p><h2 id="when-ncronjob-fits"><a href="/posts/dotnet-job-scheduling-5-ncronjob/#when-ncronjob-fits" title="When NCronJob Fits">When NCronJob Fits</a></h2><p>NCronJob excels when:</p><ol><li><p><strong>Stateless deployments are required</strong>: Containerized microservices, serverless functions, or ephemeral environments benefit from zero-dependency scheduling.</p></li><li><p><strong>Jobs are idempotent or non-critical</strong>: Tasks like cache warming, health checks, or metrics collection tolerate occasional duplication or missed executions.</p></li><li><p><strong>Simplicity trumps features</strong>: Teams that value minimal configuration and zero operational overhead over dashboards, clustering, or persistence.</p></li><li><p><strong>Native .NET integration is prioritized</strong>: Developers comfortable with <code>IHostedService</code> and modern .NET conventions find NCronJob&rsquo;s API familiar and consistent.</p></li></ol><p>NCronJob is less suitable when:</p><ul><li><p><strong>Persistence is required</strong>: User-initiated reports, financial workflows, or critical business processes demand database-backed job storage (see Hangfire or TickerQ).</p></li><li><p><strong>Clustering is essential</strong>: Distributed systems needing coordinated job execution across instances should use Quartz.NET or external coordination.</p></li><li><p><strong>Observability and dashboards matter</strong>: Production systems requiring real-time job visibility benefit from Hangfire or TickerQ&rsquo;s monitoring features.</p></li></ul><h2 id="practical-takeaways"><a href="/posts/dotnet-job-scheduling-5-ncronjob/#practical-takeaways" title="Practical Takeaways">Practical Takeaways</a></h2><p>NCronJob occupies the absolute minimalism position in the scheduling spectrum. It delivers cron-based scheduling with zero dependencies, ideal for cloud-native architectures prioritizing statelessness and simplicity.</p><p>Consider NCronJob if:</p><ul><li>Your application runs in Kubernetes, serverless, or containerized environments.</li><li>Background tasks are transient and don&rsquo;t require durability.</li><li>You value zero operational overhead and native .NET integration.</li><li>Jobs are idempotent or tolerate occasional duplication.</li></ul><p>Avoid NCronJob if:</p><ul><li>Jobs must persist across restarts (see Hangfire or TickerQ).</li><li>Horizontal scaling requires coordinated execution (see Quartz.NET).</li><li>You need built-in dashboards or retry policies (see Hangfire).</li></ul><p>The next article explores TickerQ, a framework representing the modern generation of .NET job schedulers. It combines Entity Framework Core persistence with source generation for reflection-free execution, real-time dashboards with SignalR, and async-first design for cloud-native performance—bridging the gap between simplicity and enterprise-grade capabilities.</p></section><section class="giscus"><h2>Comments</h2><aside class="giscus" id="giscus-thread" role="region" aria-label="Comments"></aside></section><script src="https://giscus.app/client.js" data-repo="dailydevops/dailydevops.github.io" data-repo-id="R_kgDOHA8eFg" data-category="Announcements" data-category-id="DIC_kwDOHA8eFs4COIqL" data-mapping="pathname" data-strict="1" data-reactions-enabled="0" data-emit-metadata="0" data-input-position="bottom" data-theme="light" data-lang="en" crossorigin="anonymous" async></script></article><aside class="sidebar divider"><section class="sidecar info" aria-labelledby="info-heading"><header><h2 id="info-heading" class="sr-only">Informations</h2></header><ul role="list"><li role="listitem"><time datetime="2025-12-09T17:00:00+01:00" itemprop="datePublished">Published on 12/9/25 5:00 pm</time></li><li>Read in 8 minutes</li></ul></section><section class="sidecar series" aria-labelledby="series-heading"><header><h2 id="series-heading">Series content</h2></header><nav class="series-nav" role="navigation" aria-label="Series content"><ul role="list"><li role="listitem"><a href="https://daily-devops.net/posts/dotnet-job-scheduling-1-landscape/" title=".NET Job Scheduling — The Landscape" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right" aria-hidden="true"></i>&nbsp;
.NET Job Scheduling — The Landscape</a></li><li role="listitem"><a href="https://daily-devops.net/posts/dotnet-job-scheduling-2-hangfire/" title=".NET Job Scheduling — Hangfire and Persistent Reliability" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right" aria-hidden="true"></i>&nbsp;
.NET Job Scheduling — Hangfire and Persistent Reliability</a></li><li role="listitem"><a href="https://daily-devops.net/posts/dotnet-job-scheduling-3-quartznet/" title=".NET Job Scheduling — Quartz.NET for Enterprise Scale" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right" aria-hidden="true"></i>&nbsp;
.NET Job Scheduling — Quartz.NET for Enterprise Scale</a></li><li role="listitem"><a href="https://daily-devops.net/posts/dotnet-job-scheduling-4-coravel/" title=".NET Job Scheduling — Coravel and Fluent Simplicity" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right" aria-hidden="true"></i>&nbsp;
.NET Job Scheduling — Coravel and Fluent Simplicity</a></li><li role="listitem"><a href="https://daily-devops.net/posts/dotnet-job-scheduling-5-ncronjob/" title=".NET Job Scheduling — NCronJob and Native Minimalism" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right" aria-hidden="true"></i>&nbsp;
.NET Job Scheduling — NCronJob and Native Minimalism</a></li><li role="listitem"><a href="https://daily-devops.net/posts/dotnet-job-scheduling-6-tickerq/" title=".NET Job Scheduling — TickerQ and Modern Architecture" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right" aria-hidden="true"></i>&nbsp;
.NET Job Scheduling — TickerQ and Modern Architecture</a></li><li role="listitem"><a href="https://daily-devops.net/posts/dotnet-job-scheduling-7-comparative-review/" title=".NET Job Scheduling — Choosing the Right Framework" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right" aria-hidden="true"></i>&nbsp;
.NET Job Scheduling — Choosing the Right Framework</a></li></ul></nav></section><section class="sidecar author" aria-labelledby="author-martin-st%C3%BChmer"><header><h2 id="author-martin-st%C3%BChmer"><a href="/authors/martin/" rel="author" title="Martin Stühmer" itemprop="url">Author <span itemprop="name">Martin Stühmer</span></a></h2></header><figure class="round"><picture><img src="https://www.gravatar.com/avatar/6da4a47ff9cc2b750452225fdb2582f7?d=identicon&amp;s=200" alt="Martin Stühmer" loading="lazy" decoding="async" title="Martin Stühmer"></picture></figure><section class="content" itemprop="description">CTO at Integrated Worlds building cloud-native solutions on Azure with modern .NET. Nearly 20 years in .NET from Framework 2.0 to today. Microsoft Certified Trainer, former CGI Director, open-source maintainer. I’ve made every mistake, bet on dead technologies, and learned more from failures than successes. Quality isn’t optional, buzzwords don’t ship features, and experience means knowing what to avoid.</section><a class="link" href="/authors/martin/" rel="author" aria-label="Author Martin Stühmer: Read more"></a></section><section class="sidecar social" aria-labelledby="social-heading"><header><h2 id="social-heading">Social media</h2></header><nav class="social-nav" role="navigation" aria-label="Social media links"><a class="icon bluesky" href="https://bsky.app/profile/samtrion.net" rel="noopener external" aria-label="Follow me on Bluesky" target="_blank"><span class="fa-stack fa-fw fa-1x" aria-hidden="true"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-bluesky fa-stack-1x fa-inverse"></i>
</span></a><a class="icon github" href="https://github.com/samtrion" rel="noopener external" aria-label="Follow me on GitHub" target="_blank"><i class="fa-brands fa-fw fa-github fa-2x" aria-hidden="true"></i></a>
<a class="icon linkedin" href="https://www.linkedin.com/in/martin-stuehmer" rel="noopener external" aria-label="Follow me on LinkedIn" target="_blank"><span class="fa-stack fa-fw fa-1x" aria-hidden="true"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-linkedin-in fa-stack-1x fa-inverse"></i>
</span></a><a class="icon stackoverflow" href="https://stackoverflow.com/users/10574963" rel="noopener external" aria-label="Follow me on Stack Overflow" target="_blank"><span class="fa-stack fa-fw fa-1x" aria-hidden="true"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-stack-overflow fa-stack-1x fa-inverse"></i>
</span></a><a class="icon mail" href="mailto:martin@daily-devops.net" aria-label="Contact me by e-mail" target="_blank"><span class="fa-stack fa-fw fa-1x" aria-hidden="true"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
</span></a><a class="icon feed" href="/authors/martin/feed.rss" aria-label="My RSS feed" target="_blank"><span class="fa-stack fa-fw fa-1x" aria-hidden="true"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></nav></section><section class="sidecar share" aria-labelledby="share-heading"><header><h2 id="share-heading">Share this content</h2></header><a class="icon linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fdaily-devops.net%2fposts%2fdotnet-job-scheduling-5-ncronjob%2f&text=.NET%20Job%20Scheduling%20%e2%80%94%20NCronJob%20and%20Native%20Minimalism%20%26mdash%3b%20Daily%20DevOps%20%26%20.NET" target="_blank" rel="noopener external" aria-label="Share on LinkedIn" title="Share on LinkedIn" target="_blank"><i class="fa-brands fa-fw fa-linkedin-in fa-2x"></i></a>
<a class="icon bluesky" href="https://bsky.app/intent/compose?text=.NET%20Job%20Scheduling%20%e2%80%94%20NCronJob%20and%20Native%20Minimalism%20%26mdash%3b%20Daily%20DevOps%20%26%20.NET%20https%3a%2f%2fdaily-devops.net%2fposts%2fdotnet-job-scheduling-5-ncronjob%2f" target="_blank" rel="noopener external" aria-label="Share on Bluesky" title="Share on Bluesky" target="_blank"><i class="fa-brands fa-fw fa-bluesky fa-2x"></i></a></section><section class="sidecar tags" aria-labelledby="tags-heading"><header><h2 id="tags-heading">Tags</h2></header><ul class="tags" role="list"><li class="tag" role="listitem"><a href="/tags/dotnet/" hreflang="en" rel="tag" title=".NET" aria-label=".NET tag"><i class="fas fa-tag" aria-hidden="true"></i>&nbsp;.NET</a></li><li class="tag" role="listitem"><a href="/tags/architecture/" hreflang="en" rel="tag" title="Architecture" aria-label="Architecture tag"><i class="fas fa-tag" aria-hidden="true"></i>&nbsp;Architecture</a></li><li class="tag" role="listitem"><a href="/tags/csharp/" hreflang="en" rel="tag" title="C#" aria-label="C# tag"><i class="fas fa-tag" aria-hidden="true"></i>&nbsp;C#</a></li><li class="tag" role="listitem"><a href="/tags/nuget/" hreflang="en" rel="tag" title="NuGet" aria-label="NuGet tag"><i class="fas fa-tag" aria-hidden="true"></i>&nbsp;NuGet</a></li><li class="tag" role="listitem"><a href="/tags/softwareengineering/" hreflang="en" rel="tag" title="Software Engineering" aria-label="Software Engineering tag"><i class="fas fa-tag" aria-hidden="true"></i>&nbsp;Software Engineering</a></li></ul></section><section class="sidecar links" aria-labelledby="links-heading"><header><h2 id="links-heading">Additional links</h2></header><nav class="links-nav" role="navigation" aria-label="Additional links"><ul role="list"><li role="listitem"><a href="https://github.com/NCronJob-Dev/NCronJob" title="NCronJob Documentation" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right" aria-hidden="true"></i>&nbsp;
NCronJob Documentation</a></li><li role="listitem"><a href="https://github.com/NCronJob-Dev/NCronJob" title="NCronJob on GitHub" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right" aria-hidden="true"></i>&nbsp;
NCronJob on GitHub</a></li></ul></nav></section><section class="sidecar related" aria-labelledby="related-heading"><header><h2 id="related-heading">Related content</h2></header><article class="post"><figure class="square"><picture><source srcset="/images/nuget-scheduler-80x80.webp?v=4083deb780fd7bbd59972f3da618a0c8" type="image/webp"><source srcset="/images/nuget-scheduler-80x80.png?v=21983cb7d1aaee6a20b10806f639db1c" type="image/png"><img src="/images/nuget-scheduler.png?v=4159bfd7c08b58b0fc741782fe532741" alt=".NET Job Scheduling — Coravel and Fluent Simplicity" loading="lazy" decoding="async" title=".NET Job Scheduling — Coravel and Fluent Simplicity"></picture></figure><header><h2><a href="/posts/dotnet-job-scheduling-4-coravel/" rel="bookmark">.NET Job Scheduling — Coravel and Fluent Simplicity</a></h2></header><section class="content" role="region">Coravel prioritizes developer velocity with fluent APIs, zero infrastructure, and integrated features like queuing and caching.
Understand when convenience and rapid iteration trump persistence and clustering for practical application development.</section></article><article class="post"><figure class="square"><picture><source srcset="/images/nuget-scheduler-80x80.webp?v=4083deb780fd7bbd59972f3da618a0c8" type="image/webp"><source srcset="/images/nuget-scheduler-80x80.png?v=21983cb7d1aaee6a20b10806f639db1c" type="image/png"><img src="/images/nuget-scheduler.png?v=4159bfd7c08b58b0fc741782fe532741" alt=".NET Job Scheduling — Hangfire and Persistent Reliability" loading="lazy" decoding="async" title=".NET Job Scheduling — Hangfire and Persistent Reliability"></picture></figure><header><h2><a href="/posts/dotnet-job-scheduling-2-hangfire/" rel="bookmark">.NET Job Scheduling — Hangfire and Persistent Reliability</a></h2></header><section class="content" role="region">Hangfire combines persistent job storage, automatic retries, and real-time monitoring to simplify background processing.
Learn when database-backed reliability matters and how Hangfire scales from single instances to distributed workers.</section></article><article class="post"><figure class="square"><picture><source srcset="/images/nuget-scheduler-80x80.webp?v=4083deb780fd7bbd59972f3da618a0c8" type="image/webp"><source srcset="/images/nuget-scheduler-80x80.png?v=21983cb7d1aaee6a20b10806f639db1c" type="image/png"><img src="/images/nuget-scheduler.png?v=4159bfd7c08b58b0fc741782fe532741" alt=".NET Job Scheduling — Quartz.NET for Enterprise Scale" loading="lazy" decoding="async" title=".NET Job Scheduling — Quartz.NET for Enterprise Scale"></picture></figure><header><h2><a href="/posts/dotnet-job-scheduling-3-quartznet/" rel="bookmark">.NET Job Scheduling — Quartz.NET for Enterprise Scale</a></h2></header><section class="content" role="region">Quartz.NET provides advanced scheduling semantics, database-backed clustering, and flexible storage for systems demanding complex workflows.
Understand when enterprise features justify operational complexity and how Quartz.NET scales across distributed deployments.</section></article></section></aside><nav class="pager" aria-label="Article navigation" role="navigation"><a class="next" href="/posts/aks-network-policies-zero-trust/" rel="next" aria-label="Next: AKS Network Policies: The Security Layer Your Cluster Is Missing"><span class="sub"><i class="fas fa-backward" aria-hidden="true"></i>&emsp;<span class="sr-only">Next</span></span><p class="title">AKS Network Policies: The Security Layer Your Cluster Is Missing</p></a><a class="prev" href="/posts/dotnet-job-scheduling-4-coravel/" rel="prev" aria-label="Previous: .NET Job Scheduling — Coravel and Fluent Simplicity"><span class="sub"><span class="sr-only">Previous</span>&emsp;<i class="fas fa-forward" aria-hidden="true"></i></span><p class="title">.NET Job Scheduling — Coravel and Fluent Simplicity</p></a></nav></main><footer class="footer"><div class="divider"></div><nav><ul class="navigation"><li><a href="/tags/">Tags</a></li><li><a href="/legal-notice/">Legal notice</a></li></ul></nav><div class="copyright">&copy; 2023 - 2026 Daily DevOps & .NET</div></footer><script defer src="/js/below.min.a6ce9164454b6077f17ae856f280442d9f3a1e21f06189f71c21f75144b22a0c8cf32bafd61d440e9d90ca02bf738b6a8ef19f5ec20285d8ca574f98c91ebaf2.js" integrity="sha512-ps6RZEVLYHfxeuhW8oBELZ86HiHwYYn3HCH3UUSyKgyM8yuv1h1EDp2QygK/c4tqjvGfXsIChdjKV0+YyR668g==" crossorigin="anonymous"></script><img class="vgwort" src="https://vg05.met.vgwort.de/na/7dc345c91b724f14b83bd3040a867799" width="1" height="1" alt="VG Wort" title="VG Wort"></body></html>