<!doctype html><html class="no-js" lang="en" dir="ltr"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="theme-color" content="#15a"><title>Why Your Logging Strategy Fails in Production — Daily DevOps & .NET</title><meta name="description" content="Let me tell you what I&rsquo;ve learned over the years from watching teams deploy logging strategies that looked great on paper and failed spectacularly at 3 …"><meta name="twitter:description" property="og:description" content="Let me tell you what I&rsquo;ve learned over the years from watching teams deploy logging strategies that looked great on paper and failed spectacularly at 3 …"><meta name="author" content="Martin Stühmer"><link rel="icon" href="/logo.svg?v=b9e294dc5c6fa04439c8c803d8e981a9" sizes="any" type="image/svg+xml"><meta name="twitter:title" property="og:title" content="Why Your Logging Strategy Fails in Production — Daily DevOps & .NET"><meta property="og:updated_time" content="2025-12-23T17:06:16+01:00"><meta property="article:modified_time" content="2025-12-23T17:06:16+01:00"><meta property="article:published_time" content="2025-12-23T17:00:00+01:00"><meta property="og:type" content="article"><meta property="og:site_name" content="Daily DevOps & .NET"><meta property="og:url" content="https://daily-devops.net/posts/dotnet-advanced-logging/"><meta property="og:locale" content="en_US"><meta name="twitter:card" content="summary_large_image"><meta property="og:image" name="twitter:image" content="https://daily-devops.net/images/observability-1200x630.webp?v=5d7913e0bf4a9a2de3abe4a5d041b1c1"><meta property="og:image:secure_url" content="https://daily-devops.net/images/observability-1200x630.webp?v=5d7913e0bf4a9a2de3abe4a5d041b1c1"><meta property="og:image:alt" name="twitter:image:alt" content="Why Your Logging Strategy Fails in Production"><meta property="og:image:type" content="image/webp"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta property="og:image" name="twitter:image" content="https://daily-devops.net/images/observability-1200x630.png?v=2356dea6598e17c3812aad6794fbdb4f"><meta property="og:image:secure_url" content="https://daily-devops.net/images/observability-1200x630.png?v=2356dea6598e17c3812aad6794fbdb4f"><meta property="og:image:alt" name="twitter:image:alt" content="Why Your Logging Strategy Fails in Production"><meta property="og:image:type" content="image/png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><link rel="dns-prefetch" href="https://www.clarity.ms"><link rel="preconnect" href="https://www.clarity.ms" crossorigin><link rel="stylesheet" href="/css/style.min.0a82b1a011c427b8ad7101f4d2af27d8fdb035d1938344df11bd53b8ee18381e7feaff6dda5dc3769214cc3fd8070373bdaf19c5e92f9a772e2769a03ac862cc.css" integrity="sha512-CoKxoBHEJ7itcQH00q8n2P2wNdGTg0TfEb1TuO4YOB5/6v9t2l3DdpIUzD/YBwNzva8ZxekvmncuJ2mgOshizA==" crossorigin="anonymous"><link rel="alternate" href='https://daily-devops.net/posts/dotnet-advanced-logging/' hreflang="x-default" title="Why Your Logging Strategy Fails in Production &mdash; Daily DevOps & .NET"><link rel="canonical" href="https://daily-devops.net/posts/dotnet-advanced-logging/" hreflang="en-us" title="Why Your Logging Strategy Fails in Production &mdash; Daily DevOps & .NET"><link rel="home" href="https://daily-devops.net/" hreflang="en-us" title="Daily DevOps & .NET"><link rel="next" href="https://daily-devops.net/posts/dotnet-10-cli-devops/" hreflang="en-us" title=".NET CLI 10 – Microsoft Finally Realizes DevOps Exists"><link rel="prev" href="https://daily-devops.net/posts/dotnet-cli-expanding-scope-autocomplete/" hreflang="en-us" title="Stop Typing: The .NET CLI Tab Completion You've Been Missing"><link rel="author" href="https://daily-devops.net/authors/martin/" hreflang="en-us" title="Martin Stühmer &mdash; Daily DevOps & .NET"><meta name="giscus:backlink" content="https://daily-devops.net/posts/dotnet-advanced-logging/"><script defer src="/js/above.min.cb42b2c9a453e49e278326637d72d2f01e7f32e3f91e9cdde8fb587793d05514efd2f5cc5021c9658ca0f73876dbdcd1f7cb4a37c0bebc9df01110926b6d7cba.js" integrity="sha512-y0KyyaRT5J4ngyZjfXLS8B5/MuP5Hpzd6PtYd5PQVRTv0vXMUCHJZYyg9zh229zR98tKN8C+vJ3wERCSa218ug==" crossorigin="anonymous"></script><script type="text/javascript">(function(e,t,n,s,o,i,a){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)},i=t.createElement(s),i.async=1,i.src="https://www.clarity.ms/tag/"+o,a=t.getElementsByTagName(s)[0],a.parentNode.insertBefore(i,a)})(window,document,"clarity","script","o0pr4n9gg3")</script></head><body class="container"><header class="header"><a class="logo" href="/" title="Daily DevOps & .NET" rel="home"><figure class="page-logo"><picture><img src="/logo.svg?v=b9e294dc5c6fa04439c8c803d8e981a9" alt="Daily DevOps & .NET" title="Daily DevOps & .NET"></picture></figure><span class="title">Daily DevOps & .NET</span></a><nav class="menu"><button class="burger" aria-haspopup="true" aria-expanded="false" tabindex="0">
<i class="fas fa-burger"></i></button><ul class="navigation"><li class="active"><a href="/posts/">Posts</a></li><li><a href="/authors/">About us</a></li></ul></nav><div class="divider"></div></header><main class="body"><figure class="hero"><picture><source srcset="/images/observability-544x136.webp?v=7cf397bcd6eb1befe09cc09b69915a11" type="image/webp" media="(max-width: 575.98px)"><source srcset="/images/observability-544x136.png?v=387efa09641fb1a916f8fa38a22befd4" type="image/png" media="(max-width: 575.98px)"><source srcset="/images/observability-672x168.webp?v=d4865874889ffd9e2a4218f0c34709a3" type="image/webp" media="(max-width: 767.98px)"><source srcset="/images/observability-672x168.png?v=4f22340b42ca04e05c6eea2933ba725b" type="image/png" media="(max-width: 767.98px)"><source srcset="/images/observability-896x224.webp?v=ac5ffaf8dfb009bc6644580724c0f23a" type="image/webp" media="(max-width: 991.98px)"><source srcset="/images/observability-896x224.png?v=243e18dd82b3f8a7877eda0e5e66a07b" type="image/png" media="(max-width: 991.98px)"><source srcset="/images/observability-1104x276.webp?v=f7d55df8ce07aebadc546ab493699e1d" type="image/webp" media="(max-width: 1199.98px)"><source srcset="/images/observability-1104x276.png?v=992656b3921c66bf1e2a8a7dc695cd2a" type="image/png" media="(max-width: 1199.98px)"><source srcset="/images/observability-1444x361.webp?v=7d824522f01327afde55745bd5fe9669" type="image/webp"><source srcset="/images/observability-1444x361.png?v=3c6141d2042c68b7567192800811bbd2" type="image/png"><img src="/images/observability.png?v=48acbd668436dc9dd3287b4ec5564639" alt="Why Your Logging Strategy Fails in Production" loading="lazy" decoding="async" title="Why Your Logging Strategy Fails in Production"></picture></figure><article class="post"><header><h1>Why Your Logging Strategy Fails in Production</h1></header><section class="content"><p>Let me tell you what I&rsquo;ve learned over the years from watching teams deploy logging strategies that looked great on paper and failed spectacularly at 3 AM when production burned.</p><p>It&rsquo;s not that they didn&rsquo;t know the theory. They&rsquo;d read the Azure documentation. They&rsquo;d seen the structured logging samples. They&rsquo;d studied distributed tracing. The real problem was different: they knew <em>what</em> to do but had no idea <em>why</em> it mattered until production broke catastrophically.</p><p>This article isn&rsquo;t about generic &ldquo;best practices&rdquo; or theoretical frameworks. Instead, it&rsquo;s about the specific, concrete ways logging strategies fail in real production systems—why teams log things that don&rsquo;t actually help, miss logging things that critically do, and build expensive observability infrastructure that doesn&rsquo;t deliver when it matters most.</p><p>And I&rsquo;m quite confident that your team is already doing at least two of these things right now.</p><h2 id="the-core-problem-logging-isnt-about-logging"><a href="/posts/dotnet-advanced-logging/#the-core-problem-logging-isnt-about-logging" title="The Core Problem: Logging Isn&rsquo;t About Logging">The Core Problem: Logging Isn&rsquo;t About Logging</a></h2><p>Here&rsquo;s the fundamental issue: most teams approach logging in a fundamentally backward way. They start by asking themselves: &ldquo;What should we log?&rdquo;</p><p>That&rsquo;s completely wrong. The right question—the one that changes everything—is: &ldquo;What information do we absolutely need to diagnose a production failure when everything is burning?&rdquo;</p><p>Because logging isn&rsquo;t a feature. It&rsquo;s insurance. And like all insurance, you want to pay the minimum premium for maximum coverage. You don&rsquo;t insure against every possible outcome; you insure against the catastrophic ones.</p><h2 id="anti-pattern-1-logging-everything-just-in-case"><a href="/posts/dotnet-advanced-logging/#anti-pattern-1-logging-everything-just-in-case" title="Anti-Pattern 1: Logging Everything &ldquo;Just in Case&rdquo;">Anti-Pattern 1: Logging Everything &ldquo;Just in Case&rdquo;</a></h2><p>I&rsquo;ve seen applications log 50+ MB per request. Developers reasoned with apparent logic: &ldquo;More data = better debugging.&rdquo;</p><p>This is not just wrong. It&rsquo;s catastrophically wrong. And I can prove it with concrete math and real-world consequences.</p><p><strong>The Reality of Excessive Logging</strong></p><p>Let&rsquo;s walk through a concrete example. Consider a typical e-commerce order processing request that touches multiple services. A well-intentioned developer adds &ldquo;detailed diagnostic logging&rdquo; at every single step—serializing objects, logging variable states, capturing full request/response payloads. It seems reasonable. It looks thorough. It feels safe.</p><p>Then production hits real load. Assume 100 requests per second, each with 5 MB of unfiltered diagnostic data. That&rsquo;s 500 MB per second of logs flowing into your systems. Your log ingestion pipeline starts struggling. You&rsquo;re either dropping logs or compressing aggressively (and losing critical detail). Your monthly storage bill—depending on your tool and retention policy—can easily escalate from a comfortable $200 to several thousand dollars. The actual impact varies depending on your setup: Application Insights charges per GB ingested, Datadog per host/span volume, Elasticsearch per GB stored. It&rsquo;s not always catastrophic, but it&rsquo;s significant enough to force painful cost-cutting decisions.</p><p>But more importantly than cost, here&rsquo;s what actually happens in practice:</p><ol><li><strong>Search becomes genuinely frustrating.</strong> With gigabytes of noise, finding a specific error means sifting through thousands of irrelevant entries. A query for &ldquo;payment timeout&rdquo; returns 500 results. Which one is actually yours? You don&rsquo;t know.</li><li><strong>Logs stop being useful entirely.</strong> Not because they&rsquo;re stored badly, but because finding signal in the noise takes longer than just restarting the service and hoping it works. So teams gradually stop using logs for diagnosis and instead use luck.</li><li><strong>Real problems hide effectively.</strong> The actual error is there somewhere, buried in noise about every intermediate step, every variable assignment, every function entry. By the time you find it, the incident is already over and customers are angry.</li><li><strong>You&rsquo;re paying for data nobody uses.</strong> Not $13,000/day in runaway costs, but definitely enough to notice and enough to make management ask questions.</li></ol><p>This is exactly what happens when you optimize for <em>completeness</em> instead of <em>signal</em>.</p><p><strong>The solution is surprisingly simple:</strong> Log only what you&rsquo;d actually need to diagnose a failure. Not what <em>might</em> be useful someday. Not &ldquo;this function was called.&rdquo; Not &ldquo;this variable is 42.&rdquo; Only things that directly help answer: &ldquo;Why did this critical operation fail?&rdquo;</p><p>In concrete terms: when an order fails, you truly need to know <em>what</em> failed and <em>why</em>. Did validation reject it? Did payment timeout? Did the warehouse queue overflow? Did inventory run out? Each failure mode has a completely different cause and a different fix. So you log specifically for those scenarios, not for everything in between.</p><p>A typical refactoring looks like this: instead of logging every intermediate step (retrieved order, started validation, started payment, called warehouse), you log only outcome points (order complete, order failed with specific reason X). This cuts noise by roughly 80% while actually <em>improving</em> diagnostic value. You know what mattered. You can find it in seconds.</p><h2 id="anti-pattern-2-fire-and-forget-observability"><a href="/posts/dotnet-advanced-logging/#anti-pattern-2-fire-and-forget-observability" title="Anti-Pattern 2: Fire-and-Forget Observability">Anti-Pattern 2: Fire-and-Forget Observability</a></h2><p>You&rsquo;ve attended a cloud architecture conference. You heard talks about observability and its importance. You read the Microsoft Learn documentation on Application Insights. You diligently configured it—set up the Azure SDK, added OpenTelemetry, made sure logs flow reliably to the cloud.</p><p>You check the box: &ldquo;Observability: Done.&rdquo; Problem solved, right?</p><p>Then production breaks at 2 AM. You wake up. You go to Application Insights and&mldr; find nothing useful. No signal, just noise. So you deploy a quick fix with logging at DEBUG level. Now you have terabytes of noise flooding in. You restart the service and hope it doesn&rsquo;t happen again. Problem &ldquo;fixed&rdquo; (until it does).</p><p>This pattern happens constantly. Not because Application Insights is fundamentally bad. Not because you&rsquo;re incompetent. But because observability was never actually designed for <em>your specific</em> application and <em>your specific</em> failure modes. You bought expensive tools. You installed them correctly. You patted yourself on the back. Then you walked away without thinking deeply.</p><p>Observability without genuine understanding isn&rsquo;t observability. It&rsquo;s just expensive logging theater—looking good in slides but useless when it matters.</p><p><strong>Real observability requires answering three critical questions:</strong></p><p>First: What are the critical paths in your system? Not every code path. The ones that, if they break, create real incidents and wake people up. In e-commerce: order placement, payment processing, inventory updates. In SaaS: user authentication, data export, billing operations. In APIs: request validation, database queries, external service calls. You need to identify and understand these before you write a single log statement.</p><p>Second: What can go wrong on each of these paths? Not everything theoretically possible. The specific failure modes you&rsquo;ve actually seen in production or can reasonably expect based on your architecture. Payment timeout? Insufficient funds? Database deadlock? API rate limiting? Service unavailable? Malformed request? Rate limit exceeded? Each has a completely different diagnosis path and different fix. So you log for each of these specific scenarios, not for the thousands of things that don&rsquo;t go wrong.</p><p>Third: What minimum information do I need to diagnose each specific failure? Not &ldquo;all the data.&rdquo; Not the entire request. The minimum information that tells you which specific failure mode occurred and <em>why</em>. For a payment timeout, you need: order ID, amount, payment provider, timeout duration, retry count. You don&rsquo;t need the entire customer object serialized. You don&rsquo;t need the full response payload. You need the signal, not the noise.</p><p>Then—and only then—you instrument for exactly those scenarios. Not generically. Specifically and intentionally.</p><p>In practice, this means source-generated log methods (using LoggerMessage) for each specific failure mode. Not generic &ldquo;OrderProcessingStarted&rdquo; and &ldquo;OrderProcessingEnded&rdquo; messages. Instead: &ldquo;PaymentTimeout,&rdquo; &ldquo;PaymentDeclined,&rdquo; &ldquo;WarehouseQueueFull,&rdquo; &ldquo;InventoryInsufficient.&rdquo; Each log message tells you exactly what state the system entered and what concrete cause triggered it.</p><h2 id="anti-pattern-3-logging-without-correlation"><a href="/posts/dotnet-advanced-logging/#anti-pattern-3-logging-without-correlation" title="Anti-Pattern 3: Logging Without Correlation">Anti-Pattern 3: Logging Without Correlation</a></h2><p>A customer reports: &ldquo;My order didn&rsquo;t process.&rdquo; In a microservices architecture, that single request touched four different services. Now you&rsquo;re essentially a detective trying to solve a mystery.</p><p>Without correlation IDs, finding the relevant logs across four different services becomes tedious, frustrating detective work. You search for &ldquo;order timeout&rdquo; and get 6 different orders from across the entire day. Which one is actually theirs? You cross-reference timestamps. You check payment logs. You check warehouse logs. You piece together a story. 30 minutes later, you finally find it. By then, the incident is already over. The customer has called your support team twice. You&rsquo;re exhausted.</p><p>With proper correlation, one single trace ID connects everything together. ASP.NET Core generates this automatically—it&rsquo;s called HttpContext.TraceIdentifier. The same trace ID flows through every log entry for that specific request, across every service it touches. When a customer reports &ldquo;my order didn&rsquo;t process,&rdquo; you search by that one trace ID and see every step: API received it, validation passed, payment service timed out, warehouse was never notified. Done. You understand the entire story in 30 seconds instead of 30 minutes.</p><p>The W3C Trace Context standard makes this correlation work across service boundaries. It&rsquo;s built into ASP.NET Core natively. You get it for free. But there&rsquo;s a crucial requirement: you have to structure your logs so the trace ID is actually queryable—which means using structured logging (key-value pairs, not free-form text blobs).</p><h2 id="anti-pattern-4-logging-performance-secrets"><a href="/posts/dotnet-advanced-logging/#anti-pattern-4-logging-performance-secrets" title="Anti-Pattern 4: Logging Performance Secrets">Anti-Pattern 4: Logging Performance Secrets</a></h2><p>Here&rsquo;s a pattern I&rsquo;ve seen derail production performance more often than most people admit: logging that hurts performance so severely that teams simply disable observability rather than pay the performance cost.</p><p>Your application runs beautifully on your local machine. You ship it to production. Suddenly in production, it feels sluggish. Latency starts climbing. P95 latency goes from 50ms to 200ms. Users complain. You add more logging to debug the slow path. Now it&rsquo;s even slower. Much, much slower. You profile the application and find the surprising culprit: the logging itself is the bottleneck.</p><p>This is the moment most teams give up on observability entirely. &ldquo;It&rsquo;s too expensive,&rdquo; they say. What they really mean: &ldquo;We instrumented it wrong and now we&rsquo;re paying the performance price.&rdquo;</p><p>The culprit: string formatting and object serialization happening automatically regardless of whether anyone is listening. You&rsquo;re serializing objects, building strings, allocating temporary memory—all of it discarded if the log level isn&rsquo;t even enabled. This is particularly insidious because it only hurts production performance (where logging is at higher levels) while looking perfectly fine in local testing (where you control the verbosity level).</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="c1">// KILLER: Always executes expensive work</span>
</span></span><span class="line"><span class="cl"><span class="n">logger</span><span class="p">.</span><span class="n">LogDebug</span><span class="p">(</span><span class="s">&#34;Processing user. FullDetails: {Details}&#34;</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">    <span class="n">JsonConvert</span><span class="p">.</span><span class="n">SerializeObject</span><span class="p">(</span><span class="n">complexUser</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// BETTER: Guards it, but still wasteful</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">logger</span><span class="p">.</span><span class="n">IsEnabled</span><span class="p">(</span><span class="n">LogLevel</span><span class="p">.</span><span class="n">Debug</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="n">logger</span><span class="p">.</span><span class="n">LogDebug</span><span class="p">(</span><span class="s">&#34;Processing user. FullDetails: {Details}&#34;</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">        <span class="n">JsonConvert</span><span class="p">.</span><span class="n">SerializeObject</span><span class="p">(</span><span class="n">complexUser</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// BEST: Source-generated logging—zero overhead when disabled</span>
</span></span><span class="line"><span class="cl"><span class="na">[LoggerMessage(Level = LogLevel.Debug, Message = &#34;Processing user. UserId={UserId}&#34;)]</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kd">partial</span> <span class="k">void</span> <span class="n">ProcessingUser</span><span class="p">(</span><span class="k">this</span> <span class="n">ILogger</span> <span class="n">logger</span><span class="p">,</span> <span class="kt">int</span> <span class="n">userId</span><span class="p">);</span>
</span></span></code></pre></div><p>In production with Debug logging disabled, the first version <em>still executes the expensive serialization anyway</em>. That&rsquo;s performance death by a thousand cuts. The template parser runs. The object is serialized. The memory is allocated. Only <em>then</em> does the code check &ldquo;is debug level enabled?&rdquo; and discard the entire result. Wasted CPU cycles. Wasted memory. And this happens repeated thousands of times per second.</p><p>This is exactly the kind of hidden performance killer that shows up and hurts production but not in load tests. Because load tests usually don&rsquo;t add this kind of logging to their code paths.</p><p><strong>The Solution: Source-Generated Logging</strong></p><p>Source-generated logging (LoggerMessage attribute, .NET 6+) completely flips this on its head. The compiler generates code at build time that knows: &ldquo;this parameter matters, that one doesn&rsquo;t. Here&rsquo;s the most efficient way to capture and format it.&rdquo; No runtime template parsing. No boxing. No wasted string allocation. Zero overhead when disabled.</p><p>A clarification: the performance gain is primarily noticeable in high-frequency logging scenarios (thousands of calls per second). For low-frequency events like error logging or rare business events, the difference is measurable but not dramatic. The real power of LoggerMessage is its consistency across high-volume paths. Also worth noting: LoggerMessage requires <code>partial</code> methods, which means you can&rsquo;t use it everywhere—instance methods on regular classes need to be static partials, which limits where you can apply this pattern.</p><p>I wrote extensively about this pattern in my <a href="/posts/compositeformat-performance-boost/">CompositeFormat article</a>, where I showed concretely how parsing overhead compounds at scale. The same principle applies here: parse once (at compile time), use a thousand times (at runtime). Source-generated logging is the logging equivalent of that core optimization. It delivers measurably better performance. It means measurably lower CPU usage. And the code is even cleaner and more maintainable.</p><h2 id="anti-pattern-5-unstructured-logs-in-structured-systems"><a href="/posts/dotnet-advanced-logging/#anti-pattern-5-unstructured-logs-in-structured-systems" title="Anti-Pattern 5: Unstructured Logs in Structured Systems">Anti-Pattern 5: Unstructured Logs in Structured Systems</a></h2><p>You&rsquo;ve set up Application Insights correctly. You&rsquo;re sending structured logs to the cloud. But then someone does this:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="c1">// DON&#39;T: Free-form text—not queryable or searchable</span>
</span></span><span class="line"><span class="cl"><span class="n">logger</span><span class="p">.</span><span class="n">LogError</span><span class="p">(</span><span class="s">$&#34;Order 12345 failed. Payment service returned 429...&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// DO: Structured data—queryable and analyzable</span>
</span></span><span class="line"><span class="cl"><span class="n">logger</span><span class="p">.</span><span class="n">LogError</span><span class="p">(</span><span class="s">&#34;Payment rate limited. OrderId={OrderId}, StatusCode={StatusCode}&#34;</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">    <span class="n">orderId</span><span class="p">,</span> <span class="n">statusCode</span><span class="p">);</span>
</span></span></code></pre></div><p>The second version is queryable. The first version is just noise that wastes storage.</p><p>Application Insights, Datadog, Elasticsearch—all of these powerful tools only work effectively because logs are structured. When you log unstructured text, you throw away the tool&rsquo;s entire value proposition. You might as well be writing to a flat file somewhere. You&rsquo;ve spent significant money on enterprise observability and gained nothing from it.</p><h2 id="the-practical-path-forward"><a href="/posts/dotnet-advanced-logging/#the-practical-path-forward" title="The Practical Path Forward">The Practical Path Forward</a></h2><p>So how do you actually fix these patterns? The answer isn&rsquo;t more generic best practices. It&rsquo;s not buying more tools. It&rsquo;s building deliberate, intentional, carefully designed observability built specifically for your application.</p><h3 id="step-1-identify-your-critical-paths"><a href="/posts/dotnet-advanced-logging/#step-1-identify-your-critical-paths" title="Step 1: Identify Your Critical Paths">Step 1: Identify Your Critical Paths</a></h3><p>Write down the 3-5 user flows that actually matter in your system. Not every single code path. The ones where failure creates real incidents and angry customers.</p><p>For an e-commerce system: order placement → payment processing → warehouse notification.
For a SaaS platform: user sign-up → authentication → data access → export.
For an API service: request validation → business logic → response serialization → client response.</p><p>You&rsquo;ll complete this exercise in an afternoon or two. It immediately clarifies what&rsquo;s actually important in your system and what you should care about.</p><h3 id="step-2-map-failure-modes"><a href="/posts/dotnet-advanced-logging/#step-2-map-failure-modes" title="Step 2: Map Failure Modes">Step 2: Map Failure Modes</a></h3><p>For each critical path, list concretely what can go wrong. Not everything theoretically possible. The specific failures you&rsquo;ve actually dealt with in production:</p><ul><li>Payment timeout (how long does it take to decide? What&rsquo;s the timeout value?)</li><li>Insufficient funds (is this handled gracefully? Do you notify the user?)</li><li>Service unavailable (do you have fallbacks? Do you retry?)</li><li>Rate limiting (do you respect backoff headers? Do you queue?)</li><li>Invalid input (where&rsquo;s the validation boundary? What gets validated?)</li><li>Database deadlock (how often does it happen? What query triggers it?)</li></ul><p>This exercise takes longer than step one, but it&rsquo;s where the real insight happens. You&rsquo;re not speculating about what <em>could</em> theoretically go wrong. You&rsquo;re building on what actually has gone wrong in production.</p><h3 id="step-3-instrument-deliberately"><a href="/posts/dotnet-advanced-logging/#step-3-instrument-deliberately" title="Step 3: Instrument Deliberately">Step 3: Instrument Deliberately</a></h3><p>Now you log only when something meaningful happens:</p><ul><li>A critical path step completes (success or specific failure)</li><li>An operation enters a retry/fallback state (you&rsquo;re doing something non-standard)</li><li>A threshold is crossed (queue is full, latency exceeds SLA, rate limit triggered, circuit breaker opened)</li></ul><p>Nothing else. Not method entry/exit. Not variable assignments. Not successful intermediate steps that didn&rsquo;t fail. Only things that directly help answer: &ldquo;Why did this critical path fail?&rdquo;</p><h3 id="step-4-make-logs-actionable"><a href="/posts/dotnet-advanced-logging/#step-4-make-logs-actionable" title="Step 4: Make Logs Actionable">Step 4: Make Logs Actionable</a></h3><p>Here&rsquo;s the test: when someone reads a log line at 3 AM during an incident, can they immediately understand what was happening and what went wrong? Or do they need to cross-reference five other services, query the database, check five other log systems, and piece together a story?</p><p>If it&rsquo;s the latter, restructure your log. Make it self-contained. Include the context that matters. Make it so someone can understand what happened without detective work.</p><h3 id="step-5-use-sampling-for-scale"><a href="/posts/dotnet-advanced-logging/#step-5-use-sampling-for-scale" title="Step 5: Use Sampling for Scale">Step 5: Use Sampling for Scale</a></h3><p>You can&rsquo;t keep every single log entry. But you actually don&rsquo;t need to. Use context-aware, intelligent sampling:</p><ul><li>Keep 100% of errors and warnings (these are rare and valuable)</li><li>For information logs, consider adaptive sampling: sample heavily on errors (100%), moderately on warnings (50%), lightly on success paths (5-10%)</li><li>Disable debug logs in production entirely (add them on-demand when troubleshooting a specific incident)</li></ul><p>Important note: Sampling must be consistent across all services in a distributed trace (W3C Trace Context propagates the <code>sampled</code> flag for this reason). If one service samples at 10% and another at 50%, you&rsquo;ll have incomplete and inconsistent traces. Either all services honor the same sampling decision, or you lose correlation.</p><p>With this approach, you might sample 1 out of every 10 successful order completions. But you&rsquo;ll still see 100 order completions per second even with sampling. You see the patterns. You see the anomalies. You catch bugs. And you&rsquo;re not paying for 90% noise.</p><h2 id="real-example-the-safe-approach"><a href="/posts/dotnet-advanced-logging/#real-example-the-safe-approach" title="Real Example: The Safe Approach">Real Example: The Safe Approach</a></h2><p>When you combine all these principles—deliberate instrumentation, source-generated logging, correlation IDs, specific failure modes—the result looks like this:</p><p>You log only when a critical path step completes. If it succeeds, one single log entry confirms it happened. If it fails, you log the specific failure mode (timeout, rate limit, validation error) with enough context to diagnose immediately. You use ActivitySource to track the operation through services. You keep the happy path silent—no noise about intermediate steps that didn&rsquo;t fail.</p><p>Instead of sprawling code with dozens of unnecessary log statements, you have surgical, intentional instrumentation. Each log line earns its place because it answers a specific diagnostic question. You use W3C Trace Context headers (traceparent/tracestate) to correlate across services automatically. The result: when something breaks at 3 AM, you don&rsquo;t sift through chaos. You have a clear narrative: here&rsquo;s what the request tried to do, here&rsquo;s where it failed in which service, here&rsquo;s why. One single trace ID connects everything.</p><h2 id="conclusion-know-why-before-you-know-what"><a href="/posts/dotnet-advanced-logging/#conclusion-know-why-before-you-know-what" title="Conclusion: Know Why Before You Know What">Conclusion: Know Why Before You Know What</a></h2><p>The difference between teams that own production and teams that merely survive it isn&rsquo;t logging volume. It&rsquo;s logging intelligence and intention.</p><p>The teams with genuinely healthy observability don&rsquo;t log more. They log smarter. They understand their failure modes deeply. They instrument not for completeness, but for purpose. They keep logs queryable because they know they&rsquo;ll search them under pressure. They use sampling strategically instead of trying to keep everything.</p><p>Most importantly: they make every log line <em>count</em>. There&rsquo;s no filler. No speculation. No &ldquo;this might be useful someday.&rdquo; Every log line answers a question.</p><p>Meanwhile, other teams are paying extra storage fees for logs nobody reads. They&rsquo;re adding more logging and watching performance tank. They&rsquo;re frustrated because diagnosis takes hours instead of minutes.</p><p>It doesn&rsquo;t have to be this way.</p><p>Start with the hardest question: &ldquo;What would I need to see in a log line to immediately understand why this customer&rsquo;s order failed? Why this API call timed out? Why this background job got stuck?&rdquo;</p><p>Then instrument for exactly that. Nothing more. Nothing less.</p><p>When a bug escapes to production—and it will—you won&rsquo;t be digging through gigabytes of noise hoping to find something relevant. You&rsquo;ll have the signal right there in front of you. You&rsquo;ll see what failed, why it failed, and what the system tried to do about it.</p><p>At 3 AM, when production is burning and everyone is exhausted and frustrated, that&rsquo;s the difference between &ldquo;we found it in minutes and fixed it&rdquo; and &ldquo;we flew blind for hours and lost customers.&rdquo;</p><p>Build for that moment. Your future self will thank you.</p></section><h2>Comments</h2><aside class="giscus"></aside><script src="https://giscus.app/client.js" data-repo="dailydevops/dailydevops.github.io" data-repo-id="R_kgDOHA8eFg" data-category="Announcements" data-category-id="DIC_kwDOHA8eFs4COIqL" data-mapping="pathname" data-strict="1" data-reactions-enabled="0" data-emit-metadata="0" data-input-position="bottom" data-theme="light" data-lang="en" crossorigin="anonymous" async></script></article><aside class="sidebar divider"><section class="sidecar info"><ul><li><time datetime="2025-12-23T17:00:00+01:00">Published on 12/23/25 5:00 pm</time></li><li>Read in 15 minutes</li></ul></section><section class="sidecar author"><header><h2><a href="/authors/martin/" rel="author" title="Martin Stühmer">Author Martin Stühmer</a></h2></header><figure class="round"><picture><img src="https://www.gravatar.com/avatar/6da4a47ff9cc2b750452225fdb2582f7?d=identicon&amp;s=200" alt="Martin Stühmer" loading="lazy" decoding="async" title="Martin Stühmer"></picture></figure><section class="content">Martin is a seasoned software architect and developer based in the Stuttgart region, with more than 15 years of experience in utilizing .NET and Microsoft technologies in his work. His expertise lies in enhancing the quality and performance of development teams, optimizing software solutions for target environments, and maximizing application efficiency. Currently serving as the Director Consulting Services at CGI, he specializes in cloud-native and .NET solutions, while also providing training in cloud and software architecture. Beyond his professional endeavors, Martin actively contributes to open-source communities by offering various NuGet packages. In 2021, he achieved certifications as an IHK instructor and Microsoft certified trainer, furthering his commitment to continuous learning. Additionally, he became a certified trainer for CGI’s Risk and Cost Driven Architecture program in 2022.</section><a class="link" href="/authors/martin/" rel="author" title="Martin Stühmer"></a></section><section class="sidecar social"><header><h2>Social media</h2></header><a class="icon bluesky" href="https://bsky.app/profile/samtrion.net" rel="noopener external" title="Follow me on Bluesky" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-bluesky fa-stack-1x fa-inverse"></i>
</span></a><a class="icon github" href="https://github.com/samtrion" rel="noopener external" title="Follow me on GitHub" target="_blank"><i class="fa-brands fa-fw fa-github fa-2x"></i></a>
<a class="icon linkedin" href="https://www.linkedin.com/in/martin-stuehmer" rel="noopener external" title="Follow me on LinkedIn" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-linkedin-in fa-stack-1x fa-inverse"></i>
</span></a><a class="icon stackoverflow" href="https://stackoverflow.com/users/10574963" rel="noopener external" title="Follow me on Stack Overflow" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-stack-overflow fa-stack-1x fa-inverse"></i>
</span></a><a class="icon mail" href="mailto:martin@daily-devops.net" title="Contact me by e-mail" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
</span></a><a class="icon feed" href="/authors/martin/feed.rss" title="My RSS feed" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></section><section class="sidecar share"><header><h2>Share this content</h2></header><a class="icon linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fdaily-devops.net%2fposts%2fdotnet-advanced-logging%2f&text=Why%20Your%20Logging%20Strategy%20Fails%20in%20Production%20%26mdash%3b%20Daily%20DevOps%20%26%20.NET" target="_blank" rel="noopener external" aria-label="Share on LinkedIn" title="Share on LinkedIn" target="_blank"><i class="fa-brands fa-fw fa-linkedin-in fa-2x"></i></a>
<a class="icon bluesky" href="https://bsky.app/intent/compose?text=Why%20Your%20Logging%20Strategy%20Fails%20in%20Production%20%26mdash%3b%20Daily%20DevOps%20%26%20.NET%20https%3a%2f%2fdaily-devops.net%2fposts%2fdotnet-advanced-logging%2f" target="_blank" rel="noopener external" aria-label="Share on Bluesky" title="Share on Bluesky" target="_blank"><i class="fa-brands fa-fw fa-bluesky fa-2x"></i></a></section><section class="sidecar tags"><header><h2>Tags</h2></header><ul><li class="tag"><a href="/tags/dotnet/" hreflang="en" rel="tag" title=".NET"><i class="fas fa-tag"></i>&nbsp;.NET</a></li><li class="tag"><a href="/tags/architecture/" hreflang="en" rel="tag" title="Architecture"><i class="fas fa-tag"></i>&nbsp;Architecture</a></li><li class="tag"><a href="/tags/bestpractices/" hreflang="en" rel="tag" title="Best Practices"><i class="fas fa-tag"></i>&nbsp;Best Practices</a></li><li class="tag"><a href="/tags/csharp/" hreflang="en" rel="tag" title="C#"><i class="fas fa-tag"></i>&nbsp;C#</a></li><li class="tag"><a href="/tags/cloudnative/" hreflang="en" rel="tag" title="Cloud-Native"><i class="fas fa-tag"></i>&nbsp;Cloud-Native</a></li><li class="tag"><a href="/tags/observability/" hreflang="en" rel="tag" title="Observability"><i class="fas fa-tag"></i>&nbsp;Observability</a></li><li class="tag"><a href="/tags/performance/" hreflang="en" rel="tag" title="Performance"><i class="fas fa-tag"></i>&nbsp;Performance</a></li></ul></section><section class="sidecar related"><header><h2>Related content</h2></header><article class="post"><figure class="square"><picture><source srcset="/images/timing-dotnet10-80x80.webp?v=b91fb425a7a9a85c6fba1e865d7ee651" type="image/webp"><source srcset="/images/timing-dotnet10-80x80.png?v=d6e1585b70c7cd2d5976a6e321556843" type="image/png"><img src="/images/timing-dotnet10.png?v=8a9aad349f586d3bcaeaf9c95a6d62b5" alt=".NET 10: Timing Is the New Technical Debt
" loading="lazy" decoding="async" title=".NET 10: Timing Is the New Technical Debt
"></picture></figure><header><h2><a href="/posts/timing-is-the-new-technical-debt/" rel="bookmark">.NET 10: Timing Is the New Technical Debt</a></h2></header><section class="content">2025 reshapes the .NET ecosystem with faster release cycles and shared responsibility. Discover why migrating to .NET 10 by Q1 2026 — and supporting your dependencies — turns timing into sustainable ROI.</section></article><article class="post"><figure class="square"><picture><source srcset="/images/dotnet-80x80.webp?v=3d56eea0243ac6549bb0ce626059527e" type="image/webp"><source srcset="/images/dotnet-80x80.png?v=98376a285f07b0021d3118e0523d147a" type="image/png"><img src="/images/dotnet.png?v=8142ec8a038ba14415ff0d0434c78182" alt=".NET 10: Boring by Design, Reliable by Default
" loading="lazy" decoding="async" title=".NET 10: Boring by Design, Reliable by Default
"></picture></figure><header><h2><a href="/posts/dotnet-10-released/" rel="bookmark">.NET 10: Boring by Design, Reliable by Default</a></h2></header><section class="content"><p><strong>Microsoft wants you to believe .NET 10 is boring. They&rsquo;re right — and that&rsquo;s the best news we&rsquo;ve had in years.</strong></p><p>.NET 10 is here, and for once, Microsoft didn&rsquo;t oversell it. LTS support through 2028, JIT improvements that actually matter, and C# 14 features that won&rsquo;t rewrite your architecture. Here&rsquo;s what you need to know before migrating.</p></section></article><article class="post"><figure class="square"><picture><source srcset="/images/dotnet-paradox-80x80.webp?v=6f47a5c4b816eeaaaa98b8171e33e7d6" type="image/webp"><source srcset="/images/dotnet-paradox-80x80.png?v=29e2f5a0c373c3060fc6fc04c3fd3c63" type="image/png"><img src="/images/dotnet-paradox.png?v=fab3db4941c79e6e7ad156d66492c87b" alt=".NET 10 and the Release Cycle Paradox" loading="lazy" decoding="async" title=".NET 10 and the Release Cycle Paradox"></picture></figure><header><h2><a href="/posts/dotnet-10-release-cycle-paradox/" rel="bookmark">.NET 10 and the Release Cycle Paradox</a></h2></header><section class="content"><p>.NET’s yearly rhythm has become a symbol of stability — yet also a source of pressure.
The <strong>release cycle paradox</strong> describes the tension between predictability and exhaustion: a release schedule that keeps the ecosystem healthy, but teams constantly catching up.</p><p>With .NET 10 on the horizon, developers must learn to navigate this rhythm rather than fight it.</p></section></article></section></aside><nav class="pager"><a class="next" href="/posts/dotnet-10-cli-devops/" title=".NET CLI 10 – Microsoft Finally Realizes DevOps Exists" rel="next"><span class="sub"><i class="fas fa-backward"></i>&emsp;Next</span><p class="title">.NET CLI 10 – Microsoft Finally Realizes DevOps Exists</p></a><a class="prev" href="/posts/dotnet-cli-expanding-scope-autocomplete/" title="Stop Typing: The .NET CLI Tab Completion You've Been Missing" rel="prev"><span class="sub">Previous&emsp;<i class="fas fa-forward"></i></span><p class="title">Stop Typing: The .NET CLI Tab Completion You've Been Missing</p></a></nav></main><footer class="footer"><div class="divider"></div><nav><ul class="navigation"><li><a href="/tags/">Tags</a></li><li><a href="/legal-notice/">Legal notice</a></li></ul></nav><div class="copyright">&copy; 2023 - 2025 Daily DevOps & .NET</div></footer><script defer src="/js/below.min.a6ce9164454b6077f17ae856f280442d9f3a1e21f06189f71c21f75144b22a0c8cf32bafd61d440e9d90ca02bf738b6a8ef19f5ec20285d8ca574f98c91ebaf2.js" integrity="sha512-ps6RZEVLYHfxeuhW8oBELZ86HiHwYYn3HCH3UUSyKgyM8yuv1h1EDp2QygK/c4tqjvGfXsIChdjKV0+YyR668g==" crossorigin="anonymous"></script><img class="vgwort" src="https://vg06.met.vgwort.de/na/81fd953db53b4f85a9adebcc713d2e1b" width="1" height="1" alt="VG Wort" title="VG Wort"></body></html>