<!doctype html><html class="no-js" lang="en" dir="ltr"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="theme-color" content="#15a"><title>PackageDownload: NuGet's Forgotten Power Tool
— Daily DevOps & .NET</title><meta name="description" content="PackageDownload arrived in NuGet 4.8 to solve a niche but genuine problem: downloading packages without adding assembly references. It works. But its version …"><meta name="twitter:description" property="og:description" content="PackageDownload arrived in NuGet 4.8 to solve a niche but genuine problem: downloading packages without adding assembly references. It works. But its version …"><meta name="author" content="Martin Stühmer"><link rel="icon" href="/logo.svg?v=b9e294dc5c6fa04439c8c803d8e981a9" sizes="any" type="image/svg+xml"><meta name="twitter:title" property="og:title" content="PackageDownload: NuGet's Forgotten Power Tool
 — Daily DevOps & .NET"><meta property="og:updated_time" content="2026-01-05T12:05:23+01:00"><meta property="article:modified_time" content="2026-01-05T12:05:23+01:00"><meta property="article:published_time" content="2025-10-29T18:00:00+01:00"><meta property="og:type" content="article"><meta property="og:site_name" content="Daily DevOps & .NET"><meta property="og:url" content="https://daily-devops.net/posts/nuget-packagedownload-functionality/"><meta property="og:locale" content="en"><meta name="twitter:card" content="summary_large_image"><meta property="og:image" name="twitter:image" content="https://daily-devops.net/images/package-manager-1200x630.webp?v=bac7dfdc3fd828807ed592e8f734c2ff"><meta property="og:image:secure_url" content="https://daily-devops.net/images/package-manager-1200x630.webp?v=bac7dfdc3fd828807ed592e8f734c2ff"><meta property="og:image:alt" name="twitter:image:alt" content="PackageDownload: NuGet's Forgotten Power Tool
"><meta property="og:image:type" content="image/webp"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta property="og:image" name="twitter:image" content="https://daily-devops.net/images/package-manager-1200x630.png?v=137b5da8870ec4d2da820a5eeed2f7f1"><meta property="og:image:secure_url" content="https://daily-devops.net/images/package-manager-1200x630.png?v=137b5da8870ec4d2da820a5eeed2f7f1"><meta property="og:image:alt" name="twitter:image:alt" content="PackageDownload: NuGet's Forgotten Power Tool
"><meta property="og:image:type" content="image/png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><link rel="dns-prefetch" href="https://www.clarity.ms"><link rel="preconnect" href="https://www.clarity.ms" crossorigin><link rel="stylesheet" href="/css/style.min.0b2ef4378cd908eb695017aaa74603d244ff2b38c8068b4b51d76cad830c8ee5e3a40b67ab5b860a542c8bae73d8ba90cfbe9249b59c733a50de74cc32af818a.css" integrity="sha512-Cy70N4zZCOtpUBeqp0YD0kT/KzjIBotLUddsrYMMjuXjpAtnq1uGClQsi65z2LqQz76SSbWcczpQ3nTMMq+Big==" crossorigin="anonymous"><link rel="alternate" href='https://daily-devops.net/posts/nuget-packagedownload-functionality/' hreflang="x-default" title="PackageDownload: NuGet's Forgotten Power Tool
 &mdash; Daily DevOps & .NET"><link rel="alternate" href="https://daily-devops.net/en/posts/nuget-packagedownload-functionality" hreflang="en" title="PackageDownload: NuGet's Forgotten Power Tool
 &mdash; Daily DevOps & .NET"><link rel="canonical" href="https://daily-devops.net/posts/nuget-packagedownload-functionality/" hreflang="en" title="PackageDownload: NuGet's Forgotten Power Tool
 &mdash; Daily DevOps & .NET"><link rel="home" href="https://daily-devops.net/" hreflang="en" title="Daily DevOps & .NET"><link rel="next" href="https://daily-devops.net/posts/tests-are-lying/" hreflang="en" title="Your Tests Are Lying — Mutation Testing in .NET"><link rel="prev" href="https://daily-devops.net/posts/netevolve-healthchecks/" hreflang="en" title="Configuration-First Health Checks for Modern .NET"><link rel="author" href="https://daily-devops.net/authors/martin/" hreflang="en" title="Martin Stühmer &mdash; Daily DevOps & .NET"><meta name="giscus:backlink" content="https://daily-devops.net/posts/nuget-packagedownload-functionality/"><script defer src="/js/above.min.cb42b2c9a453e49e278326637d72d2f01e7f32e3f91e9cdde8fb587793d05514efd2f5cc5021c9658ca0f73876dbdcd1f7cb4a37c0bebc9df01110926b6d7cba.js" integrity="sha512-y0KyyaRT5J4ngyZjfXLS8B5/MuP5Hpzd6PtYd5PQVRTv0vXMUCHJZYyg9zh229zR98tKN8C+vJ3wERCSa218ug==" crossorigin="anonymous"></script><script type="text/javascript">(function(e,t,n,s,o,i,a){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)},i=t.createElement(s),i.async=1,i.src="https://www.clarity.ms/tag/"+o,a=t.getElementsByTagName(s)[0],a.parentNode.insertBefore(i,a)})(window,document,"clarity","script","o0pr4n9gg3")</script><script src="https://analytics.ahrefs.com/analytics.js" data-key="C5Iv+2Rb9el+FLJqVw2QGA" async></script></head><body class="container"><header class="header"><a class="logo" href="/" title="Daily DevOps & .NET" rel="home"><figure class="page-logo"><picture><img src="/logo.svg?v=b9e294dc5c6fa04439c8c803d8e981a9" alt="Daily DevOps & .NET" title="Daily DevOps & .NET"></picture></figure><span class="title">Daily DevOps & .NET</span></a><nav class="menu" aria-label="Main navigation"><button class="burger" type="button" aria-haspopup="menu" aria-expanded="false" aria-label="Toggle menu">
<i class="fas fa-burger" aria-hidden="true"></i></button><ul class="navigation"><li class="active"><a href="/posts/">Posts</a></li><li><a href="/authors/">About us</a></li></ul></nav><div class="divider"></div></header><main class="body"><figure class="hero"><picture><source srcset="/images/package-manager-544x136.webp?v=eea7a32bd5cb677236c3399bd984eee9" type="image/webp" media="(max-width: 575.98px)"><source srcset="/images/package-manager-544x136.png?v=52ae00f679a1dfb0e920e029e40c908f" type="image/png" media="(max-width: 575.98px)"><source srcset="/images/package-manager-672x168.webp?v=1b2e8ab439b5712e7b071f24400b97f8" type="image/webp" media="(max-width: 767.98px)"><source srcset="/images/package-manager-672x168.png?v=8afeeabc7880c6c880ae5d7f6e438284" type="image/png" media="(max-width: 767.98px)"><source srcset="/images/package-manager-896x224.webp?v=61941fa568d820ed68a8696d95af512c" type="image/webp" media="(max-width: 991.98px)"><source srcset="/images/package-manager-896x224.png?v=360fed6f8012ba6ec551b107ccccb7b2" type="image/png" media="(max-width: 991.98px)"><source srcset="/images/package-manager-1104x276.webp?v=1fc61c2b00c83115c4c9ed0149b25669" type="image/webp" media="(max-width: 1199.98px)"><source srcset="/images/package-manager-1104x276.png?v=df66f43d699d849aaaa61eee29b1564f" type="image/png" media="(max-width: 1199.98px)"><source srcset="/images/package-manager-1444x361.webp?v=aa15f6b58b419e16a771122b7e5486e9" type="image/webp"><source srcset="/images/package-manager-1444x361.png?v=053b83363623fe9b40e197517a80fd42" type="image/png"><img src="/images/package-manager.png?v=19ac8eda9b0cc3394a0da24151d44079" alt="PackageDownload: NuGet's Forgotten Power Tool
" loading="lazy" decoding="async" title="PackageDownload: NuGet's Forgotten Power Tool
"></picture></figure><article class="post"><header><h1>PackageDownload: NuGet&rsquo;s Forgotten Power Tool</h1></header><section class="content" role="region"><p>NuGet has been the backbone of .NET dependency management for over a decade. It&rsquo;s mature. It&rsquo;s reliable. It mostly works.</p><p>And then there&rsquo;s <strong>PackageDownload</strong> — a feature introduced in 2018 that solves a legitimate problem, but in a way that makes you wonder whether anyone thought about how it would integrate with the rest of the ecosystem.</p><p>PackageDownload lets you download NuGet packages to your build environment <strong>without adding assembly references</strong>. That&rsquo;s useful. It&rsquo;s not glamorous, but it fills a gap. The problem is how it does it: with mandatory version range syntax, zero integration with Central Package Management, and documentation that assumes you already know what you&rsquo;re doing.</p><p>This article isn&rsquo;t about celebrating NuGet. It&rsquo;s about understanding PackageDownload — what it does well, where it fails, and why those failures matter.</p><h2 id="what-packagedownload-actually-does"><a href="/posts/nuget-packagedownload-functionality/#what-packagedownload-actually-does" title="What PackageDownload Actually Does">What PackageDownload Actually Does</a></h2><p>When you add a package reference with <code>&lt;PackageReference></code>, NuGet does two things simultaneously: it downloads the package to your local cache and adds its assemblies to your project&rsquo;s compilation and runtime dependencies. That&rsquo;s fine for libraries, frameworks, and application dependencies. But what if you need the package contents during the build process without those assemblies polluting your dependency graph?</p><p>That&rsquo;s where PackageDownload comes in.</p><h3 id="the-basic-syntax"><a href="/posts/nuget-packagedownload-functionality/#the-basic-syntax" title="The Basic Syntax">The Basic Syntax</a></h3><p>PackageDownload is defined in your <code>.csproj</code> file:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="nt">&lt;ItemGroup&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;PackageDownload</span> <span class="na">Include=</span><span class="s">&#34;Newtonsoft.Json&#34;</span> <span class="na">Version=</span><span class="s">&#34;[13.0.1]&#34;</span> <span class="nt">/&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/ItemGroup&gt;</span>
</span></span></code></pre></div><p>Unlike <code>&lt;PackageReference></code>, this downloads the package but <strong>does not reference its assemblies</strong>. The package sits in your NuGet cache, available for MSBuild tasks or custom build logic, but it doesn&rsquo;t touch your dependency tree.</p><p>Simple enough. Until you hit the version requirement.</p><h2 id="why-youd-use-this"><a href="/posts/nuget-packagedownload-functionality/#why-youd-use-this" title="Why You&rsquo;d Use This">Why You&rsquo;d Use This</a></h2><p>PackageDownload isn&rsquo;t a mainstream feature. Most developers will never need it. But when you do, it&rsquo;s the only clean option.</p><h3 id="1-build-time-tools-and-analyzers"><a href="/posts/nuget-packagedownload-functionality/#1-build-time-tools-and-analyzers" title="1. Build-Time Tools and Analyzers">1. Build-Time Tools and Analyzers</a></h3><p>Some packages contain Roslyn analyzers or code generators that run during compilation. You need the package on disk for MSBuild to find it, but you don&rsquo;t want it as a runtime dependency.</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="nt">&lt;PackageDownload</span> <span class="na">Include=</span><span class="s">&#34;Microsoft.CodeAnalysis.NetAnalyzers&#34;</span> <span class="na">Version=</span><span class="s">&#34;[7.0.0]&#34;</span> <span class="nt">/&gt;</span>
</span></span></code></pre></div><p>The analyzer runs during the build. It doesn&rsquo;t ship with your application.</p><h3 id="2-non-code-assets"><a href="/posts/nuget-packagedownload-functionality/#2-non-code-assets" title="2. Non-Code Assets">2. Non-Code Assets</a></h3><p>If you&rsquo;re distributing build scripts, configuration files, or schemas via NuGet, PackageDownload lets you pull them down without dragging in unnecessary assemblies.</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="nt">&lt;PackageDownload</span> <span class="na">Include=</span><span class="s">&#34;CompanyBuildTools&#34;</span> <span class="na">Version=</span><span class="s">&#34;[2.3.0]&#34;</span> <span class="nt">/&gt;</span>
</span></span></code></pre></div><h3 id="3-avoiding-transitive-dependency-conflicts"><a href="/posts/nuget-packagedownload-functionality/#3-avoiding-transitive-dependency-conflicts" title="3. Avoiding Transitive Dependency Conflicts">3. Avoiding Transitive Dependency Conflicts</a></h3><p>In complex solutions, pulling in a package for its metadata or documentation can trigger unwanted transitive dependencies. PackageDownload sidesteps that entirely.</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="nt">&lt;PackageDownload</span> <span class="na">Include=</span><span class="s">&#34;XmlSchemas.Library&#34;</span> <span class="na">Version=</span><span class="s">&#34;[2.1.0]&#34;</span> <span class="nt">/&gt;</span>
</span></span></code></pre></div><h3 id="4-version-pinning-for-build-reproducibility"><a href="/posts/nuget-packagedownload-functionality/#4-version-pinning-for-build-reproducibility" title="4. Version Pinning for Build Reproducibility">4. Version Pinning for Build Reproducibility</a></h3><p>When you need an exact package version available during the build — not approximately, not &ldquo;compatible with,&rdquo; but <strong>exactly that version</strong> — PackageDownload enforces it.</p><h2 id="how-it-works"><a href="/posts/nuget-packagedownload-functionality/#how-it-works" title="How It Works">How It Works</a></h2><p>When MSBuild encounters a <code>&lt;PackageDownload></code> element, NuGet resolves the specified version and downloads the package to the global cache — typically <code>%USERPROFILE%\.nuget\packages</code> on Windows or <code>~/.nuget/packages</code> on Linux and macOS. Crucially, no assembly references are added to your project. The package contents sit there, available for custom MSBuild tasks, targets, or extraction logic, but they don&rsquo;t touch your dependency tree.</p><p>That&rsquo;s straightforward. The frustration starts with the version syntax.</p><h2 id="the-version-range-requirement-a-painful-design-choice"><a href="/posts/nuget-packagedownload-functionality/#the-version-range-requirement-a-painful-design-choice" title="The Version Range Requirement: A Painful Design Choice">The Version Range Requirement: A Painful Design Choice</a></h2><p>Here&rsquo;s the part that trips up everyone who tries PackageDownload for the first time:</p><p><strong>You must specify the version using range notation.</strong></p><h3 id="the-hard-requirement"><a href="/posts/nuget-packagedownload-functionality/#the-hard-requirement" title="The Hard Requirement">The Hard Requirement</a></h3><p>Unlike <code>&lt;PackageReference></code>, which accepts a simple version like <code>Version="13.0.1"</code>, PackageDownload demands version ranges:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="c">&lt;!-- This does NOT work --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;PackageDownload</span> <span class="na">Include=</span><span class="s">&#34;Newtonsoft.Json&#34;</span> <span class="na">Version=</span><span class="s">&#34;13.0.1&#34;</span> <span class="nt">/&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">&lt;!-- You must use this --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;PackageDownload</span> <span class="na">Include=</span><span class="s">&#34;Newtonsoft.Json&#34;</span> <span class="na">Version=</span><span class="s">&#34;[13.0.1]&#34;</span> <span class="nt">/&gt;</span>
</span></span></code></pre></div><p>The square brackets <code>[13.0.1]</code> mean <strong>exactly version 13.0.1</strong>. No flexibility. No approximation. That specific version, or the restore fails.</p><h3 id="why-this-is-a-problem"><a href="/posts/nuget-packagedownload-functionality/#why-this-is-a-problem" title="Why This Is a Problem">Why This Is a Problem</a></h3><p>This requirement creates unnecessary friction in several ways. First, the syntax is unintuitive — developers familiar with <code>&lt;PackageReference></code> expect the same syntax to work, but it doesn&rsquo;t. The version range requirement isn&rsquo;t obvious, and the error messages when you get it wrong are cryptic at best.</p><p>Second, and more frustratingly, there&rsquo;s no integration with Central Package Management. When Microsoft introduced CPM in 2022, it promised to centralize version control across solutions. Define versions once in <code>Directory.Packages.props</code>, reference them everywhere. PackageDownload doesn&rsquo;t care.</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="c">&lt;!-- Directory.Packages.props --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;ItemGroup&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;PackageVersion</span> <span class="na">Include=</span><span class="s">&#34;Newtonsoft.Json&#34;</span> <span class="na">Version=</span><span class="s">&#34;13.0.1&#34;</span> <span class="nt">/&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/ItemGroup&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">&lt;!-- Project file - this FAILS --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;ItemGroup&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;PackageDownload</span> <span class="na">Include=</span><span class="s">&#34;Newtonsoft.Json&#34;</span> <span class="nt">/&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="c">&lt;!-- Still requires: Version=&#34;[13.0.1]&#34; --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/ItemGroup&gt;</span>
</span></span></code></pre></div><p>You still need to manually specify the version in every <code>&lt;PackageDownload></code> entry. CPM is ignored completely. This creates manual maintenance overhead — if you&rsquo;re using PackageDownload across multiple projects, updating a version means editing every single file. There&rsquo;s no centralized control. It defeats the entire purpose of modern dependency management.</p><h3 id="the-missed-opportunity"><a href="/posts/nuget-packagedownload-functionality/#the-missed-opportunity" title="The Missed Opportunity">The Missed Opportunity</a></h3><p>PackageDownload was introduced in 2018. CPM arrived in 2022. As of 2025, they still don&rsquo;t work together. This isn&rsquo;t an oversight — it&rsquo;s a conscious decision not to invest in making older features compatible with newer workflows. And it shows.</p><p>The result is a bifurcated system where you use CPM for <code>&lt;PackageReference></code> (modern, clean, centralized) but inline versions for <code>&lt;PackageDownload></code> (legacy, manual, error-prone). It&rsquo;s frustrating because it didn&rsquo;t have to be this way.</p><h2 id="real-world-scenarios"><a href="/posts/nuget-packagedownload-functionality/#real-world-scenarios" title="Real-World Scenarios">Real-World Scenarios</a></h2><p>Despite the rough edges, PackageDownload has legitimate use cases.</p><h3 id="roslyn-analyzers-in-multi-project-solutions"><a href="/posts/nuget-packagedownload-functionality/#roslyn-analyzers-in-multi-project-solutions" title="Roslyn Analyzers in Multi-Project Solutions">Roslyn Analyzers in Multi-Project Solutions</a></h3><p>If you&rsquo;re using StyleCop or custom analyzers that should run during the build but not ship with your application:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="nt">&lt;ItemGroup&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;PackageDownload</span> <span class="na">Include=</span><span class="s">&#34;StyleCop.Analyzers&#34;</span> <span class="na">Version=</span><span class="s">&#34;[1.2.0-beta.435]&#34;</span> <span class="nt">/&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/ItemGroup&gt;</span>
</span></span></code></pre></div><p>The analyzer is downloaded, applied during compilation, and ignored at runtime.</p><h3 id="extracting-package-contents"><a href="/posts/nuget-packagedownload-functionality/#extracting-package-contents" title="Extracting Package Contents">Extracting Package Contents</a></h3><p>Custom MSBuild tasks can extract specific files from downloaded packages:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="nt">&lt;ItemGroup&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;PackageDownload</span> <span class="na">Include=</span><span class="s">&#34;CompanyAssets&#34;</span> <span class="na">Version=</span><span class="s">&#34;[2.5.0]&#34;</span> <span class="nt">/&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/ItemGroup&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nt">&lt;Target</span> <span class="na">Name=</span><span class="s">&#34;ExtractAssets&#34;</span> <span class="na">AfterTargets=</span><span class="s">&#34;Restore&#34;</span><span class="nt">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;Copy</span> <span class="na">SourceFiles=</span><span class="s">&#34;$(NuGetPackageRoot)companyassets\2.5.0\content\config.json&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="na">DestinationFolder=</span><span class="s">&#34;$(OutputPath)&#34;</span> <span class="nt">/&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/Target&gt;</span>
</span></span></code></pre></div><p>This turns NuGet into a distribution mechanism for non-code assets.</p><h3 id="build-tools-with-exact-versions"><a href="/posts/nuget-packagedownload-functionality/#build-tools-with-exact-versions" title="Build Tools with Exact Versions">Build Tools with Exact Versions</a></h3><p>For reproducible builds, you might need specific tool versions:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="nt">&lt;ItemGroup&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;PackageDownload</span> <span class="na">Include=</span><span class="s">&#34;GitVersion.Tool&#34;</span> <span class="na">Version=</span><span class="s">&#34;[5.12.0]&#34;</span> <span class="nt">/&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/ItemGroup&gt;</span>
</span></span></code></pre></div><p>PackageDownload guarantees that exact version is available, no matter what.</p><h2 id="the-broader-pattern-incomplete-evolution"><a href="/posts/nuget-packagedownload-functionality/#the-broader-pattern-incomplete-evolution" title="The Broader Pattern: Incomplete Evolution">The Broader Pattern: Incomplete Evolution</a></h2><p>PackageDownload is emblematic of how mature platforms evolve — slowly, incrementally, and often without full integration.</p><p>Consider the timeline:</p><ul><li><strong>2010</strong>: NuGet 1.0 launches</li><li><strong>2018</strong>: PackageDownload is introduced in NuGet 4.8</li><li><strong>2022</strong>: Central Package Management arrives</li><li><strong>2025</strong>: PackageDownload still doesn&rsquo;t integrate with CPM</li></ul><p>This reveals a fundamental challenge: maintaining backward compatibility while adding new capabilities. Every feature must coexist with a decade of existing workflows. Sometimes that means compromise. Other times it means neglect.</p><h3 id="what-should-have-happened"><a href="/posts/nuget-packagedownload-functionality/#what-should-have-happened" title="What Should Have Happened">What Should Have Happened</a></h3><p>PackageDownload should have been updated when CPM launched. At minimum, it should respect CPM versions, allowing PackageDownload to read from <code>Directory.Packages.props</code> and falling back to inline versions only when necessary. The version syntax should have been simplified to support both simple versions and ranges, with clear guidance on when each applies. Visual Studio and the CLI should provide first-class support for managing PackageDownload entries, and the official docs should explain the version requirement prominently, not bury it in footnotes.</p><p>None of that happened. PackageDownload works. But it doesn&rsquo;t integrate.</p><h2 id="practical-guidelines"><a href="/posts/nuget-packagedownload-functionality/#practical-guidelines" title="Practical Guidelines">Practical Guidelines</a></h2><p>If you&rsquo;re using PackageDownload, here&rsquo;s how to avoid the pain points.</p><h3 id="when-to-use-it"><a href="/posts/nuget-packagedownload-functionality/#when-to-use-it" title="When to Use It">When to Use It</a></h3><p>PackageDownload makes sense for build-time tools or analyzers that shouldn&rsquo;t be runtime dependencies, for non-code assets distributed via NuGet, for custom MSBuild tasks requiring specific package versions, and in scenarios where transitive dependencies would create conflicts. These are real use cases where PackageDownload genuinely solves problems.</p><h3 id="when-to-avoid-it"><a href="/posts/nuget-packagedownload-functionality/#when-to-avoid-it" title="When to Avoid It">When to Avoid It</a></h3><p>Don&rsquo;t use PackageDownload if you need the package&rsquo;s assemblies — that&rsquo;s what <code>&lt;PackageReference></code> is for. Don&rsquo;t expect CPM integration because it doesn&rsquo;t exist. And be aware that automatic version updates via Dependabot get complicated when you&rsquo;re using version ranges.</p><h3 id="best-practices"><a href="/posts/nuget-packagedownload-functionality/#best-practices" title="Best Practices">Best Practices</a></h3><p>Document your intent by adding comments explaining why you&rsquo;re using PackageDownload instead of PackageReference. It saves confusion later. Since CPM doesn&rsquo;t work, centralize versions manually using MSBuild properties:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="c">&lt;!-- Using PackageDownload to avoid runtime dependency on StyleCop --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;PackageDownload</span> <span class="na">Include=</span><span class="s">&#34;StyleCop.Analyzers&#34;</span> <span class="na">Version=</span><span class="s">&#34;[1.2.0]&#34;</span> <span class="nt">/&gt;</span>
</span></span></code></pre></div><p>This approach at least keeps versions in one place, even if it&rsquo;s not as elegant as CPM. And always test in clean environments — PackageDownload failures often appear only during initial restore, not in your local development setup where everything&rsquo;s already cached.</p><h2 id="final-thoughts-a-tool-that-works-with-caveats"><a href="/posts/nuget-packagedownload-functionality/#final-thoughts-a-tool-that-works-with-caveats" title="Final Thoughts: A Tool That Works, With Caveats">Final Thoughts: A Tool That Works, With Caveats</a></h2><p>PackageDownload solves a real problem. It enables scenarios that would otherwise require awkward workarounds or custom scripting. For teams managing complex build pipelines, it&rsquo;s indispensable.</p><p>But its limitations aren&rsquo;t minor inconveniences. The version range requirement is unintuitive. The lack of CPM integration is inexcusable. And the documentation assumes you already know what you&rsquo;re doing.</p><p>This is what happens when platforms evolve without a coherent strategy. Features get added. They solve problems. But they don&rsquo;t integrate. They coexist, awkwardly, creating friction for developers who just want things to work.</p><p>PackageDownload is powerful. It&rsquo;s also a reminder that mature ecosystems carry baggage. Sometimes that baggage is worth the trade-off. Other times, it&rsquo;s just frustrating.</p><p>Know when you need it. Understand its limitations. And hope that someday, Microsoft decides to make it work with the rest of the tooling.</p><p>Until then, it&rsquo;s another tool in your arsenal — useful, imperfect, and occasionally infuriating.</p></section><section class="giscus"><h2>Comments</h2><aside class="giscus" id="giscus-thread" role="region" aria-label="Comments"></aside></section><script src="https://giscus.app/client.js" data-repo="dailydevops/dailydevops.github.io" data-repo-id="R_kgDOHA8eFg" data-category="Announcements" data-category-id="DIC_kwDOHA8eFs4COIqL" data-mapping="pathname" data-strict="1" data-reactions-enabled="0" data-emit-metadata="0" data-input-position="bottom" data-theme="light" data-lang="en" crossorigin="anonymous" async></script></article><aside class="sidebar divider"><section class="sidecar info" aria-labelledby="info-heading"><header><h2 id="info-heading" class="sr-only">Informations</h2></header><ul role="list"><li role="listitem"><time datetime="2025-10-29T18:00:00+01:00" itemprop="datePublished">Published on 10/29/25 6:00 pm</time></li><li>Read in 7 minutes</li></ul></section><section class="sidecar author" aria-labelledby="author-martin-st%C3%BChmer"><header><h2 id="author-martin-st%C3%BChmer"><a href="/authors/martin/" rel="author" title="Martin Stühmer" itemprop="url">Author <span itemprop="name">Martin Stühmer</span></a></h2></header><figure class="round"><picture><img src="https://www.gravatar.com/avatar/6da4a47ff9cc2b750452225fdb2582f7?d=identicon&amp;s=200" alt="Martin Stühmer" loading="lazy" decoding="async" title="Martin Stühmer"></picture></figure><section class="content" itemprop="description">Martin is a software architect and developer who has spent nearly two decades navigating the .NET ecosystem from Framework 2.0 to modern .NET 10. As Director Consulting Services at CGI and a Microsoft Certified Trainer, he specializes in cloud-native solutions, enterprise architecture, and Risk and Cost Driven Architecture (RCDA). His mission is straightforward - help teams build quality software that survives contact with production. He contributes to open-source communities through NuGet packages, writes about pragmatic software engineering on this blog, and trains developers who want substance over buzzwords.</section><a class="link" href="/authors/martin/" rel="author" aria-label="Author Martin Stühmer: Read more"></a></section><section class="sidecar social" aria-labelledby="social-heading"><header><h2 id="social-heading">Social media</h2></header><nav class="social-nav" role="navigation" aria-label="Social media links"><a class="icon bluesky" href="https://bsky.app/profile/samtrion.net" rel="noopener external" aria-label="Follow me on Bluesky" target="_blank"><span class="fa-stack fa-fw fa-1x" aria-hidden="true"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-bluesky fa-stack-1x fa-inverse"></i>
</span></a><a class="icon github" href="https://github.com/samtrion" rel="noopener external" aria-label="Follow me on GitHub" target="_blank"><i class="fa-brands fa-fw fa-github fa-2x" aria-hidden="true"></i></a>
<a class="icon linkedin" href="https://www.linkedin.com/in/martin-stuehmer" rel="noopener external" aria-label="Follow me on LinkedIn" target="_blank"><span class="fa-stack fa-fw fa-1x" aria-hidden="true"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-linkedin-in fa-stack-1x fa-inverse"></i>
</span></a><a class="icon stackoverflow" href="https://stackoverflow.com/users/10574963" rel="noopener external" aria-label="Follow me on Stack Overflow" target="_blank"><span class="fa-stack fa-fw fa-1x" aria-hidden="true"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-stack-overflow fa-stack-1x fa-inverse"></i>
</span></a><a class="icon mail" href="mailto:martin@daily-devops.net" aria-label="Contact me by e-mail" target="_blank"><span class="fa-stack fa-fw fa-1x" aria-hidden="true"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
</span></a><a class="icon feed" href="/authors/martin/feed.rss" aria-label="My RSS feed" target="_blank"><span class="fa-stack fa-fw fa-1x" aria-hidden="true"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></nav></section><section class="sidecar share" aria-labelledby="share-heading"><header><h2 id="share-heading">Share this content</h2></header><a class="icon linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fdaily-devops.net%2fposts%2fnuget-packagedownload-functionality%2f&text=PackageDownload%3a%20NuGet%27s%20Forgotten%20Power%20Tool%0a%20%26mdash%3b%20Daily%20DevOps%20%26%20.NET" target="_blank" rel="noopener external" aria-label="Share on LinkedIn" title="Share on LinkedIn" target="_blank"><i class="fa-brands fa-fw fa-linkedin-in fa-2x"></i></a>
<a class="icon bluesky" href="https://bsky.app/intent/compose?text=PackageDownload%3a%20NuGet%27s%20Forgotten%20Power%20Tool%0a%20%26mdash%3b%20Daily%20DevOps%20%26%20.NET%20https%3a%2f%2fdaily-devops.net%2fposts%2fnuget-packagedownload-functionality%2f" target="_blank" rel="noopener external" aria-label="Share on Bluesky" title="Share on Bluesky" target="_blank"><i class="fa-brands fa-fw fa-bluesky fa-2x"></i></a></section><section class="sidecar tags" aria-labelledby="tags-heading"><header><h2 id="tags-heading">Tags</h2></header><ul class="tags" role="list"><li class="tag" role="listitem"><a href="/tags/dotnet/" hreflang="en" rel="tag" title=".NET" aria-label=".NET tag"><i class="fas fa-tag" aria-hidden="true"></i>&nbsp;.NET</a></li><li class="tag" role="listitem"><a href="/tags/bestpractices/" hreflang="en" rel="tag" title="Best Practices" aria-label="Best Practices tag"><i class="fas fa-tag" aria-hidden="true"></i>&nbsp;Best Practices</a></li><li class="tag" role="listitem"><a href="/tags/dependency-management/" hreflang="en" rel="tag" title="Dependency Management" aria-label="Dependency Management tag"><i class="fas fa-tag" aria-hidden="true"></i>&nbsp;Dependency Management</a></li><li class="tag" role="listitem"><a href="/tags/msbuild/" hreflang="en" rel="tag" title="MSBuild" aria-label="MSBuild tag"><i class="fas fa-tag" aria-hidden="true"></i>&nbsp;MSBuild</a></li><li class="tag" role="listitem"><a href="/tags/nuget/" hreflang="en" rel="tag" title="NuGet" aria-label="NuGet tag"><i class="fas fa-tag" aria-hidden="true"></i>&nbsp;NuGet</a></li><li class="tag" role="listitem"><a href="/tags/technicaldebt/" hreflang="en" rel="tag" title="Technical Debt" aria-label="Technical Debt tag"><i class="fas fa-tag" aria-hidden="true"></i>&nbsp;Technical Debt</a></li></ul></section><section class="sidecar related" aria-labelledby="related-heading"><header><h2 id="related-heading">Related content</h2></header><article class="post"><figure class="square"><picture><source srcset="/images/package-manager-80x80.webp?v=bf435c341033f38259d0b461059c30c4" type="image/webp"><source srcset="/images/package-manager-80x80.png?v=e2d9bba485820dc0336d1253eb4dd7a1" type="image/png"><img src="/images/package-manager.png?v=19ac8eda9b0cc3394a0da24151d44079" alt="Manage NuGet Packages Centrally" loading="lazy" decoding="async" title="Manage NuGet Packages Centrally"></picture></figure><header><h2><a href="/posts/manage-nuget-packages-centrally/" rel="bookmark">Manage NuGet Packages Centrally</a></h2></header><section class="content" role="region"><p>For over 12 years, NuGet package management has been part of the .NET ecosystem with direct integrations to various IDEs, CLIs and build systems. But a feature took 12 years before it appeared and certainly needs some more maintenance until it is mature!</p></section></article><article class="post"><figure class="square"><picture><source srcset="/images/dotnet-80x80.webp?v=3d56eea0243ac6549bb0ce626059527e" type="image/webp"><source srcset="/images/dotnet-80x80.png?v=98376a285f07b0021d3118e0523d147a" type="image/png"><img src="/images/dotnet.png?v=8142ec8a038ba14415ff0d0434c78182" alt="Buzzword-Driven Development vs. Fundamental Software Quality" loading="lazy" decoding="async" title="Buzzword-Driven Development vs. Fundamental Software Quality"></picture></figure><header><h2><a href="/posts/buzzword-driven-development/" rel="bookmark">Buzzword-Driven Development vs. Fundamental Software Quality</a></h2></header><section class="content" role="region">Explore why fundamental software quality practices in .NET must never be overlooked for trendy buzzwords, including recommended analyzers and project settings for managing technical debt effectively.</section></article><article class="post"><figure class="square"><picture><source srcset="/images/csharp-80x80.webp?v=052f6acac96e85c28437419a43ab8923" type="image/webp"><source srcset="/images/csharp-80x80.png?v=c5d685b0d4fa9ec69bd959ee04beb903" type="image/png"><img src="/images/csharp.png?v=21ff9dcf5d1da7bfa80141c972c117da" alt="Managing Errors, Warnings, and Configurations in C# and .NET" loading="lazy" decoding="async" title="Managing Errors, Warnings, and Configurations in C# and .NET"></picture></figure><header><h2><a href="/posts/managing-errors-warnings-and-configurations/" rel="bookmark">Managing Errors, Warnings, and Configurations in C# and .NET</a></h2></header><section class="content" role="region"><p>When we activated static code analysis for the first time in one of my last projects, the overwhelming number of warnings exceeded expectations and highlighted gaps in the code. Without making any changes, the project already had a <strong>significant number of warnings</strong>. After activating additional analyzers and updating some configurations, this number <strong>temporarily increased dramatically</strong>.</p><p>The high number of warnings was initially daunting, but we saw it as an opportunity to significantly improve our code quality. At first glance, it seemed easier to suppress or ignore these warnings. But as I often remind my team, <strong>&ldquo;The code you create is a valuable legacy, so it&rsquo;s important to build it carefully.&rdquo;</strong> Ignoring warnings today creates obstacles for future developers—and that could very well include you six months down the line.</p><p>This experience reinforced the importance of managing warnings and errors systematically. Let me share some of the lessons we learned, the strategies we used to tame those 60,000 warnings, and how you can apply these techniques to your own projects.</p></section></article></section></aside><nav class="pager" aria-label="Article navigation" role="navigation"><a class="next" href="/posts/tests-are-lying/" rel="next" aria-label="Next: Your Tests Are Lying — Mutation Testing in .NET"><span class="sub"><i class="fas fa-backward" aria-hidden="true"></i>&emsp;<span class="sr-only">Next</span></span><p class="title">Your Tests Are Lying — Mutation Testing in .NET</p></a><a class="prev" href="/posts/netevolve-healthchecks/" rel="prev" aria-label="Previous: Configuration-First Health Checks for Modern .NET"><span class="sub"><span class="sr-only">Previous</span>&emsp;<i class="fas fa-forward" aria-hidden="true"></i></span><p class="title">Configuration-First Health Checks for Modern .NET</p></a></nav></main><footer class="footer"><div class="divider"></div><nav><ul class="navigation"><li><a href="/tags/">Tags</a></li><li><a href="/legal-notice/">Legal notice</a></li></ul></nav><div class="copyright">&copy; 2023 - 2026 Daily DevOps & .NET</div></footer><script defer src="/js/below.min.a6ce9164454b6077f17ae856f280442d9f3a1e21f06189f71c21f75144b22a0c8cf32bafd61d440e9d90ca02bf738b6a8ef19f5ec20285d8ca574f98c91ebaf2.js" integrity="sha512-ps6RZEVLYHfxeuhW8oBELZ86HiHwYYn3HCH3UUSyKgyM8yuv1h1EDp2QygK/c4tqjvGfXsIChdjKV0+YyR668g==" crossorigin="anonymous"></script><img class="vgwort" src="https://vg05.met.vgwort.de/na/537e3a92954d46c1bd09fa44d7e70cd6" width="1" height="1" alt="VG Wort" title="VG Wort"></body></html>