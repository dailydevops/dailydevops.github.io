<!doctype html><html class="no-js" lang="en" dir="ltr"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="theme-color" content="#15a"><title>.NET 10: Timing Is the New Technical Debt
— Daily DevOps & .NET</title><meta name="description" content="2025 reshapes the .NET ecosystem with faster release cycles and shared responsibility. Discover why migrating to .NET 10 by Q1 2026 — and supporting your …"><meta name="twitter:description" property="og:description" content="2025 reshapes the .NET ecosystem with faster release cycles and shared responsibility. Discover why migrating to .NET 10 by Q1 2026 — and supporting your …"><meta name="author" content="Martin Stühmer"><link rel="icon" href="/logo.svg?v=b9e294dc5c6fa04439c8c803d8e981a9" sizes="any" type="image/svg+xml"><meta name="twitter:title" property="og:title" content=".NET 10: Timing Is the New Technical Debt
 — Daily DevOps & .NET"><meta property="og:updated_time" content="2025-11-12T17:20:02+01:00"><meta property="article:modified_time" content="2025-11-12T17:20:02+01:00"><meta property="article:published_time" content="2025-10-28T09:30:00+01:00"><meta property="og:type" content="article"><meta property="og:site_name" content="Daily DevOps & .NET"><meta property="og:url" content="https://daily-devops.net/posts/timing-is-the-new-technical-debt/"><meta property="og:locale" content="en_US"><meta name="twitter:card" content="summary_large_image"><meta property="og:image" name="twitter:image" content="https://daily-devops.net/images/timing-dotnet10-1200x630.webp?v=030fa7a7c7b6b5395291583adf15b2d4"><meta property="og:image:secure_url" content="https://daily-devops.net/images/timing-dotnet10-1200x630.webp?v=030fa7a7c7b6b5395291583adf15b2d4"><meta property="og:image:alt" name="twitter:image:alt" content=".NET 10: Timing Is the New Technical Debt
"><meta property="og:image:type" content="image/webp"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta property="og:image" name="twitter:image" content="https://daily-devops.net/images/timing-dotnet10-1200x630.png?v=dd9110a566c35ba69c40a9dbff7ceb86"><meta property="og:image:secure_url" content="https://daily-devops.net/images/timing-dotnet10-1200x630.png?v=dd9110a566c35ba69c40a9dbff7ceb86"><meta property="og:image:alt" name="twitter:image:alt" content=".NET 10: Timing Is the New Technical Debt
"><meta property="og:image:type" content="image/png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><link rel="dns-prefetch" href="https://www.clarity.ms"><link rel="preconnect" href="https://www.clarity.ms" crossorigin><link rel="stylesheet" href="/css/style.min.5ccb118d2a61a152205e83121806e681df83c9be30dc661b5c2ac97f257aa206825d04398f912d6763f44f402cb983be17b797fa6f45bf2df44dcf69583f808a.css" integrity="sha512-XMsRjSphoVIgXoMSGAbmgd+Dyb4w3GYbXCrJfyV6ogaCXQQ5j5EtZ2P0T0AsuYO+F7eX+m9Fvy30Tc9pWD+Aig==" crossorigin="anonymous"><link rel="alternate" href='https://daily-devops.net/posts/timing-is-the-new-technical-debt/' hreflang="x-default" title=".NET 10: Timing Is the New Technical Debt
 &mdash; Daily DevOps & .NET"><link rel="canonical" href="https://daily-devops.net/posts/timing-is-the-new-technical-debt/" hreflang="en-us" title=".NET 10: Timing Is the New Technical Debt
 &mdash; Daily DevOps & .NET"><link rel="home" href="https://daily-devops.net/" hreflang="en-us" title="Daily DevOps & .NET"><link rel="next" href="https://daily-devops.net/posts/netevolve-healthchecks/" hreflang="en-us" title="Configuration-First Health Checks for Modern .NET"><link rel="prev" href="https://daily-devops.net/posts/compositeformat-performance-boost/" hreflang="en-us" title="Stop Parsing the Same String Twice: CompositeFormat in .NET"><link rel="author" href="https://daily-devops.net/authors/martin/" hreflang="en-us" title="Martin Stühmer &mdash; Daily DevOps & .NET"><meta name="giscus:backlink" content="https://daily-devops.net/posts/timing-is-the-new-technical-debt/"><script defer src="/js/above.min.cb42b2c9a453e49e278326637d72d2f01e7f32e3f91e9cdde8fb587793d05514efd2f5cc5021c9658ca0f73876dbdcd1f7cb4a37c0bebc9df01110926b6d7cba.js" integrity="sha512-y0KyyaRT5J4ngyZjfXLS8B5/MuP5Hpzd6PtYd5PQVRTv0vXMUCHJZYyg9zh229zR98tKN8C+vJ3wERCSa218ug==" crossorigin="anonymous"></script><script type="text/javascript">(function(e,t,n,s,o,i,a){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)},i=t.createElement(s),i.async=1,i.src="https://www.clarity.ms/tag/"+o,a=t.getElementsByTagName(s)[0],a.parentNode.insertBefore(i,a)})(window,document,"clarity","script","o0pr4n9gg3")</script></head><body class="container"><header class="header"><a class="logo" href="/" title="Daily DevOps & .NET" rel="home"><figure class="page-logo"><picture><img src="/logo.svg?v=b9e294dc5c6fa04439c8c803d8e981a9" alt="Daily DevOps & .NET" title="Daily DevOps & .NET"></picture></figure><span class="title">Daily DevOps & .NET</span></a><nav class="menu"><button class="burger" aria-haspopup="true" aria-expanded="false" tabindex="0">
<i class="fas fa-burger"></i></button><ul class="navigation"><li class="active"><a href="/posts/">Posts</a></li><li><a href="/authors/">About us</a></li></ul></nav><div class="divider"></div></header><main class="body"><figure class="hero"><picture><source srcset="/images/timing-dotnet10-544x136.webp?v=8fcc138f3a22d412eac9efa2001996e9" type="image/webp" media="(max-width: 575.98px)"><source srcset="/images/timing-dotnet10-544x136.png?v=552e7cde2b85d844f5d4a0e4f55cb943" type="image/png" media="(max-width: 575.98px)"><source srcset="/images/timing-dotnet10-672x168.webp?v=dbd30004391a34cbf0104fc9983328c1" type="image/webp" media="(max-width: 767.98px)"><source srcset="/images/timing-dotnet10-672x168.png?v=f43495640159a4613e35c1a3e486c8a4" type="image/png" media="(max-width: 767.98px)"><source srcset="/images/timing-dotnet10-896x224.webp?v=479c1489c4feb5ab3976cc31ef578886" type="image/webp" media="(max-width: 991.98px)"><source srcset="/images/timing-dotnet10-896x224.png?v=687e46642694336ffebf67bce0aa3fc0" type="image/png" media="(max-width: 991.98px)"><source srcset="/images/timing-dotnet10-1104x276.webp?v=960c0f2d16d76a8d0f4c349f9deac267" type="image/webp" media="(max-width: 1199.98px)"><source srcset="/images/timing-dotnet10-1104x276.png?v=89cd27a53286d642d3c3aeb8065651ae" type="image/png" media="(max-width: 1199.98px)"><source srcset="/images/timing-dotnet10-1444x361.webp?v=0bb2f936f7a72dd2e4bb4ef28b94632a" type="image/webp"><source srcset="/images/timing-dotnet10-1444x361.png?v=ef05e894d7d2ccabff1140c11bbfcf31" type="image/png"><img src="/images/timing-dotnet10.png?v=8a9aad349f586d3bcaeaf9c95a6d62b5" alt=".NET 10: Timing Is the New Technical Debt
" loading="lazy" decoding="async" title=".NET 10: Timing Is the New Technical Debt
"></picture></figure><article class="post"><header><h1>.NET 10: Timing Is the New Technical Debt</h1></header><section class="content"><p>The <strong>.NET ecosystem is changing faster than ever before</strong>, and this time the shift runs deeper than a simple version number.</p><p>In the last few months, I have seen a growing trend among organizations to delay their migration plans. <strong>We&rsquo;ll wait for .NET 10 to stabilise.</strong> - This sentiment is becoming increasingly common, without a clear understanding of what stability means in today&rsquo;s accelerated software landscape.</p><p>Over the past years, Microsoft has unified runtimes, aligned frameworks, and compressed release cadences into a strict three-year Long-Term Support rhythm. Together with faster SDK iterations and an accelerating dependency landscape, these changes have quietly redefined what <em><strong>stable</strong></em> means in enterprise software.</p><p>This evolution doesn&rsquo;t create chaos—it creates compression.
Update windows are shorter, dependencies are more interlinked, and security governance has become a continuous discipline rather than a periodic audit. As a result, timing itself is now a structural variable in the cost model of modern software.</p><p>For almost a decade, organisations could afford to delay upgrades, waiting “one more release” in the name of caution. But those days are over. In the new ecosystem, every quarter of hesitation accumulates like interest on a loan. The debt isn’t in the code—it’s in the calendar. And that is precisely why targeting a <strong>.NET 10 migration in Q1 2026</strong> is not merely technically sensible, but economically strategic.</p><h2 id="the-5-whys-of-migration-timing"><a href="/posts/timing-is-the-new-technical-debt/#the-5-whys-of-migration-timing" title="The 5 Whys of Migration Timing">The 5 Whys of Migration Timing</a></h2><h3 id="why-1--why-upgrade-at-all"><a href="/posts/timing-is-the-new-technical-debt/#why-1--why-upgrade-at-all" title="Why 1 – Why upgrade at all?"><strong>Why 1 – Why upgrade at all?</strong></a></h3><p>Because remaining on older runtimes no longer preserves stability—it erodes it.
The three-year LTS rhythm means .NET 6 is out of support, and .NET 8 will follow in November 2026. Unsupported frameworks bring manual patching, fragmented libraries, and compliance exposure. What once felt like safety has become cost inertia.</p><h3 id="why-2--why-specifically-net-10"><a href="/posts/timing-is-the-new-technical-debt/#why-2--why-specifically-net-10" title="Why 2 – Why specifically .NET 10?"><strong>Why 2 – Why specifically .NET 10?</strong></a></h3><p>Because .NET 10 completes the unification agenda Microsoft started years ago.
For the first time, runtime, SDK, and container models align seamlessly. Build systems behave predictably across platforms, dependency resolution has matured, and C# 14 integrates natively into DevOps toolchains. It’s the version where the ecosystem finally stabilises—and stability converts directly into lower operational overhead.</p><h3 id="why-3--why-now"><a href="/posts/timing-is-the-new-technical-debt/#why-3--why-now" title="Why 3 – Why now?"><strong>Why 3 – Why now?</strong></a></h3><p>Because the ecosystem’s velocity has overtaken the enterprise pace.
Open-source maintainers, cloud vendors, and security standards evolve faster than corporate release plans. Two versions behind means you’re already managing exceptions instead of releases. Vulnerability patches and dependency updates increasingly assume modern SDKs, leaving older ones stranded. Waiting until 2027 simply means paying a premium for standing still.</p><h3 id="why-4--why-target-q1-2026"><a href="/posts/timing-is-the-new-technical-debt/#why-4--why-target-q1-2026" title="Why 4 – Why target Q1 2026?"><strong>Why 4 – Why target Q1 2026?</strong></a></h3><p>Because that&rsquo;s the moment when stability and ROI intersect.
By the first quarter after general availability, Microsoft&rsquo;s initial cumulative updates are in place, partner libraries are aligned, and build tooling has settled.
A Q1 2026 migration integrates naturally into fiscal planning, avoids year-end freezes, and delivers the full three-year LTS runway through late 2028.</p><h3 id="why-5--why-is-timing-an-economic-decision"><a href="/posts/timing-is-the-new-technical-debt/#why-5--why-is-timing-an-economic-decision" title="Why 5 – Why is timing an economic decision?"><strong>Why 5 – Why is timing an economic decision?</strong></a></h3><p>Because time now governs cost curves.
Cloud workloads consume more compute under older runtimes—Microsoft&rsquo;s own benchmarks show .NET 8 consuming 18-22% less memory than .NET 6 in containerised scenarios. Governance teams spend more cycles validating outdated dependencies; developers lose time adapting tooling instead of delivering value. Every delay drains budget and morale alike.</p><p>But here&rsquo;s the uncomfortable truth Microsoft won&rsquo;t emphasise: the accelerated cadence benefits <em>their</em> cloud economics more directly than yours. Faster obsolescence drives Azure consumption of newer, optimised runtimes. Is that wrong? Not necessarily—but let&rsquo;s not pretend the three-year LTS cycle was designed purely for developer convenience.</p><h2 id="the-cost-of-waiting-dependency-and-developer-coupling"><a href="/posts/timing-is-the-new-technical-debt/#the-cost-of-waiting-dependency-and-developer-coupling" title="The Cost of Waiting: Dependency and Developer Coupling">The Cost of Waiting: Dependency and Developer Coupling</a></h2><p>Consider a financial-services platform still running on .NET 6.
Half its modules are maintained in-house, the rest by partner vendors and open-source projects.
When a critical CVE appears in a transitive dependency—a telemetry or cryptography library, for instance—the internal teams can patch immediately. External vendors, however, must retest their modules and go through governance reviews. Open-source dependencies may require upstream fixes before new packages are even available.</p><p>The result is version drift, duplicated effort, and expensive manual verification during audits.
Security teams document exception after exception because not every library can be updated on command. Over a year, this coordination friction costs hundreds of engineer hours and more than <strong>€200 000</strong> in compliance overhead—without producing a single new feature.</p><p>Here&rsquo;s a real-world pattern I&rsquo;ve seen repeatedly: teams add workarounds instead of addressing root causes.</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="c1">// Legacy .NET 6 workaround for incompatible dependency</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">class</span> <span class="nc">LegacyTelemetryAdapter</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="k">readonly</span> <span class="n">OldTelemetryClient</span> <span class="n">_client</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">async</span> <span class="n">Task</span> <span class="n">LogEventAsync</span><span class="p">(</span><span class="kt">string</span> <span class="n">eventName</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Manual serialization because the library doesn&#39;t support modern JSON APIs</span>
</span></span><span class="line"><span class="cl">        <span class="kt">var</span> <span class="n">json</span> <span class="p">=</span> <span class="n">JsonConvert</span><span class="p">.</span><span class="n">SerializeObject</span><span class="p">(</span><span class="k">new</span> <span class="p">{</span> <span class="n">Event</span> <span class="p">=</span> <span class="n">eventName</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">        <span class="k">await</span> <span class="n">_client</span><span class="p">.</span><span class="n">SendAsync</span><span class="p">(</span><span class="n">json</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Modern .NET 10 approach with updated dependency</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">class</span> <span class="nc">ModernTelemetryAdapter</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="k">readonly</span> <span class="n">ITelemetryClient</span> <span class="n">_client</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">async</span> <span class="n">Task</span> <span class="n">LogEventAsync</span><span class="p">(</span><span class="kt">string</span> <span class="n">eventName</span><span class="p">,</span> <span class="n">CancellationToken</span> <span class="n">cancellationToken</span> <span class="p">=</span> <span class="k">default</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">await</span> <span class="n">_client</span><span class="p">.</span><span class="n">TrackEventAsync</span><span class="p">(</span><span class="n">eventName</span><span class="p">,</span> <span class="n">cancellationToken</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>The adapter pattern above isn&rsquo;t clever engineering—it&rsquo;s technical debt accrued because upgrading the underlying telemetry library required upgrading the runtime first. Once the runtime is modern, the dependency can be modern, and the adapter disappears entirely.</p><p>Migrating to .NET 10 does not magically eliminate these dependencies—but it provides a unified, modern baseline where dependency visibility, communication, and automation can finally work together.
Organisations that succeed at this treat dependencies as part of their supply chain.
They <strong>communicate proactively</strong> with external maintainers, <strong>track dependency status</strong> across internal and external repositories, and, where appropriate, <strong>contribute back</strong>—through pull requests, sponsorships, or shared testing infrastructure.</p><p>Supporting critical open-source projects is not altruism; it’s risk management.
When your business depends on their libraries, your stability is their stability.
A mature migration strategy therefore includes not only upgrading your code, but also strengthening the ecosystem you rely on.</p><h2 id="migration-as-strategic-sequencing"><a href="/posts/timing-is-the-new-technical-debt/#migration-as-strategic-sequencing" title="Migration as Strategic Sequencing">Migration as Strategic Sequencing</a></h2><p>Methodologies like the “7 Rs” describe what kind of migration you perform—rehost, refactor, rebuild—but timing determines whether it delivers value.
A successful .NET 10 transition sequences work around three axes:</p><ol><li><strong>Economic criticality</strong> – modernise the workloads that generate or protect revenue first.</li><li><strong>Lifecycle synchronisation</strong> – align runtime upgrades with dependency refreshes.</li><li><strong>Collaboration readiness</strong> – ensure partners and open-source maintainers have the same timeline and resources.</li></ol><p>A <strong>Q1 2026</strong> target window achieves that balance: early enough to capture the efficiency and governance gains, late enough to benefit from ecosystem maturity.</p><h2 id="timing-as-a-financial-lever"><a href="/posts/timing-is-the-new-technical-debt/#timing-as-a-financial-lever" title="Timing as a Financial Lever">Timing as a Financial Lever</a></h2><p>The <strong>three-year LTS horizon</strong> turns migration into a budget decision with measurable ROI.
Move in Q1 2026 and enjoy full vendor support until late 2028.
Move a year later and your amortisation window shortens to two years—an immediate 33 % reduction in return potential.</p><p>Early .NET 10 preview benchmarks show promising efficiency gains: memory allocations down 15-20% in high-throughput APIs, container startup times improved by roughly 12%, and GC pause times reduced in server workloads. These aren&rsquo;t marketing numbers—they&rsquo;re patterns emerging from pre-release testing. Whether they hold in production across all workload types remains to be seen, but the direction is clear.</p><p>Across container clusters and cloud-native deployments, these savings compound quickly.
When timing and governance align, migration cost is recovered long before the next LTS arrives.</p><h2 id="the-economics-of-confidence"><a href="/posts/timing-is-the-new-technical-debt/#the-economics-of-confidence" title="The Economics of Confidence">The Economics of Confidence</a></h2><p>Organisations that manage timing as a discipline rather than a reaction consistently outperform peers in both cost control and security posture.
Those that plan their migration now, test preview builds through late 2025, and execute in Q1 2026 achieve three enduring advantages:</p><ul><li><strong>Predictable stability</strong> through 2028 under full vendor support.</li><li><strong>Unified dependency and security governance</strong>, supported by transparent communication with external maintainers.</li><li><strong>Stronger developer engagement</strong> by investing in an ecosystem, not just a runtime.</li></ul><p>Waiting until necessity forces change means continuing to pay the coordination tax: drifted dependencies, fragmented toolchains, and constant exception handling.</p><h2 id="conclusion"><a href="/posts/timing-is-the-new-technical-debt/#conclusion" title="Conclusion">Conclusion</a></h2><p>The .NET ecosystem has matured; the economic model around it has changed.
Where upgrades once felt optional, they have become part of responsible cost management.
Migrating to <strong>.NET 10</strong> is not a shortcut to perfection—it&rsquo;s an entry ticket to a healthier, more predictable ecosystem.</p><p>Targeting completion in <strong>Q1 2026</strong> is not about speed; it&rsquo;s about synchrony.
Those who plan early, communicate clearly with dependency owners, and support the open-source projects they rely on will enjoy a three-year runway of stability and efficiency.
Those who delay will discover that in software, as in finance, <strong>interest compounds fastest on silence and inaction</strong>.</p><p>I&rsquo;ve watched too many teams postpone migrations <em>just one more quarter</em>—only to find themselves two versions behind, scrambling during a security incident, with vendors no longer prioritising their framework version. That scramble is expensive, stressful, and entirely avoidable.</p><p>In this new era, the biggest risk isn&rsquo;t outdated code—it&rsquo;s unspoken dependencies and unplanned timing.</p></section><h2>Comments</h2><aside class="giscus"></aside><script src="https://giscus.app/client.js" data-repo="dailydevops/dailydevops.github.io" data-repo-id="R_kgDOHA8eFg" data-category="Announcements" data-category-id="DIC_kwDOHA8eFs4COIqL" data-mapping="pathname" data-strict="1" data-reactions-enabled="0" data-emit-metadata="0" data-input-position="bottom" data-theme="light" data-lang="en" crossorigin="anonymous" async></script></article><aside class="sidebar divider"><section class="sidecar info"><ul><li><time datetime="2025-10-28T09:30:00+01:00">Published on 10/28/25 9:30 am</time></li><li>Read in 7 minutes</li></ul></section><section class="sidecar author"><header><h2><a href="/authors/martin/" rel="author" title="Martin Stühmer">Author Martin Stühmer</a></h2></header><figure class="round"><picture><img src="https://www.gravatar.com/avatar/6da4a47ff9cc2b750452225fdb2582f7?d=identicon&amp;s=200" alt="Martin Stühmer" loading="lazy" decoding="async" title="Martin Stühmer"></picture></figure><section class="content">Martin is a seasoned software architect and developer based in the Cologne/Bonn area, with over 15 years of experience in utilizing .NET and Microsoft technologies in his work. His expertise lies in enhancing the quality and performance of development teams, optimizing software solutions for target environments, and maximizing application efficiency. Currently serving as the Director Consulting Services at CGI, he specializes in cloud-native and .NET solutions, while also providing training in cloud and software architecture. Beyond his professional endeavors, Martin actively contributes to open-source communities by offering various NuGet packages. In 2021, he achieved certifications as an IHK instructor and Microsoft certified trainer, furthering his commitment to continuous learning. Additionally, he became a certified trainer for CGI’s Risk and Cost Driven Architecture program in 2022.</section><a class="link" href="/authors/martin/" rel="author" title="Martin Stühmer"></a></section><section class="sidecar social"><header><h2>Social media</h2></header><a class="icon bluesky" href="https://bsky.app/profile/samtrion.net" rel="noopener external" title="Follow me on Bluesky" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-bluesky fa-stack-1x fa-inverse"></i>
</span></a><a class="icon github" href="https://github.com/samtrion" rel="noopener external" title="Follow me on GitHub" target="_blank"><i class="fa-brands fa-fw fa-github fa-2x"></i></a>
<a class="icon linkedin" href="https://www.linkedin.com/in/martin-stuehmer" rel="noopener external" title="Follow me on LinkedIn" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-linkedin-in fa-stack-1x fa-inverse"></i>
</span></a><a class="icon stackoverflow" href="https://stackoverflow.com/users/10574963" rel="noopener external" title="Follow me on Stack Overflow" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-stack-overflow fa-stack-1x fa-inverse"></i>
</span></a><a class="icon mail" href="mailto:martin@daily-devops.net" title="Contact me by e-mail" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
</span></a><a class="icon feed" href="/authors/martin/feed.rss" title="My RSS feed" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></section><section class="sidecar share"><header><h2>Share this content</h2></header><a class="icon linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fdaily-devops.net%2fposts%2ftiming-is-the-new-technical-debt%2f&text=.NET%2010%3a%20Timing%20Is%20the%20New%20Technical%20Debt%0a%20%26mdash%3b%20Daily%20DevOps%20%26%20.NET" target="_blank" rel="noopener external" aria-label="Share on LinkedIn" title="Share on LinkedIn" target="_blank"><i class="fa-brands fa-fw fa-linkedin-in fa-2x"></i></a>
<a class="icon bluesky" href="https://bsky.app/intent/compose?text=.NET%2010%3a%20Timing%20Is%20the%20New%20Technical%20Debt%0a%20%26mdash%3b%20Daily%20DevOps%20%26%20.NET%20https%3a%2f%2fdaily-devops.net%2fposts%2ftiming-is-the-new-technical-debt%2f" target="_blank" rel="noopener external" aria-label="Share on Bluesky" title="Share on Bluesky" target="_blank"><i class="fa-brands fa-fw fa-bluesky fa-2x"></i></a></section><section class="sidecar tags"><header><h2>Tags</h2></header><ul><li class="tag"><a href="/tags/dotnet/" hreflang="en" rel="tag" title=".NET"><i class="fas fa-tag"></i>&nbsp;.NET</a></li><li class="tag"><a href="/tags/architecture/" hreflang="en" rel="tag" title="Architecture"><i class="fas fa-tag"></i>&nbsp;Architecture</a></li><li class="tag"><a href="/tags/bestpractices/" hreflang="en" rel="tag" title="Best Practices"><i class="fas fa-tag"></i>&nbsp;Best Practices</a></li><li class="tag"><a href="/tags/csharp/" hreflang="en" rel="tag" title="C#"><i class="fas fa-tag"></i>&nbsp;C#</a></li><li class="tag"><a href="/tags/performance/" hreflang="en" rel="tag" title="Performance"><i class="fas fa-tag"></i>&nbsp;Performance</a></li><li class="tag"><a href="/tags/technicaldebt/" hreflang="en" rel="tag" title="Technical Debt"><i class="fas fa-tag"></i>&nbsp;Technical Debt</a></li></ul></section><section class="sidecar related"><header><h2>Related content</h2></header><article class="post"><figure class="square"><picture><source srcset="/images/csharp-80x80.webp?v=2009610da0e7ad52e611197cf3092830" type="image/webp"><source srcset="/images/csharp-80x80.png?v=c5d685b0d4fa9ec69bd959ee04beb903" type="image/png"><img src="/images/csharp.png?v=21ff9dcf5d1da7bfa80141c972c117da" alt="Stop Parsing the Same String Twice: CompositeFormat in .NET" loading="lazy" decoding="async" title="Stop Parsing the Same String Twice: CompositeFormat in .NET"></picture></figure><header><h2><a href="/posts/compositeformat-performance-boost/" rel="bookmark">Stop Parsing the Same String Twice: CompositeFormat in .NET</a></h2></header><section class="content">Every time you call <code>string.Format()</code> with the same format string, .NET parses it again. And again. And again. CompositeFormat changes that: parse once, reuse forever. The result? Up to 30% faster formatting, fewer allocations, and a one-line code change. Here&rsquo;s why this matters and how to use it.</section></article><article class="post"><figure class="square"><picture><source srcset="/images/vibecoding-80x80.webp?v=627bd7d4bf89f079951c78503a124358" type="image/webp"><source srcset="/images/vibecoding-80x80.png?v=7617a55dbdf6bd7939238821b77c1a82" type="image/png"><img src="/images/vibecoding.png?v=9a36076d86533930bbd6319c257968b9" alt="Vibe Coding in .NET: Creative Catalyst or Maintenance Risk?" loading="lazy" decoding="async" title="Vibe Coding in .NET: Creative Catalyst or Maintenance Risk?"></picture></figure><header><h2><a href="/posts/vibe-coding-isnt-wrong-its-unfinished/" rel="bookmark">Vibe Coding in .NET: Creative Catalyst or Maintenance Risk?</a></h2></header><section class="content"><p>In the world of software development, there’s a recurring tension between <strong>discipline and improvisation</strong>. Somewhere along that spectrum lies a phenomenon increasingly referred to as <strong>Vibe Coding</strong>. The term evokes a style of development where engineers follow intuition and momentum rather than formal plans, processes, or design patterns.</p><p>It’s fast, fluid, and occasionally brilliant. But is it sustainable in a .NET-based enterprise context?</p></section></article><article class="post"><figure class="square"><picture><source srcset="/images/csharp-80x80.webp?v=2009610da0e7ad52e611197cf3092830" type="image/webp"><source srcset="/images/csharp-80x80.png?v=c5d685b0d4fa9ec69bd959ee04beb903" type="image/png"><img src="/images/csharp.png?v=21ff9dcf5d1da7bfa80141c972c117da" alt="How SearchValues Saved Us From Scaling Hell" loading="lazy" decoding="async" title="How SearchValues Saved Us From Scaling Hell"></picture></figure><header><h2><a href="/posts/searchvalues-saved-us-from-scaling-hell/" rel="bookmark">How SearchValues<t> Saved Us From Scaling Hell</a></h2></header><section class="content"><p>While you&rsquo;re busy optimizing database queries and adding cache layers, thousands of string searches per second are quietly eating your CPU budget. The problem isn&rsquo;t visible in your APM dashboard because it&rsquo;s distributed across every request. But it&rsquo;s there. Compounding. Scaling linearly with load.</p><p>I discovered this the hard way when a log processing API started choking under production traffic. The bottleneck? String validation and sanitization. The fix? A .NET 8 feature that delivered a <strong>5x performance improvement</strong> and let us shut down servers instead of adding them. And it&rsquo;s gotten even better in .NET 9 and 10.</p></section></article></section></aside><nav class="pager"><a class="next" href="/posts/netevolve-healthchecks/" title="Configuration-First Health Checks for Modern .NET" rel="next"><span class="sub"><i class="fas fa-backward"></i>&emsp;Next</span><p class="title">Configuration-First Health Checks for Modern .NET</p></a><a class="prev" href="/posts/compositeformat-performance-boost/" title="Stop Parsing the Same String Twice: CompositeFormat in .NET" rel="prev"><span class="sub">Previous&emsp;<i class="fas fa-forward"></i></span><p class="title">Stop Parsing the Same String Twice: CompositeFormat in .NET</p></a></nav></main><footer class="footer"><div class="divider"></div><nav><ul class="navigation"><li><a href="/tags/">Tags</a></li><li><a href="/legal-notice/">Legal notice</a></li></ul></nav><div class="copyright">&copy; 2023 - 2025 Daily DevOps & .NET</div></footer><script defer src="/js/below.min.a6ce9164454b6077f17ae856f280442d9f3a1e21f06189f71c21f75144b22a0c8cf32bafd61d440e9d90ca02bf738b6a8ef19f5ec20285d8ca574f98c91ebaf2.js" integrity="sha512-ps6RZEVLYHfxeuhW8oBELZ86HiHwYYn3HCH3UUSyKgyM8yuv1h1EDp2QygK/c4tqjvGfXsIChdjKV0+YyR668g==" crossorigin="anonymous"></script><img class="vgwort" src="https://vg06.met.vgwort.de/na/9b3660c486ee4d30b3caeddce22becf3" width="1" height="1" alt="VG Wort" title="VG Wort"></body></html>