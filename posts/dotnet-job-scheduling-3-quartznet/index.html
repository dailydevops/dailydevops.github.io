<!doctype html><html class="no-js" lang="en" dir="ltr"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="theme-color" content="#15a"><title>.NET Job Scheduling — Quartz.NET for Enterprise Scale — Daily DevOps & .NET</title><meta name="description" content="Quartz.NET provides advanced scheduling semantics, database-backed clustering, and flexible storage for systems demanding complex workflows.
Understand when …"><meta name="twitter:description" property="og:description" content="Quartz.NET provides advanced scheduling semantics, database-backed clustering, and flexible storage for systems demanding complex workflows.
Understand when …"><meta name="author" content="Martin Stühmer"><link rel="icon" href="/logo.svg?v=b9e294dc5c6fa04439c8c803d8e981a9" sizes="any" type="image/svg+xml"><meta name="twitter:title" property="og:title" content=".NET Job Scheduling — Quartz.NET for Enterprise Scale — Daily DevOps & .NET"><meta property="og:updated_time" content="2025-12-02T17:06:02+01:00"><meta property="article:modified_time" content="2025-12-02T17:06:02+01:00"><meta property="article:published_time" content="2025-12-02T17:00:00+01:00"><meta property="og:type" content="article"><meta property="og:site_name" content="Daily DevOps & .NET"><meta property="og:url" content="https://daily-devops.net/posts/dotnet-job-scheduling-3-quartznet/"><meta property="og:locale" content="en_US"><meta name="twitter:card" content="summary_large_image"><meta property="og:image" name="twitter:image" content="https://daily-devops.net/images/nuget-scheduler-1200x630.webp?v=eba4478bafcb44a0d9c21fa64f2358ee"><meta property="og:image:secure_url" content="https://daily-devops.net/images/nuget-scheduler-1200x630.webp?v=eba4478bafcb44a0d9c21fa64f2358ee"><meta property="og:image:alt" name="twitter:image:alt" content=".NET Job Scheduling — Quartz.NET for Enterprise Scale"><meta property="og:image:type" content="image/webp"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta property="og:image" name="twitter:image" content="https://daily-devops.net/images/nuget-scheduler-1200x630.png?v=16dd667ddd31353e2d9ebc222586164d"><meta property="og:image:secure_url" content="https://daily-devops.net/images/nuget-scheduler-1200x630.png?v=16dd667ddd31353e2d9ebc222586164d"><meta property="og:image:alt" name="twitter:image:alt" content=".NET Job Scheduling — Quartz.NET for Enterprise Scale"><meta property="og:image:type" content="image/png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><link rel="dns-prefetch" href="https://www.clarity.ms"><link rel="preconnect" href="https://www.clarity.ms" crossorigin><link rel="stylesheet" href="/css/style.min.0a82b1a011c427b8ad7101f4d2af27d8fdb035d1938344df11bd53b8ee18381e7feaff6dda5dc3769214cc3fd8070373bdaf19c5e92f9a772e2769a03ac862cc.css" integrity="sha512-CoKxoBHEJ7itcQH00q8n2P2wNdGTg0TfEb1TuO4YOB5/6v9t2l3DdpIUzD/YBwNzva8ZxekvmncuJ2mgOshizA==" crossorigin="anonymous"><link rel="alternate" href='https://daily-devops.net/posts/dotnet-job-scheduling-3-quartznet/' hreflang="x-default" title=".NET Job Scheduling — Quartz.NET for Enterprise Scale &mdash; Daily DevOps & .NET"><link rel="canonical" href="https://daily-devops.net/posts/dotnet-job-scheduling-3-quartznet/" hreflang="en-us" title=".NET Job Scheduling — Quartz.NET for Enterprise Scale &mdash; Daily DevOps & .NET"><link rel="home" href="https://daily-devops.net/" hreflang="en-us" title="Daily DevOps & .NET"><link rel="prev" href="https://daily-devops.net/posts/dotnet-job-scheduling-2-hangfire/" hreflang="en-us" title=".NET Job Scheduling — Hangfire and Persistent Reliability"><link rel="author" href="https://daily-devops.net/authors/martin/" hreflang="en-us" title="Martin Stühmer &mdash; Daily DevOps & .NET"><meta name="giscus:backlink" content="https://daily-devops.net/posts/dotnet-job-scheduling-3-quartznet/"><script defer src="/js/above.min.cb42b2c9a453e49e278326637d72d2f01e7f32e3f91e9cdde8fb587793d05514efd2f5cc5021c9658ca0f73876dbdcd1f7cb4a37c0bebc9df01110926b6d7cba.js" integrity="sha512-y0KyyaRT5J4ngyZjfXLS8B5/MuP5Hpzd6PtYd5PQVRTv0vXMUCHJZYyg9zh229zR98tKN8C+vJ3wERCSa218ug==" crossorigin="anonymous"></script><script type="text/javascript">(function(e,t,n,s,o,i,a){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)},i=t.createElement(s),i.async=1,i.src="https://www.clarity.ms/tag/"+o,a=t.getElementsByTagName(s)[0],a.parentNode.insertBefore(i,a)})(window,document,"clarity","script","o0pr4n9gg3")</script></head><body class="container"><header class="header"><a class="logo" href="/" title="Daily DevOps & .NET" rel="home"><figure class="page-logo"><picture><img src="/logo.svg?v=b9e294dc5c6fa04439c8c803d8e981a9" alt="Daily DevOps & .NET" title="Daily DevOps & .NET"></picture></figure><span class="title">Daily DevOps & .NET</span></a><nav class="menu"><button class="burger" aria-haspopup="true" aria-expanded="false" tabindex="0">
<i class="fas fa-burger"></i></button><ul class="navigation"><li class="active"><a href="/posts/">Posts</a></li><li><a href="/authors/">About us</a></li></ul></nav><div class="divider"></div></header><main class="body"><figure class="hero"><picture><source srcset="/images/nuget-scheduler-544x136.webp?v=4d010c553641ee8fe9a52f00774b9461" type="image/webp" media="(max-width: 575.98px)"><source srcset="/images/nuget-scheduler-544x136.png?v=f24f4c05bcbce7421f53568505a29f42" type="image/png" media="(max-width: 575.98px)"><source srcset="/images/nuget-scheduler-672x168.webp?v=ab0c2859bfebaf0bbabc012f9515c9d1" type="image/webp" media="(max-width: 767.98px)"><source srcset="/images/nuget-scheduler-672x168.png?v=9081a48ed39bbcf72048c71e59f757bf" type="image/png" media="(max-width: 767.98px)"><source srcset="/images/nuget-scheduler-896x224.webp?v=ef58a1d1cb3f0471f86bc4b75e52cd63" type="image/webp" media="(max-width: 991.98px)"><source srcset="/images/nuget-scheduler-896x224.png?v=2e6bb71535af5f7bbaa14618564af8db" type="image/png" media="(max-width: 991.98px)"><source srcset="/images/nuget-scheduler-1104x276.webp?v=ca587b49fe5a9c68080bb103391f501b" type="image/webp" media="(max-width: 1199.98px)"><source srcset="/images/nuget-scheduler-1104x276.png?v=13c4fd9c98192929ddcca480ea783609" type="image/png" media="(max-width: 1199.98px)"><source srcset="/images/nuget-scheduler-1444x361.webp?v=3b93b7c3af2fa3020bad36fd06974cc2" type="image/webp"><source srcset="/images/nuget-scheduler-1444x361.png?v=5e8383f2e2acb3de1df045ebc65e458d" type="image/png"><img src="/images/nuget-scheduler.png?v=4159bfd7c08b58b0fc741782fe532741" alt=".NET Job Scheduling — Quartz.NET for Enterprise Scale" loading="lazy" decoding="async" title=".NET Job Scheduling — Quartz.NET for Enterprise Scale"></picture></figure><article class="post"><header><h1>.NET Job Scheduling — Quartz.NET for Enterprise Scale</h1></header><section class="content"><p>Your financial platform processes millions of transactions daily. At midnight, the system must calculate interest for every account, generate regulatory reports, and trigger fraud detection sweeps. These tasks cannot overlap—interest calculation must complete before reporting begins. Some jobs repeat hourly, others run on the last business day of each month, skipping holidays. A single scheduler instance cannot handle the throughput, but multiple instances must coordinate to prevent duplicate execution.</p><p>This is Quartz.NET&rsquo;s domain: enterprise-grade job scheduling where complexity, throughput, and reliability intersect. Quartz.NET targets systems with demanding scheduling semantics—job calendars that respect business rules, priority-based execution, clustering across datacenters, and integration with external monitoring infrastructure.</p><p>The trade-off: operational complexity. Quartz.NET requires careful configuration, understanding of its architectural patterns, and infrastructure to support distributed coordination. For systems where scheduling is a first-class concern—ETL pipelines, financial batch processing, multi-tenant SaaS platforms—this investment pays dividends. For applications where background jobs are secondary concerns, the complexity may outweigh the benefits.</p><h2 id="architecture-jobs-triggers-and-the-scheduler"><a href="/posts/dotnet-job-scheduling-3-quartznet/#architecture-jobs-triggers-and-the-scheduler" title="Architecture: Jobs, Triggers, and the Scheduler">Architecture: Jobs, Triggers, and the Scheduler</a></h2><p>Quartz.NET&rsquo;s architecture decomposes scheduling into three core abstractions: jobs, triggers, and the scheduler.</p><p><strong>Jobs</strong> define what to execute. They implement <code>IJob</code>, a single-method interface:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">class</span> <span class="nc">InterestCalculationJob</span> <span class="p">:</span> <span class="n">IJob</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">async</span> <span class="n">Task</span> <span class="n">Execute</span><span class="p">(</span><span class="n">IJobExecutionContext</span> <span class="n">context</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">var</span> <span class="n">accountService</span> <span class="p">=</span> <span class="n">context</span><span class="p">.</span><span class="n">JobDetail</span><span class="p">.</span><span class="n">JobDataMap</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="s">&#34;accountService&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">await</span> <span class="n">accountService</span><span class="p">.</span><span class="n">CalculateInterestAsync</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Jobs are stateless. The scheduler instantiates them on demand, injects dependencies via job data maps or DI containers, and discards them after execution. This statelessness enables clustering: any scheduler instance can execute any job without requiring sticky sessions or shared state.</p><p><strong>Triggers</strong> define when jobs execute. Quartz.NET supports several trigger types:</p><ul><li><strong>Simple triggers</strong>: Execute once after a delay or repeat at fixed intervals.</li><li><strong>Cron triggers</strong>: Use cron expressions for complex schedules like &ldquo;every Monday at 9 AM&rdquo; or &ldquo;the last Friday of each month.&rdquo;</li><li><strong>Calendar interval triggers</strong>: Repeat at intervals respecting business calendars—every month, every quarter, skipping holidays.</li><li><strong>Daily time interval triggers</strong>: Run between specific hours on selected days—useful for jobs that should only execute during business hours.</li></ul><p>Triggers can include misfire policies—rules for handling missed executions when the scheduler is offline or overloaded. For example, a trigger might specify &ldquo;execute immediately upon recovery&rdquo; or &ldquo;skip missed executions and wait for the next scheduled time.&rdquo;</p><p><strong>The scheduler</strong> coordinates jobs and triggers. It stores definitions in persistent storage (SQL Server, PostgreSQL, Oracle, or in-memory), polls for triggers whose fire times have arrived, claims them atomically to prevent duplicate execution, and dispatches jobs to worker threads.</p><p>Quartz.NET&rsquo;s scheduler supports clustering: multiple instances share the same database, coordinating via database locks. When a trigger fires, one instance claims it using optimistic locking (<code>UPDATE ... WHERE locked_by IS NULL</code>). If the instance crashes mid-execution, another instance detects the orphaned job and recovers it based on the trigger&rsquo;s misfire policy.</p><p>This design scales horizontally. Add more scheduler instances to increase throughput. Each instance competes for jobs via database coordination, distributing workload automatically without manual partitioning or configuration.</p><h2 id="configuration-and-integration-with-aspnet-core"><a href="/posts/dotnet-job-scheduling-3-quartznet/#configuration-and-integration-with-aspnet-core" title="Configuration and Integration with ASP.NET Core">Configuration and Integration with ASP.NET Core</a></h2><p>Integrating Quartz.NET into an ASP.NET Core application involves configuring storage, defining jobs and triggers, and starting the scheduler.</p><p>First, install the NuGet packages:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">dotnet add package Quartz
</span></span><span class="line"><span class="cl">dotnet add package Quartz.Extensions.Hosting
</span></span><span class="line"><span class="cl">dotnet add package Quartz.Serialization.Json
</span></span><span class="line"><span class="cl">dotnet add package Quartz.Plugins
</span></span></code></pre></div><p>Second, configure the scheduler in <code>Program.cs</code>:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="n">builder</span><span class="p">.</span><span class="n">Services</span><span class="p">.</span><span class="n">AddQuartz</span><span class="p">(</span><span class="n">q</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">q</span><span class="p">.</span><span class="n">UseMicrosoftDependencyInjectionJobFactory</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">q</span><span class="p">.</span><span class="n">UsePersistentStore</span><span class="p">(</span><span class="n">s</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">s</span><span class="p">.</span><span class="n">UsePostgres</span><span class="p">(</span><span class="s">&#34;Host=localhost;Database=quartz;&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">s</span><span class="p">.</span><span class="n">UseJsonSerializer</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">var</span> <span class="n">jobKey</span> <span class="p">=</span> <span class="k">new</span> <span class="n">JobKey</span><span class="p">(</span><span class="s">&#34;InterestCalculation&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">q</span><span class="p">.</span><span class="n">AddJob</span><span class="p">&lt;</span><span class="n">InterestCalculationJob</span><span class="p">&gt;(</span><span class="n">opts</span> <span class="p">=&gt;</span> <span class="n">opts</span><span class="p">.</span><span class="n">WithIdentity</span><span class="p">(</span><span class="n">jobKey</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">q</span><span class="p">.</span><span class="n">AddTrigger</span><span class="p">(</span><span class="n">opts</span> <span class="p">=&gt;</span> <span class="n">opts</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">ForJob</span><span class="p">(</span><span class="n">jobKey</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">WithIdentity</span><span class="p">(</span><span class="s">&#34;InterestCalculation-trigger&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">WithCronSchedule</span><span class="p">(</span><span class="s">&#34;0 0 0 * * ?&#34;</span><span class="p">));</span> <span class="c1">// Daily at midnight</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">builder</span><span class="p">.</span><span class="n">Services</span><span class="p">.</span><span class="n">AddQuartzHostedService</span><span class="p">(</span><span class="n">q</span> <span class="p">=&gt;</span> <span class="n">q</span><span class="p">.</span><span class="n">WaitForJobsToComplete</span> <span class="p">=</span> <span class="kc">true</span><span class="p">);</span>
</span></span></code></pre></div><p>This configuration uses PostgreSQL for storage, schedules a job to run daily at midnight, and ensures the scheduler waits for jobs to complete during application shutdown.</p><p>Quartz.NET&rsquo;s hosted service integration leverages ASP.NET Core&rsquo;s <code>IHostedService</code>, starting and stopping the scheduler alongside the application lifecycle. The <code>WaitForJobsToComplete</code> option ensures graceful shutdowns: the scheduler finishes executing jobs before the application terminates, preventing interrupted workflows.</p><p>Jobs receive dependencies via constructor injection when using <code>UseMicrosoftDependencyInjectionJobFactory()</code>. This eliminates the need for manual service resolution:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">class</span> <span class="nc">ReportGenerationJob</span> <span class="p">:</span> <span class="n">IJob</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="k">readonly</span> <span class="n">IReportService</span> <span class="n">_reportService</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">ReportGenerationJob</span><span class="p">(</span><span class="n">IReportService</span> <span class="n">reportService</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">_reportService</span> <span class="p">=</span> <span class="n">reportService</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">async</span> <span class="n">Task</span> <span class="n">Execute</span><span class="p">(</span><span class="n">IJobExecutionContext</span> <span class="n">context</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">await</span> <span class="n">_reportService</span><span class="p">.</span><span class="n">GenerateMonthlyReportAsync</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>The scheduler resolves <code>IReportService</code> from the DI container and injects it into the job. This integration feels native to ASP.NET Core, reducing boilerplate compared to manual service location patterns.</p><h2 id="advanced-scheduling-calendars-and-misfires"><a href="/posts/dotnet-job-scheduling-3-quartznet/#advanced-scheduling-calendars-and-misfires" title="Advanced Scheduling: Calendars and Misfires">Advanced Scheduling: Calendars and Misfires</a></h2><p>Quartz.NET&rsquo;s calendar support enables business-aware scheduling. Calendars exclude specific dates—holidays, maintenance windows—from trigger schedules. For example, a job scheduled to run daily except holidays:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">holidays</span> <span class="p">=</span> <span class="k">new</span> <span class="n">HolidayCalendar</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">holidays</span><span class="p">.</span><span class="n">AddExcludedDate</span><span class="p">(</span><span class="k">new</span> <span class="n">DateTime</span><span class="p">(</span><span class="m">2025</span><span class="p">,</span> <span class="m">12</span><span class="p">,</span> <span class="m">25</span><span class="p">));</span> <span class="c1">// Christmas</span>
</span></span><span class="line"><span class="cl"><span class="n">holidays</span><span class="p">.</span><span class="n">AddExcludedDate</span><span class="p">(</span><span class="k">new</span> <span class="n">DateTime</span><span class="p">(</span><span class="m">2025</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">1</span><span class="p">));</span>   <span class="c1">// New Year</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">await</span> <span class="n">scheduler</span><span class="p">.</span><span class="n">AddCalendar</span><span class="p">(</span><span class="s">&#34;US-Holidays&#34;</span><span class="p">,</span> <span class="n">holidays</span><span class="p">,</span> <span class="n">replace</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="n">updateTriggers</span><span class="p">:</span> <span class="kc">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">trigger</span> <span class="p">=</span> <span class="n">TriggerBuilder</span><span class="p">.</span><span class="n">Create</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">WithIdentity</span><span class="p">(</span><span class="s">&#34;DailyProcessing&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">WithCronSchedule</span><span class="p">(</span><span class="s">&#34;0 9 * * ?&#34;</span><span class="p">,</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span><span class="p">.</span><span class="n">InTimeZone</span><span class="p">(</span><span class="n">TimeZoneInfo</span><span class="p">.</span><span class="n">FindSystemTimeZoneById</span><span class="p">(</span><span class="s">&#34;Eastern Standard Time&#34;</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">ModifiedByCalendar</span><span class="p">(</span><span class="s">&#34;US-Holidays&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">Build</span><span class="p">();</span>
</span></span></code></pre></div><p>This trigger fires at 9 AM daily, Eastern Time, but skips days marked in the <code>US-Holidays</code> calendar. Quartz.NET evaluates calendars during trigger computation, deferring execution to the next valid day.</p><p>Calendar types include:</p><ul><li><strong>HolidayCalendar</strong>: Exclude specific dates.</li><li><strong>CronCalendar</strong>: Exclude dates matching a cron expression.</li><li><strong>DailyCalendar</strong>: Exclude time ranges (e.g., &ldquo;skip execution between 2 AM and 6 AM&rdquo;).</li><li><strong>MonthlyCalendar</strong>: Exclude specific days of the month.</li></ul><p>Combining calendars creates sophisticated rules. A trigger might exclude weekends, holidays, and the first Monday of each month—all declaratively, without custom logic.</p><p><strong>Misfire policies</strong> handle execution gaps when the scheduler is offline or overloaded. If a job scheduled for 2 AM doesn&rsquo;t execute until 3 AM because the scheduler was down, the misfire policy determines behavior:</p><ul><li><strong>DoNothing</strong>: Skip the missed execution.</li><li><strong>FireNow</strong>: Execute immediately upon recovery.</li><li><strong>FireAndProceed</strong>: Execute missed runs, then continue with the normal schedule.</li><li><strong>FireOnceNow</strong>: Execute once immediately, then resume the schedule.</li></ul><p>Configure misfire policies per trigger:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">trigger</span> <span class="p">=</span> <span class="n">TriggerBuilder</span><span class="p">.</span><span class="n">Create</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">WithIdentity</span><span class="p">(</span><span class="s">&#34;DataImport&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">WithCronSchedule</span><span class="p">(</span><span class="s">&#34;0 0 2 * * ?&#34;</span><span class="p">,</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span><span class="p">.</span><span class="n">WithMisfireHandlingInstructionFireAndProceed</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">Build</span><span class="p">();</span>
</span></span></code></pre></div><p>This trigger ensures missed nightly imports execute upon scheduler recovery, preventing data gaps.</p><h2 id="clustering-and-distributed-coordination"><a href="/posts/dotnet-job-scheduling-3-quartznet/#clustering-and-distributed-coordination" title="Clustering and Distributed Coordination">Clustering and Distributed Coordination</a></h2><p>Quartz.NET&rsquo;s clustering enables horizontal scaling and high availability. Multiple scheduler instances share a database, coordinating via optimistic locking to prevent duplicate job execution. I&rsquo;ve run three-node Quartz.NET clusters processing 15,000+ jobs daily, and the coordination works—but you need to understand what&rsquo;s happening under the hood.</p><p>When a trigger fires, the scheduler that claims it updates a database row with its instance ID:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">UPDATE</span><span class="w"> </span><span class="n">qrtz_triggers</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SET</span><span class="w"> </span><span class="k">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;ACQUIRED&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">instance_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;scheduler-01&#39;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="k">trigger_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;DataImport&#39;</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="k">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;WAITING&#39;</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>Only one scheduler succeeds. Others skip the trigger and poll for the next available job. This database-based coordination avoids requiring external coordination services like ZooKeeper or Consul.</p><p>If a scheduler crashes mid-execution, orphaned jobs remain in the <code>ACQUIRED</code> state. A recovery thread detects these jobs (based on a timeout threshold) and resets them to <code>WAITING</code>, allowing another scheduler to claim them. The interval and timeout are configurable:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="n">q</span><span class="p">.</span><span class="n">UsePersistentStore</span><span class="p">(</span><span class="n">s</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="p">.</span><span class="n">UsePostgres</span><span class="p">(</span><span class="s">&#34;...&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="p">.</span><span class="n">UseClusteredMode</span> <span class="p">=</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="p">.</span><span class="n">PerformSchemaValidation</span> <span class="p">=</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span></code></pre></div><p>Clustering introduces latency: each scheduler instance polls the database for triggers, typically every few seconds. For high-throughput scenarios, this creates database load proportional to instance count. Tuning polling intervals balances responsiveness and database overhead.</p><p>Quartz.NET also supports <strong>job persistence without clustering</strong>. Single-instance deployments benefit from persistent storage (jobs survive restarts) without coordination overhead. This mode suits applications where high availability isn&rsquo;t critical but durability matters.</p><h2 id="job-data-maps-and-parameterization"><a href="/posts/dotnet-job-scheduling-3-quartznet/#job-data-maps-and-parameterization" title="Job Data Maps and Parameterization">Job Data Maps and Parameterization</a></h2><p>Jobs often require parameters—account IDs, file paths, configuration values. Quartz.NET uses <strong>job data maps</strong> to pass data:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">jobData</span> <span class="p">=</span> <span class="k">new</span> <span class="n">JobDataMap</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span> <span class="s">&#34;accountId&#34;</span><span class="p">,</span> <span class="m">12345</span> <span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span> <span class="s">&#34;reportType&#34;</span><span class="p">,</span> <span class="s">&#34;monthly&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">job</span> <span class="p">=</span> <span class="n">JobBuilder</span><span class="p">.</span><span class="n">Create</span><span class="p">&lt;</span><span class="n">ReportJob</span><span class="p">&gt;()</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">WithIdentity</span><span class="p">(</span><span class="s">&#34;Report-12345&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">UsingJobData</span><span class="p">(</span><span class="n">jobData</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">Build</span><span class="p">();</span>
</span></span></code></pre></div><p>Jobs retrieve parameters from the execution context:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">async</span> <span class="n">Task</span> <span class="n">Execute</span><span class="p">(</span><span class="n">IJobExecutionContext</span> <span class="n">context</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">var</span> <span class="n">accountId</span> <span class="p">=</span> <span class="n">context</span><span class="p">.</span><span class="n">MergedJobDataMap</span><span class="p">.</span><span class="n">GetInt</span><span class="p">(</span><span class="s">&#34;accountId&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">var</span> <span class="n">reportType</span> <span class="p">=</span> <span class="n">context</span><span class="p">.</span><span class="n">MergedJobDataMap</span><span class="p">.</span><span class="n">GetString</span><span class="p">(</span><span class="s">&#34;reportType&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">await</span> <span class="n">GenerateReportAsync</span><span class="p">(</span><span class="n">accountId</span><span class="p">,</span> <span class="n">reportType</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Quartz.NET serializes job data maps to the database using JSON. Complex types—custom classes, collections—are supported, but large payloads impact performance. For heavyweight data, pass identifiers (e.g., database primary keys) and fetch the data within the job.</p><p>Triggers can also carry data maps, which merge with job data maps during execution. This enables per-trigger customization: a single job definition with multiple triggers, each passing different parameters.</p><h2 id="monitoring-plugins-and-extensibility"><a href="/posts/dotnet-job-scheduling-3-quartznet/#monitoring-plugins-and-extensibility" title="Monitoring, Plugins, and Extensibility">Monitoring, Plugins, and Extensibility</a></h2><p>Quartz.NET provides listeners for observing job lifecycle events:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">class</span> <span class="nc">JobExecutionListener</span> <span class="p">:</span> <span class="n">IJobListener</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">string</span> <span class="n">Name</span> <span class="p">=&gt;</span> <span class="s">&#34;JobExecutionListener&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Task</span> <span class="n">JobWasExecuted</span><span class="p">(</span><span class="n">IJobExecutionContext</span> <span class="n">context</span><span class="p">,</span> <span class="n">JobExecutionException</span><span class="p">?</span> <span class="n">exception</span><span class="p">,</span> <span class="n">CancellationToken</span> <span class="n">cancellationToken</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">var</span> <span class="n">duration</span> <span class="p">=</span> <span class="n">context</span><span class="p">.</span><span class="n">JobRunTime</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">Log</span><span class="p">.</span><span class="n">Information</span><span class="p">(</span><span class="s">&#34;Job {JobKey} executed in {Duration}ms&#34;</span><span class="p">,</span> <span class="n">context</span><span class="p">.</span><span class="n">JobDetail</span><span class="p">.</span><span class="n">Key</span><span class="p">,</span> <span class="n">duration</span><span class="p">.</span><span class="n">TotalMilliseconds</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">Task</span><span class="p">.</span><span class="n">CompletedTask</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Other lifecycle methods...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Register listeners during configuration:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="n">q</span><span class="p">.</span><span class="n">AddJobListener</span><span class="p">&lt;</span><span class="n">JobExecutionListener</span><span class="p">&gt;();</span>
</span></span></code></pre></div><p>Listeners integrate with telemetry systems—Application Insights, Prometheus, Datadog—exporting metrics like job execution time, failure rates, and queue depths. This observability is critical for production systems where job health impacts business operations.</p><p>Quartz.NET includes plugins for common scenarios:</p><ul><li><strong>XMLSchedulingDataProcessorPlugin</strong>: Load job definitions from XML files, enabling configuration-driven scheduling.</li><li><strong>LoggingTriggerHistoryPlugin</strong>: Records trigger fire history to logs for audit trails.</li><li><strong>InterruptMonitorPlugin</strong>: Monitors job interruptions and logs them for debugging.</li></ul><p>Plugins integrate via configuration:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="n">q</span><span class="p">.</span><span class="n">AddXMLSchedulingDataProcessorPlugin</span><span class="p">(</span><span class="n">plugin</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">plugin</span><span class="p">.</span><span class="n">Files</span> <span class="p">=</span> <span class="k">new</span><span class="p">[]</span> <span class="p">{</span> <span class="s">&#34;~/quartz_jobs.xml&#34;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">plugin</span><span class="p">.</span><span class="n">ScanInterval</span> <span class="p">=</span> <span class="n">TimeSpan</span><span class="p">.</span><span class="n">FromSeconds</span><span class="p">(</span><span class="m">30</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span></code></pre></div><p>This plugin watches an XML file and dynamically updates job definitions without application restarts—useful for operational teams adjusting schedules without developer intervention.</p><h2 id="when-quartznet-fits"><a href="/posts/dotnet-job-scheduling-3-quartznet/#when-quartznet-fits" title="When Quartz.NET Fits">When Quartz.NET Fits</a></h2><p>Quartz.NET excels when:</p><ol><li><p><strong>Complex scheduling is essential</strong>: Job calendars, business day logic, misfire policies, and priority-based execution are first-class requirements.</p></li><li><p><strong>High throughput demands clustering</strong>: Thousands or tens of thousands of jobs per minute justify distributed coordination and horizontal scaling.</p></li><li><p><strong>Observability and auditability matter</strong>: Enterprises needing compliance, audit trails, and detailed execution history benefit from Quartz.NET&rsquo;s persistence and plugin ecosystem.</p></li><li><p><strong>Multi-tenancy or geo-distribution</strong>: Systems spanning multiple datacenters or customer tenants require flexible storage and isolation, which Quartz.NET&rsquo;s architecture supports.</p></li></ol><p>Quartz.NET is less suitable when:</p><ul><li><p><strong>Simplicity is paramount</strong>: Teams seeking minimal configuration overhead should consider Hangfire, Coravel, or NCronJob.</p></li><li><p><strong>Stateless deployments are preferred</strong>: While Quartz.NET supports in-memory storage, clustering requires a database. Fully stateless architectures might prefer external message brokers or in-memory frameworks.</p></li><li><p><strong>Throughput is modest</strong>: If job volumes are hundreds per minute, not thousands, Quartz.NET&rsquo;s complexity may outweigh its benefits. Hangfire delivers adequate performance with less operational overhead.</p></li></ul><h2 id="operational-complexity-and-trade-offs"><a href="/posts/dotnet-job-scheduling-3-quartznet/#operational-complexity-and-trade-offs" title="Operational Complexity and Trade-offs">Operational Complexity and Trade-offs</a></h2><p>Quartz.NET&rsquo;s power comes with operational demands. Teams must provision and maintain database infrastructure, configure clustering correctly, monitor database performance under polling load, and tune misfire policies based on workload characteristics.</p><p>The learning curve is steeper than simpler frameworks. Quartz.NET&rsquo;s abstractions—jobs, triggers, calendars, listeners—require understanding before effective use. Misconfigured misfire policies can cause execution storms (hundreds of missed jobs firing simultaneously). Incorrect clustering settings can lead to duplicate execution or job starvation.</p><p>However, for systems where scheduling is critical, this complexity is justified. Quartz.NET&rsquo;s reliability, flexibility, and scalability enable architectures that simpler frameworks cannot support. Financial platforms, healthcare systems, and enterprise ETL pipelines rely on Quartz.NET for workloads where failures have business consequences.</p><h2 id="practical-takeaways"><a href="/posts/dotnet-job-scheduling-3-quartznet/#practical-takeaways" title="Practical Takeaways">Practical Takeaways</a></h2><p>Quartz.NET occupies the enterprise end of the scheduling spectrum. It provides advanced semantics, clustering, and observability at the cost of operational complexity.</p><p>Consider Quartz.NET if:</p><ul><li>Your system requires complex scheduling—calendars, misfires, priorities.</li><li>Job volumes justify horizontal scaling across multiple instances.</li><li>Observability, auditing, and compliance are critical.</li><li>You need fine-grained control over execution policies and error handling.</li></ul><p>Avoid Quartz.NET if:</p><ul><li>Your application needs simple, lightweight scheduling (see NCronJob or Coravel).</li><li>Persistence suffices without clustering (see Hangfire).</li><li>Developer velocity and minimal configuration are priorities over advanced features.</li></ul><p>The next article explores Coravel, a framework that prioritizes simplicity and developer convenience. Where Quartz.NET offers enterprise control, Coravel provides fluent APIs, zero infrastructure requirements, and rapid integration for small to medium applications.</p></section><h2>Comments</h2><aside class="giscus"></aside><script src="https://giscus.app/client.js" data-repo="dailydevops/dailydevops.github.io" data-repo-id="R_kgDOHA8eFg" data-category="Announcements" data-category-id="DIC_kwDOHA8eFs4COIqL" data-mapping="pathname" data-strict="1" data-reactions-enabled="0" data-emit-metadata="0" data-input-position="bottom" data-theme="light" data-lang="en" crossorigin="anonymous" async></script></article><aside class="sidebar divider"><section class="sidecar info"><ul><li><time datetime="2025-12-02T17:00:00+01:00">Published on 12/2/25 5:00 pm</time></li><li>Read in 9 minutes</li></ul></section><section class="sidecar series"><header><h2>Series content</h2></header><a href="https://daily-devops.net/posts/dotnet-job-scheduling-1-landscape/" title=".NET Job Scheduling — The Landscape" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right"></i>&nbsp;
.NET Job Scheduling — The Landscape
</a><a href="https://daily-devops.net/posts/dotnet-job-scheduling-2-hangfire/" title=".NET Job Scheduling — Hangfire and Persistent Reliability" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right"></i>&nbsp;
.NET Job Scheduling — Hangfire and Persistent Reliability
</a><a href="https://daily-devops.net/posts/dotnet-job-scheduling-3-quartznet/" title=".NET Job Scheduling — Quartz.NET for Enterprise Scale" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right"></i>&nbsp;
.NET Job Scheduling — Quartz.NET for Enterprise Scale</a></section><section class="sidecar author"><header><h2><a href="/authors/martin/" rel="author" title="Martin Stühmer">Author Martin Stühmer</a></h2></header><figure class="round"><picture><img src="https://www.gravatar.com/avatar/6da4a47ff9cc2b750452225fdb2582f7?d=identicon&amp;s=200" alt="Martin Stühmer" loading="lazy" decoding="async" title="Martin Stühmer"></picture></figure><section class="content">Martin is a seasoned software architect and developer based in the Stuttgart region, with more than 15 years of experience in utilizing .NET and Microsoft technologies in his work. His expertise lies in enhancing the quality and performance of development teams, optimizing software solutions for target environments, and maximizing application efficiency. Currently serving as the Director Consulting Services at CGI, he specializes in cloud-native and .NET solutions, while also providing training in cloud and software architecture. Beyond his professional endeavors, Martin actively contributes to open-source communities by offering various NuGet packages. In 2021, he achieved certifications as an IHK instructor and Microsoft certified trainer, furthering his commitment to continuous learning. Additionally, he became a certified trainer for CGI’s Risk and Cost Driven Architecture program in 2022.</section><a class="link" href="/authors/martin/" rel="author" title="Martin Stühmer"></a></section><section class="sidecar social"><header><h2>Social media</h2></header><a class="icon bluesky" href="https://bsky.app/profile/samtrion.net" rel="noopener external" title="Follow me on Bluesky" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-bluesky fa-stack-1x fa-inverse"></i>
</span></a><a class="icon github" href="https://github.com/samtrion" rel="noopener external" title="Follow me on GitHub" target="_blank"><i class="fa-brands fa-fw fa-github fa-2x"></i></a>
<a class="icon linkedin" href="https://www.linkedin.com/in/martin-stuehmer" rel="noopener external" title="Follow me on LinkedIn" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-linkedin-in fa-stack-1x fa-inverse"></i>
</span></a><a class="icon stackoverflow" href="https://stackoverflow.com/users/10574963" rel="noopener external" title="Follow me on Stack Overflow" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-stack-overflow fa-stack-1x fa-inverse"></i>
</span></a><a class="icon mail" href="mailto:martin@daily-devops.net" title="Contact me by e-mail" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
</span></a><a class="icon feed" href="/authors/martin/feed.rss" title="My RSS feed" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></section><section class="sidecar share"><header><h2>Share this content</h2></header><a class="icon linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fdaily-devops.net%2fposts%2fdotnet-job-scheduling-3-quartznet%2f&text=.NET%20Job%20Scheduling%20%e2%80%94%20Quartz.NET%20for%20Enterprise%20Scale%20%26mdash%3b%20Daily%20DevOps%20%26%20.NET" target="_blank" rel="noopener external" aria-label="Share on LinkedIn" title="Share on LinkedIn" target="_blank"><i class="fa-brands fa-fw fa-linkedin-in fa-2x"></i></a>
<a class="icon bluesky" href="https://bsky.app/intent/compose?text=.NET%20Job%20Scheduling%20%e2%80%94%20Quartz.NET%20for%20Enterprise%20Scale%20%26mdash%3b%20Daily%20DevOps%20%26%20.NET%20https%3a%2f%2fdaily-devops.net%2fposts%2fdotnet-job-scheduling-3-quartznet%2f" target="_blank" rel="noopener external" aria-label="Share on Bluesky" title="Share on Bluesky" target="_blank"><i class="fa-brands fa-fw fa-bluesky fa-2x"></i></a></section><section class="sidecar tags"><header><h2>Tags</h2></header><ul><li class="tag"><a href="/tags/dotnet/" hreflang="en" rel="tag" title=".NET"><i class="fas fa-tag"></i>&nbsp;.NET</a></li><li class="tag"><a href="/tags/architecture/" hreflang="en" rel="tag" title="Architecture"><i class="fas fa-tag"></i>&nbsp;Architecture</a></li><li class="tag"><a href="/tags/csharp/" hreflang="en" rel="tag" title="C#"><i class="fas fa-tag"></i>&nbsp;C#</a></li><li class="tag"><a href="/tags/nuget/" hreflang="en" rel="tag" title="NuGet"><i class="fas fa-tag"></i>&nbsp;NuGet</a></li><li class="tag"><a href="/tags/softwareengineering/" hreflang="en" rel="tag" title="Software Engineering"><i class="fas fa-tag"></i>&nbsp;Software Engineering</a></li></ul></section><section class="sidecar links"><header><h2>Additional links</h2></header><a href="https://www.quartz-scheduler.net/documentation/" title="Quartz.NET Documentation" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right"></i>&nbsp;
Quartz.NET Documentation
</a><a href="https://github.com/quartznet/quartznet" title="Quartz.NET on GitHub" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right"></i>&nbsp;
Quartz.NET on GitHub</a></section><section class="sidecar related"><header><h2>Related content</h2></header><article class="post"><figure class="square"><picture><source srcset="/images/nuget-scheduler-80x80.webp?v=95914a9a175237c92bb05c5c3187d800" type="image/webp"><source srcset="/images/nuget-scheduler-80x80.png?v=21983cb7d1aaee6a20b10806f639db1c" type="image/png"><img src="/images/nuget-scheduler.png?v=4159bfd7c08b58b0fc741782fe532741" alt=".NET Job Scheduling — Hangfire and Persistent Reliability" loading="lazy" decoding="async" title=".NET Job Scheduling — Hangfire and Persistent Reliability"></picture></figure><header><h2><a href="/posts/dotnet-job-scheduling-2-hangfire/" rel="bookmark">.NET Job Scheduling — Hangfire and Persistent Reliability</a></h2></header><section class="content">Hangfire combines persistent job storage, automatic retries, and real-time monitoring to simplify background processing.
Learn when database-backed reliability matters and how Hangfire scales from single instances to distributed workers.</section></article><article class="post"><figure class="square"><picture><source srcset="/images/nuget-scheduler-80x80.webp?v=95914a9a175237c92bb05c5c3187d800" type="image/webp"><source srcset="/images/nuget-scheduler-80x80.png?v=21983cb7d1aaee6a20b10806f639db1c" type="image/png"><img src="/images/nuget-scheduler.png?v=4159bfd7c08b58b0fc741782fe532741" alt=".NET Job Scheduling — The Landscape" loading="lazy" decoding="async" title=".NET Job Scheduling — The Landscape"></picture></figure><header><h2><a href="/posts/dotnet-job-scheduling-1-landscape/" rel="bookmark">.NET Job Scheduling — The Landscape</a></h2></header><section class="content">Explore the spectrum of .NET job scheduling from lightweight in-memory solutions to enterprise-grade distributed systems.
Understand which approach fits your operational model and why background processing architecture matters.</section></article><article class="post"><figure class="square"><picture><source srcset="/images/dotnet-paradox-80x80.webp?v=757c098ada78a773777eecce2ac37bf5" type="image/webp"><source srcset="/images/dotnet-paradox-80x80.png?v=29e2f5a0c373c3060fc6fc04c3fd3c63" type="image/png"><img src="/images/dotnet-paradox.png?v=fab3db4941c79e6e7ad156d66492c87b" alt=".NET 10 and the Release Cycle Paradox" loading="lazy" decoding="async" title=".NET 10 and the Release Cycle Paradox"></picture></figure><header><h2><a href="/posts/dotnet-10-release-cycle-paradox/" rel="bookmark">.NET 10 and the Release Cycle Paradox</a></h2></header><section class="content"><p>.NET’s yearly rhythm has become a symbol of stability — yet also a source of pressure.
The <strong>release cycle paradox</strong> describes the tension between predictability and exhaustion: a release schedule that keeps the ecosystem healthy, but teams constantly catching up.</p><p>With .NET 10 on the horizon, developers must learn to navigate this rhythm rather than fight it.</p></section></article></section></aside><nav class="pager"><a class="prev" href="/posts/dotnet-job-scheduling-2-hangfire/" title=".NET Job Scheduling — Hangfire and Persistent Reliability" rel="prev"><span class="sub">Previous&emsp;<i class="fas fa-forward"></i></span><p class="title">.NET Job Scheduling — Hangfire and Persistent Reliability</p></a></nav></main><footer class="footer"><div class="divider"></div><nav><ul class="navigation"><li><a href="/tags/">Tags</a></li><li><a href="/legal-notice/">Legal notice</a></li></ul></nav><div class="copyright">&copy; 2023 - 2025 Daily DevOps & .NET</div></footer><script defer src="/js/below.min.a6ce9164454b6077f17ae856f280442d9f3a1e21f06189f71c21f75144b22a0c8cf32bafd61d440e9d90ca02bf738b6a8ef19f5ec20285d8ca574f98c91ebaf2.js" integrity="sha512-ps6RZEVLYHfxeuhW8oBELZ86HiHwYYn3HCH3UUSyKgyM8yuv1h1EDp2QygK/c4tqjvGfXsIChdjKV0+YyR668g==" crossorigin="anonymous"></script><img class="vgwort" src="https://vg06.met.vgwort.de/na/6e205129c5af418cb20b5763832fe6a1" width="1" height="1" alt="VG Wort" title="VG Wort"></body></html>