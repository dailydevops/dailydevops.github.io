<!doctype html><html class="no-js" lang="en" dir="ltr"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="theme-color" content="#15a"><title>.NET Job Scheduling — Hangfire and Persistent Reliability — Daily DevOps & .NET</title><meta name="description" content="Hangfire combines persistent job storage, automatic retries, and real-time monitoring to simplify background processing.
Learn when database-backed reliability …"><meta name="twitter:description" property="og:description" content="Hangfire combines persistent job storage, automatic retries, and real-time monitoring to simplify background processing.
Learn when database-backed reliability …"><meta name="author" content="Martin Stühmer"><link rel="icon" href="/logo.svg?v=b9e294dc5c6fa04439c8c803d8e981a9" sizes="any" type="image/svg+xml"><meta name="twitter:title" property="og:title" content=".NET Job Scheduling — Hangfire and Persistent Reliability — Daily DevOps & .NET"><meta property="og:updated_time" content="2026-01-05T12:05:23+01:00"><meta property="article:modified_time" content="2026-01-05T12:05:23+01:00"><meta property="article:published_time" content="2025-11-27T17:00:00+01:00"><meta property="og:type" content="article"><meta property="og:site_name" content="Daily DevOps & .NET"><meta property="og:url" content="https://daily-devops.net/posts/dotnet-job-scheduling-2-hangfire/"><meta property="og:locale" content="en"><meta name="twitter:card" content="summary_large_image"><meta property="og:image" name="twitter:image" content="https://daily-devops.net/images/nuget-scheduler-1200x630.webp?v=f3d889c42c9ebef75a8080657d86d1e1"><meta property="og:image:secure_url" content="https://daily-devops.net/images/nuget-scheduler-1200x630.webp?v=f3d889c42c9ebef75a8080657d86d1e1"><meta property="og:image:alt" name="twitter:image:alt" content=".NET Job Scheduling — Hangfire and Persistent Reliability"><meta property="og:image:type" content="image/webp"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta property="og:image" name="twitter:image" content="https://daily-devops.net/images/nuget-scheduler-1200x630.png?v=16dd667ddd31353e2d9ebc222586164d"><meta property="og:image:secure_url" content="https://daily-devops.net/images/nuget-scheduler-1200x630.png?v=16dd667ddd31353e2d9ebc222586164d"><meta property="og:image:alt" name="twitter:image:alt" content=".NET Job Scheduling — Hangfire and Persistent Reliability"><meta property="og:image:type" content="image/png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><link rel="dns-prefetch" href="https://www.clarity.ms"><link rel="preconnect" href="https://www.clarity.ms" crossorigin><link rel="stylesheet" href="/css/style.min.0b2ef4378cd908eb695017aaa74603d244ff2b38c8068b4b51d76cad830c8ee5e3a40b67ab5b860a542c8bae73d8ba90cfbe9249b59c733a50de74cc32af818a.css" integrity="sha512-Cy70N4zZCOtpUBeqp0YD0kT/KzjIBotLUddsrYMMjuXjpAtnq1uGClQsi65z2LqQz76SSbWcczpQ3nTMMq+Big==" crossorigin="anonymous"><link rel="alternate" href='https://daily-devops.net/posts/dotnet-job-scheduling-2-hangfire/' hreflang="x-default" title=".NET Job Scheduling — Hangfire and Persistent Reliability &mdash; Daily DevOps & .NET"><link rel="alternate" href="https://daily-devops.net/en/posts/dotnet-job-scheduling-2-hangfire/" hreflang="en" title=".NET Job Scheduling — Hangfire and Persistent Reliability &mdash; Daily DevOps & .NET"><link rel="canonical" href="https://daily-devops.net/posts/dotnet-job-scheduling-2-hangfire/" hreflang="en" title=".NET Job Scheduling — Hangfire and Persistent Reliability &mdash; Daily DevOps & .NET"><link rel="home" href="https://daily-devops.net/" hreflang="en" title="Daily DevOps & .NET"><link rel="next" href="https://daily-devops.net/posts/dotnet-job-scheduling-3-quartznet/" hreflang="en" title=".NET Job Scheduling — Quartz.NET for Enterprise Scale"><link rel="prev" href="https://daily-devops.net/posts/dotnet-job-scheduling-1-landscape/" hreflang="en" title=".NET Job Scheduling — The Landscape"><link rel="author" href="https://daily-devops.net/authors/martin/" hreflang="en" title="Martin Stühmer &mdash; Daily DevOps & .NET"><meta name="giscus:backlink" content="https://daily-devops.net/posts/dotnet-job-scheduling-2-hangfire/"><script defer src="/js/above.min.cb42b2c9a453e49e278326637d72d2f01e7f32e3f91e9cdde8fb587793d05514efd2f5cc5021c9658ca0f73876dbdcd1f7cb4a37c0bebc9df01110926b6d7cba.js" integrity="sha512-y0KyyaRT5J4ngyZjfXLS8B5/MuP5Hpzd6PtYd5PQVRTv0vXMUCHJZYyg9zh229zR98tKN8C+vJ3wERCSa218ug==" crossorigin="anonymous"></script><script type="text/javascript">(function(e,t,n,s,o,i,a){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)},i=t.createElement(s),i.async=1,i.src="https://www.clarity.ms/tag/"+o,a=t.getElementsByTagName(s)[0],a.parentNode.insertBefore(i,a)})(window,document,"clarity","script","o0pr4n9gg3")</script></head><body class="container"><header class="header"><a class="logo" href="/" title="Daily DevOps & .NET" rel="home"><figure class="page-logo"><picture><img src="/logo.svg?v=b9e294dc5c6fa04439c8c803d8e981a9" alt="Daily DevOps & .NET" title="Daily DevOps & .NET"></picture></figure><span class="title">Daily DevOps & .NET</span></a><nav class="menu" aria-label="Main navigation"><button class="burger" type="button" aria-haspopup="menu" aria-expanded="false" aria-label="Toggle menu">
<i class="fas fa-burger" aria-hidden="true"></i></button><ul class="navigation"><li class="active"><a href="/posts/">Posts</a></li><li><a href="/authors/">About us</a></li></ul></nav><div class="divider"></div></header><main class="body"><figure class="hero"><picture><source srcset="/images/nuget-scheduler-544x136.webp?v=0e0bb9efd96bd0b3b7b45b871b5167aa" type="image/webp" media="(max-width: 575.98px)"><source srcset="/images/nuget-scheduler-544x136.png?v=f24f4c05bcbce7421f53568505a29f42" type="image/png" media="(max-width: 575.98px)"><source srcset="/images/nuget-scheduler-672x168.webp?v=de5b6c8d6aa6a6aa919713225a93e3fb" type="image/webp" media="(max-width: 767.98px)"><source srcset="/images/nuget-scheduler-672x168.png?v=9081a48ed39bbcf72048c71e59f757bf" type="image/png" media="(max-width: 767.98px)"><source srcset="/images/nuget-scheduler-896x224.webp?v=2bd0203b85c5855d6e65e5f1623effa8" type="image/webp" media="(max-width: 991.98px)"><source srcset="/images/nuget-scheduler-896x224.png?v=2e6bb71535af5f7bbaa14618564af8db" type="image/png" media="(max-width: 991.98px)"><source srcset="/images/nuget-scheduler-1104x276.webp?v=398614058e8e62a2c8e4df74236f5f0f" type="image/webp" media="(max-width: 1199.98px)"><source srcset="/images/nuget-scheduler-1104x276.png?v=13c4fd9c98192929ddcca480ea783609" type="image/png" media="(max-width: 1199.98px)"><source srcset="/images/nuget-scheduler-1444x361.webp?v=1ef9c89362404bf7bd1fffc612397312" type="image/webp"><source srcset="/images/nuget-scheduler-1444x361.png?v=5e8383f2e2acb3de1df045ebc65e458d" type="image/png"><img src="/images/nuget-scheduler.png?v=4159bfd7c08b58b0fc741782fe532741" alt=".NET Job Scheduling — Hangfire and Persistent Reliability" loading="lazy" decoding="async" title=".NET Job Scheduling — Hangfire and Persistent Reliability"></picture></figure><article class="post"><header><h1>.NET Job Scheduling — Hangfire and Persistent Reliability</h1></header><section class="content" role="region"><p>A user uploads a 200 MB video to your platform at 3:14 PM. Transcoding it into multiple formats—1080p, 720p, mobile—takes twelve minutes on average, sometimes longer. Keeping the HTTP request open that long? Unacceptable. But here&rsquo;s the problem: during our Tuesday maintenance window last month, we restarted the app servers, and boom—87 video processing jobs vanished into thin air. Users got &ldquo;upload successful&rdquo; messages, but their videos never appeared. Not ideal when you&rsquo;re charging for the service.</p><p>You need persistence: the ability to store job definitions in a database, detach them from the request lifecycle, and guarantee execution even when infrastructure hiccups.</p><p>Hangfire solves this by turning background jobs into first-class database records. When you enqueue a job, Hangfire serializes the method invocation—class name, method signature, parameters—and persists it to SQL Server, PostgreSQL, or Redis. Worker threads poll the storage, claim jobs, execute them, and record outcomes. If a worker crashes mid-execution, another worker picks up the job and retries it based on configurable policies. If the entire application restarts, queued jobs remain intact, waiting for workers to resume processing.</p><p>This architecture makes Hangfire particularly suited for web applications where background work must survive deployments, process restarts, or transient failures. The trade-off: you need a database. For teams already running SQL Server or PostgreSQL, this is minimal overhead. For environments preferring stateless components, the infrastructure requirement merits consideration.</p><h2 id="core-architecture-storage-workers-and-coordination"><a href="/posts/dotnet-job-scheduling-2-hangfire/#core-architecture-storage-workers-and-coordination" title="Core Architecture: Storage, Workers, and Coordination">Core Architecture: Storage, Workers, and Coordination</a></h2><p>Hangfire&rsquo;s design centers on three components: the storage backend, the job server (workers), and the client API that enqueues jobs.</p><p><strong>Storage</strong> holds job definitions, execution history, and metadata. Hangfire serializes method calls—including parameter values—as JSON and stores them in tables like <code>HangFire.Job</code>, <code>HangFire.State</code>, and <code>HangFire.JobQueue</code>. When a job is enqueued, a record appears in the database. When a worker processes it, the state transitions from <code>Enqueued</code> to <code>Processing</code> to <code>Succeeded</code> or <code>Failed</code>. This persistence is what differentiates Hangfire from in-memory schedulers: jobs are durable, observable, and recoverable.</p><p>Supported storage backends include SQL Server (the default), PostgreSQL, MySQL, MongoDB, and Redis. SQL-based backends offer strong consistency and integrate seamlessly with existing relational infrastructure. Redis provides lower latency for high-throughput scenarios where job volumes exceed thousands per minute. Choosing a backend depends on your existing infrastructure and performance requirements—SQL Server for most .NET shops, Redis for systems already using it for caching or session state.</p><p><strong>Workers</strong> execute jobs. Each Hangfire server instance starts dedicated background threads—not the ASP.NET Core thread pool—that poll the storage for <code>Enqueued</code> jobs. Polling uses database-specific mechanisms: SQL Server leverages <code>UPDLOCK</code> and <code>READPAST</code> hints to claim jobs atomically, ensuring only one worker processes each job even when multiple servers run concurrently. Workers fetch jobs, deserialize method calls, invoke them using reflection, and update job states in the database.</p><p>The number of worker threads is configurable. A single-instance application might run five workers; a scaled-out deployment with three servers might run fifteen total workers (five per server). More workers increase throughput but consume more database connections and CPU. Tuning depends on job execution time: CPU-bound jobs benefit from fewer workers matching CPU core counts, while I/O-bound jobs can support more workers since threads spend time waiting on external resources.</p><p><strong>Clients</strong> enqueue jobs via a simple API. <code>BackgroundJob.Enqueue(() => Console.WriteLine("Hello"))</code> serializes the method call and inserts it into the database. The calling thread returns immediately; the work happens asynchronously on a worker thread. This decoupling is essential for web applications: controllers enqueue jobs in milliseconds and respond to users, while workers process jobs in the background without blocking HTTP requests.</p><p>Hangfire also supports delayed jobs (scheduled to run after a time interval), recurring jobs (executed on a cron schedule), and continuations (jobs that run after a parent job succeeds). Each pattern maps to database records with corresponding state transitions, enabling rich workflows without custom orchestration code.</p><h2 id="configuration-and-integration"><a href="/posts/dotnet-job-scheduling-2-hangfire/#configuration-and-integration" title="Configuration and Integration">Configuration and Integration</a></h2><p>Integrating Hangfire into an ASP.NET Core application requires three steps: configuring storage, starting the server, and optionally enabling the dashboard.</p><p>First, install the NuGet package. For SQL Server:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">dotnet add package Hangfire.AspNetCore
</span></span><span class="line"><span class="cl">dotnet add package Hangfire.SqlServer
</span></span></code></pre></div><p>Second, configure storage and start the server in <code>Program.cs</code>:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="n">builder</span><span class="p">.</span><span class="n">Services</span><span class="p">.</span><span class="n">AddHangfire</span><span class="p">(</span><span class="n">configuration</span> <span class="p">=&gt;</span> <span class="n">configuration</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">SetDataCompatibilityLevel</span><span class="p">(</span><span class="n">CompatibilityLevel</span><span class="p">.</span><span class="n">Version_180</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">UseSimpleAssemblyNameTypeSerializer</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">UseRecommendedSerializerSettings</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">UseSqlServerStorage</span><span class="p">(</span><span class="s">&#34;Server=.;Database=HangfireDB;Integrated Security=True;&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">builder</span><span class="p">.</span><span class="n">Services</span><span class="p">.</span><span class="n">AddHangfireServer</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">app</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">app</span><span class="p">.</span><span class="n">UseHangfireDashboard</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">app</span><span class="p">.</span><span class="n">Run</span><span class="p">();</span>
</span></span></code></pre></div><p>This configuration connects to a SQL Server database, starts worker threads, and exposes the dashboard at <code>/hangfire</code>. The dashboard provides real-time visibility into job states: succeeded, failed, processing, scheduled, and enqueued. You can manually trigger recurring jobs, delete failed jobs, or re-enqueue them for retry.</p><p>Third, enqueue jobs from anywhere in your application—controllers, services, background tasks:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">class</span> <span class="nc">OrderController</span> <span class="p">:</span> <span class="n">ControllerBase</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="na">    [HttpPost]</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">IActionResult</span> <span class="n">ProcessOrder</span><span class="p">(</span><span class="n">Order</span> <span class="n">order</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">BackgroundJob</span><span class="p">.</span><span class="n">Enqueue</span><span class="p">&lt;</span><span class="n">IOrderProcessor</span><span class="p">&gt;(</span><span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span><span class="p">.</span><span class="n">ProcessAsync</span><span class="p">(</span><span class="n">order</span><span class="p">.</span><span class="n">Id</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">Accepted</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>The controller responds immediately with <code>202 Accepted</code>. The <code>ProcessAsync</code> method executes asynchronously on a worker thread. If processing fails—database timeout, external API unavailable—Hangfire automatically retries it up to ten times with exponential backoff (configurable). Failed jobs appear in the dashboard with full stack traces, enabling debugging without log archaeology.</p><p>Recurring jobs use cron expressions:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="n">RecurringJob</span><span class="p">.</span><span class="n">AddOrUpdate</span><span class="p">(</span><span class="s">&#34;nightly-report&#34;</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">    <span class="p">()</span> <span class="p">=&gt;</span> <span class="n">GenerateReport</span><span class="p">(),</span> 
</span></span><span class="line"><span class="cl">    <span class="n">Cron</span><span class="p">.</span><span class="n">Daily</span><span class="p">(</span><span class="m">2</span><span class="p">));</span> <span class="c1">// 2 AM daily</span>
</span></span></code></pre></div><p>Hangfire stores the recurring job definition in the database and triggers it based on the cron schedule. If the application is down during the scheduled time, Hangfire executes the job as soon as a server starts. This &ldquo;catch-up&rdquo; behavior prevents missed executions but can cause bursts if the application was offline for extended periods.</p><h2 id="retry-policies-and-error-handling"><a href="/posts/dotnet-job-scheduling-2-hangfire/#retry-policies-and-error-handling" title="Retry Policies and Error Handling">Retry Policies and Error Handling</a></h2><p>Transient failures—network timeouts, temporary database unavailability—shouldn&rsquo;t cause permanent job failures. Hangfire&rsquo;s automatic retry mechanism handles these transparently.</p><p>By default, failed jobs retry up to ten times with exponential backoff: immediate retry, then 1 minute, 2 minutes, 4 minutes, and so on. If all retries exhaust, the job transitions to the <code>Failed</code> state and appears in the dashboard. Administrators can manually re-enqueue failed jobs or investigate root causes using stack traces recorded in the database.</p><p>Custom retry logic uses filters:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">class</span> <span class="nc">CustomRetryAttribute</span> <span class="p">:</span> <span class="n">JobFilterAttribute</span><span class="p">,</span> <span class="n">IElectStateFilter</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="k">void</span> <span class="n">OnStateElection</span><span class="p">(</span><span class="n">ElectStateContext</span> <span class="n">context</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">var</span> <span class="n">failedState</span> <span class="p">=</span> <span class="n">context</span><span class="p">.</span><span class="n">CandidateState</span> <span class="k">as</span> <span class="n">FailedState</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">failedState</span> <span class="p">!=</span> <span class="kc">null</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">context</span><span class="p">.</span><span class="n">CandidateState</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ScheduledState</span><span class="p">(</span><span class="n">TimeSpan</span><span class="p">.</span><span class="n">FromMinutes</span><span class="p">(</span><span class="m">5</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="na">
</span></span></span><span class="line"><span class="cl"><span class="na">[CustomRetry]</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">void</span> <span class="n">UnreliableTask</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Custom retry: wait 5 minutes, then retry indefinitely</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>This filter intercepts state transitions and reschedules failed jobs with custom delays. Use cases include rate-limited APIs (retry after a cooldown), scheduled maintenance windows (skip retries during known outages), or critical workflows requiring infinite retries until manual intervention.</p><p>Hangfire also supports idempotency checks via filters. If a job should only execute once regardless of retries—for example, charging a customer&rsquo;s credit card—wrap the logic in idempotency tokens or database locks to prevent duplicate execution.</p><h2 id="scalability-from-single-instance-to-distributed-workers"><a href="/posts/dotnet-job-scheduling-2-hangfire/#scalability-from-single-instance-to-distributed-workers" title="Scalability: From Single Instance to Distributed Workers">Scalability: From Single Instance to Distributed Workers</a></h2><p>Hangfire scales vertically and horizontally. Vertical scaling increases worker threads on a single server. Horizontal scaling adds more servers, each running its own Hangfire server instance. Workers across all servers poll the same database, coordinating via atomic database operations to prevent duplicate job processing.</p><p>When you deploy three application instances, each with five worker threads, you effectively have fifteen workers competing for jobs. Hangfire&rsquo;s SQL-based storage uses <code>UPDLOCK</code> and <code>READPAST</code> to ensure only one worker claims each job. This coordination happens at the database level—no external message broker or distributed lock manager required.</p><p>For high-throughput scenarios—tens of thousands of jobs per minute—SQL Server&rsquo;s polling overhead becomes noticeable. Each worker queries the database every few seconds, creating connection churn and CPU load. Redis-based storage reduces this overhead by leveraging Redis&rsquo;s pub/sub for instant job notifications instead of polling. Workers sleep until Redis signals a new job, eliminating unnecessary queries.</p><p>Switching to Redis:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">dotnet add package Hangfire.Pro.Redis
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="n">builder</span><span class="p">.</span><span class="n">Services</span><span class="p">.</span><span class="n">AddHangfire</span><span class="p">(</span><span class="n">configuration</span> <span class="p">=&gt;</span> <span class="n">configuration</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">UseRedisStorage</span><span class="p">(</span><span class="s">&#34;localhost:6379&#34;</span><span class="p">));</span>
</span></span></code></pre></div><p>Redis also supports job prioritization, faster dashboard queries, and lower database load. The trade-off: Redis is eventually consistent, so job visibility (dashboard updates) may lag slightly compared to SQL Server&rsquo;s strong consistency.</p><p>Another scalability concern: long-running jobs. If a job takes an hour to complete, it ties up a worker thread for that duration. Consider splitting long-running jobs into smaller units or processing them on dedicated servers with higher worker counts. Hangfire&rsquo;s queue-based architecture supports this: route long-running jobs to a specific queue processed by dedicated servers.</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">Hangfire.States</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">BackgroundJob</span><span class="p">.</span><span class="n">Enqueue</span><span class="p">&lt;</span><span class="n">IReportGenerator</span><span class="p">&gt;(</span><span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span><span class="p">.</span><span class="n">GenerateLargeReport</span><span class="p">(),</span> <span class="k">new</span> <span class="n">EnqueuedState</span><span class="p">(</span><span class="s">&#34;reports&#34;</span><span class="p">));</span>
</span></span></code></pre></div><p>Configure a dedicated server to process only the <code>reports</code> queue:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="n">builder</span><span class="p">.</span><span class="n">Services</span><span class="p">.</span><span class="n">AddHangfireServer</span><span class="p">(</span><span class="n">options</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">options</span><span class="p">.</span><span class="n">Queues</span> <span class="p">=</span> <span class="k">new</span><span class="p">[]</span> <span class="p">{</span> <span class="s">&#34;reports&#34;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">options</span><span class="p">.</span><span class="n">WorkerCount</span> <span class="p">=</span> <span class="m">2</span><span class="p">;</span> <span class="c1">// Limit to two concurrent reports</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span></code></pre></div><p>This isolates resource-intensive jobs from standard background work, preventing them from starving other tasks.</p><h2 id="dashboard-and-observability"><a href="/posts/dotnet-job-scheduling-2-hangfire/#dashboard-and-observability" title="Dashboard and Observability">Dashboard and Observability</a></h2><p>Hangfire&rsquo;s dashboard is one of its most compelling features. It provides real-time visibility into job states without requiring custom telemetry or logging integration.</p><p>The dashboard displays:</p><ul><li><strong>Enqueued jobs</strong>: Waiting for worker threads.</li><li><strong>Processing jobs</strong>: Currently executing, with elapsed time and server information.</li><li><strong>Scheduled jobs</strong>: Delayed or recurring jobs awaiting their trigger time.</li><li><strong>Succeeded jobs</strong>: Completed successfully, with execution duration.</li><li><strong>Failed jobs</strong>: Errors, stack traces, and retry counts.</li><li><strong>Recurring jobs</strong>: Cron schedules, last execution time, next execution time.</li></ul><p>Administrators can manually trigger recurring jobs, delete failed jobs, or re-enqueue them for retry—all from the dashboard without writing code or deploying updates. This operational flexibility reduces time spent diagnosing background job issues.</p><p>Security considerations: the dashboard exposes sensitive information—job parameters, stack traces, server names. Protect it using authentication middleware:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="n">app</span><span class="p">.</span><span class="n">UseHangfireDashboard</span><span class="p">(</span><span class="s">&#34;/hangfire&#34;</span><span class="p">,</span> <span class="k">new</span> <span class="n">DashboardOptions</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Authorization</span> <span class="p">=</span> <span class="k">new</span><span class="p">[]</span> <span class="p">{</span> <span class="k">new</span> <span class="n">MyAuthorizationFilter</span><span class="p">()</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span></code></pre></div><p>Implement <code>IDashboardAuthorizationFilter</code> to restrict access based on roles, authentication status, or IP address.</p><p>For production systems, consider integrating Hangfire with external monitoring tools. Export job metrics—succeeded jobs per minute, average execution time, retry rates—to Prometheus, Application Insights, or Datadog. Hangfire&rsquo;s extensibility via filters and listeners makes this straightforward.</p><h2 id="when-hangfire-fits"><a href="/posts/dotnet-job-scheduling-2-hangfire/#when-hangfire-fits" title="When Hangfire Fits">When Hangfire Fits</a></h2><p>Hangfire excels in scenarios where:</p><ol><li><p><strong>Persistence is non-negotiable</strong>: Jobs must survive application restarts, deployments, or server reboots. Examples: user-initiated reports, data imports, long-running workflows.</p></li><li><p><strong>Observability matters</strong>: Teams need real-time visibility into job states without building custom dashboards or integrating logging frameworks.</p></li><li><p><strong>Web applications dominate your architecture</strong>: Hangfire integrates seamlessly with ASP.NET Core, leveraging existing database infrastructure without requiring separate message brokers or coordination services.</p></li><li><p><strong>Moderate throughput suffices</strong>: Thousands of jobs per minute work well. If you need hundreds of thousands, consider Redis-based storage or evaluate Quartz.NET for advanced clustering.</p></li><li><p><strong>Automatic retries reduce operational burden</strong>: Teams that value hands-off error handling benefit from Hangfire&rsquo;s built-in retry policies, eliminating custom retry logic.</p></li></ol><p>Hangfire is less suitable when:</p><ul><li><p><strong>Stateless deployments are required</strong>: Kubernetes environments favoring ephemeral pods may prefer in-memory schedulers like NCronJob, though Hangfire&rsquo;s database dependency isn&rsquo;t prohibitive if managed databases are available.</p></li><li><p><strong>Sub-second latency is critical</strong>: Hangfire&rsquo;s polling mechanism introduces latency (typically 1-5 seconds). Real-time event-driven systems might prefer message brokers like RabbitMQ or Azure Service Bus.</p></li><li><p><strong>Complex scheduling is paramount</strong>: While Hangfire supports cron expressions, it lacks Quartz.NET&rsquo;s advanced features like job calendars, misfire handling, or priority-based execution.</p></li></ul><h2 id="operational-benefits-and-trade-offs"><a href="/posts/dotnet-job-scheduling-2-hangfire/#operational-benefits-and-trade-offs" title="Operational Benefits and Trade-offs">Operational Benefits and Trade-offs</a></h2><p>Hangfire&rsquo;s primary operational benefit is reliability. Jobs stored in a database won&rsquo;t vanish due to application crashes or restarts. Administrators gain confidence that critical workflows—nightly data synchronization, scheduled email campaigns, periodic cache refreshes—execute reliably even during infrastructure turbulence.</p><p>The dashboard reduces debugging time. Instead of parsing logs to determine whether a job ran, succeeded, or failed, teams view job states in real-time. Failed jobs display stack traces inline, enabling root cause analysis without log aggregation tools.</p><p>Automatic retries reduce operational overhead. Transient failures—network blips, temporary service unavailability—self-heal without manual intervention. Teams spend less time monitoring background jobs and more time building features.</p><p>The trade-offs: database dependency and polling overhead. Teams must provision and maintain a database, configure connection strings, and monitor database health. In cloud environments, this might mean managed SQL instances (Azure SQL, Amazon RDS) with associated costs. Polling introduces latency and database load—acceptable for most workloads but noticeable in high-throughput or latency-sensitive scenarios.</p><h2 id="practical-takeaways"><a href="/posts/dotnet-job-scheduling-2-hangfire/#practical-takeaways" title="Practical Takeaways">Practical Takeaways</a></h2><p>Hangfire occupies the middle ground between simplicity and enterprise-grade features. It provides persistence without requiring clustering, visibility without custom telemetry, and retries without manual logic. For ASP.NET Core applications needing reliable background processing, Hangfire delivers substantial value with moderate operational complexity.</p><p>Consider Hangfire if:</p><ul><li>Your application uses SQL Server, PostgreSQL, or Redis.</li><li>Jobs must survive restarts and benefit from automatic retries.</li><li>You value built-in dashboards over custom monitoring solutions.</li><li>Throughput requirements are moderate (thousands per minute, not hundreds of thousands).</li></ul><p>Avoid Hangfire if:</p><ul><li>You need stateless, zero-dependency deployments (see NCronJob or Coravel).</li><li>Complex scheduling with calendars and advanced triggers is essential (see Quartz.NET).</li><li>Ultra-low latency or extremely high throughput is required (consider message brokers or TickerQ).</li></ul><p>The next article explores Quartz.NET, a framework that extends Hangfire&rsquo;s persistence model with enterprise-grade features: clustering, advanced scheduling semantics, and multi-datacenter coordination. Where Hangfire simplifies reliability for web applications, Quartz.NET targets systems with complex scheduling demands and high-scale distributed deployments.</p></section><section class="giscus"><h2>Comments</h2><aside class="giscus" id="giscus-thread" role="region" aria-label="Comments"></aside></section><script src="https://giscus.app/client.js" data-repo="dailydevops/dailydevops.github.io" data-repo-id="R_kgDOHA8eFg" data-category="Announcements" data-category-id="DIC_kwDOHA8eFs4COIqL" data-mapping="pathname" data-strict="1" data-reactions-enabled="0" data-emit-metadata="0" data-input-position="bottom" data-theme="light" data-lang="en" crossorigin="anonymous" async></script></article><aside class="sidebar divider"><section class="sidecar info" aria-labelledby="info-heading"><header><h2 id="info-heading" class="sr-only">Informations</h2></header><ul role="list"><li role="listitem"><time datetime="2025-11-27T17:00:00+01:00" itemprop="datePublished">Published on 11/27/25 5:00 pm</time></li><li>Read in 10 minutes</li></ul></section><section class="sidecar series" aria-labelledby="series-heading"><header><h2 id="series-heading">Series content</h2></header><nav class="series-nav" role="navigation" aria-label="Series content"><ul role="list"><li role="listitem"><a href="https://daily-devops.net/posts/dotnet-job-scheduling-1-landscape/" title=".NET Job Scheduling — The Landscape" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right" aria-hidden="true"></i>&nbsp;
.NET Job Scheduling — The Landscape</a></li><li role="listitem"><a href="https://daily-devops.net/posts/dotnet-job-scheduling-2-hangfire/" title=".NET Job Scheduling — Hangfire and Persistent Reliability" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right" aria-hidden="true"></i>&nbsp;
.NET Job Scheduling — Hangfire and Persistent Reliability</a></li><li role="listitem"><a href="https://daily-devops.net/posts/dotnet-job-scheduling-3-quartznet/" title=".NET Job Scheduling — Quartz.NET for Enterprise Scale" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right" aria-hidden="true"></i>&nbsp;
.NET Job Scheduling — Quartz.NET for Enterprise Scale</a></li><li role="listitem"><a href="https://daily-devops.net/posts/dotnet-job-scheduling-4-coravel/" title=".NET Job Scheduling — Coravel and Fluent Simplicity" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right" aria-hidden="true"></i>&nbsp;
.NET Job Scheduling — Coravel and Fluent Simplicity</a></li><li role="listitem"><a href="https://daily-devops.net/posts/dotnet-job-scheduling-5-ncronjob/" title=".NET Job Scheduling — NCronJob and Native Minimalism" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right" aria-hidden="true"></i>&nbsp;
.NET Job Scheduling — NCronJob and Native Minimalism</a></li><li role="listitem"><a href="https://daily-devops.net/posts/dotnet-job-scheduling-6-tickerq/" title=".NET Job Scheduling — TickerQ and Modern Architecture" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right" aria-hidden="true"></i>&nbsp;
.NET Job Scheduling — TickerQ and Modern Architecture</a></li><li role="listitem"><a href="https://daily-devops.net/posts/dotnet-job-scheduling-7-comparative-review/" title=".NET Job Scheduling — Choosing the Right Framework" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right" aria-hidden="true"></i>&nbsp;
.NET Job Scheduling — Choosing the Right Framework</a></li></ul></nav></section><section class="sidecar author" aria-labelledby="author-martin-st%C3%BChmer"><header><h2 id="author-martin-st%C3%BChmer"><a href="/authors/martin/" rel="author" title="Martin Stühmer" itemprop="url">Author <span itemprop="name">Martin Stühmer</span></a></h2></header><figure class="round"><picture><img src="https://www.gravatar.com/avatar/6da4a47ff9cc2b750452225fdb2582f7?d=identicon&amp;s=200" alt="Martin Stühmer" loading="lazy" decoding="async" title="Martin Stühmer"></picture></figure><section class="content" itemprop="description">Martin is a software architect and developer who has spent nearly two decades navigating the .NET ecosystem from Framework 2.0 to modern .NET 10. As Director Consulting Services at CGI and a Microsoft Certified Trainer, he specializes in cloud-native solutions, enterprise architecture, and Risk and Cost Driven Architecture (RCDA). His mission is straightforward - help teams build quality software that survives contact with production. He contributes to open-source communities through NuGet packages, writes about pragmatic software engineering on this blog, and trains developers who want substance over buzzwords.</section><a class="link" href="/authors/martin/" rel="author" aria-label="Author Martin Stühmer: Read more"></a></section><section class="sidecar social" aria-labelledby="social-heading"><header><h2 id="social-heading">Social media</h2></header><nav class="social-nav" role="navigation" aria-label="Social media links"><a class="icon bluesky" href="https://bsky.app/profile/samtrion.net" rel="noopener external" aria-label="Follow me on Bluesky" target="_blank"><span class="fa-stack fa-fw fa-1x" aria-hidden="true"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-bluesky fa-stack-1x fa-inverse"></i>
</span></a><a class="icon github" href="https://github.com/samtrion" rel="noopener external" aria-label="Follow me on GitHub" target="_blank"><i class="fa-brands fa-fw fa-github fa-2x" aria-hidden="true"></i></a>
<a class="icon linkedin" href="https://www.linkedin.com/in/martin-stuehmer" rel="noopener external" aria-label="Follow me on LinkedIn" target="_blank"><span class="fa-stack fa-fw fa-1x" aria-hidden="true"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-linkedin-in fa-stack-1x fa-inverse"></i>
</span></a><a class="icon stackoverflow" href="https://stackoverflow.com/users/10574963" rel="noopener external" aria-label="Follow me on Stack Overflow" target="_blank"><span class="fa-stack fa-fw fa-1x" aria-hidden="true"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-stack-overflow fa-stack-1x fa-inverse"></i>
</span></a><a class="icon mail" href="mailto:martin@daily-devops.net" aria-label="Contact me by e-mail" target="_blank"><span class="fa-stack fa-fw fa-1x" aria-hidden="true"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
</span></a><a class="icon feed" href="/authors/martin/feed.rss" aria-label="My RSS feed" target="_blank"><span class="fa-stack fa-fw fa-1x" aria-hidden="true"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></nav></section><section class="sidecar share" aria-labelledby="share-heading"><header><h2 id="share-heading">Share this content</h2></header><a class="icon linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fdaily-devops.net%2fposts%2fdotnet-job-scheduling-2-hangfire%2f&text=.NET%20Job%20Scheduling%20%e2%80%94%20Hangfire%20and%20Persistent%20Reliability%20%26mdash%3b%20Daily%20DevOps%20%26%20.NET" target="_blank" rel="noopener external" aria-label="Share on LinkedIn" title="Share on LinkedIn" target="_blank"><i class="fa-brands fa-fw fa-linkedin-in fa-2x"></i></a>
<a class="icon bluesky" href="https://bsky.app/intent/compose?text=.NET%20Job%20Scheduling%20%e2%80%94%20Hangfire%20and%20Persistent%20Reliability%20%26mdash%3b%20Daily%20DevOps%20%26%20.NET%20https%3a%2f%2fdaily-devops.net%2fposts%2fdotnet-job-scheduling-2-hangfire%2f" target="_blank" rel="noopener external" aria-label="Share on Bluesky" title="Share on Bluesky" target="_blank"><i class="fa-brands fa-fw fa-bluesky fa-2x"></i></a></section><section class="sidecar tags" aria-labelledby="tags-heading"><header><h2 id="tags-heading">Tags</h2></header><ul class="tags" role="list"><li class="tag" role="listitem"><a href="/tags/dotnet/" hreflang="en" rel="tag" title=".NET" aria-label=".NET tag"><i class="fas fa-tag" aria-hidden="true"></i>&nbsp;.NET</a></li><li class="tag" role="listitem"><a href="/tags/architecture/" hreflang="en" rel="tag" title="Architecture" aria-label="Architecture tag"><i class="fas fa-tag" aria-hidden="true"></i>&nbsp;Architecture</a></li><li class="tag" role="listitem"><a href="/tags/csharp/" hreflang="en" rel="tag" title="C#" aria-label="C# tag"><i class="fas fa-tag" aria-hidden="true"></i>&nbsp;C#</a></li><li class="tag" role="listitem"><a href="/tags/nuget/" hreflang="en" rel="tag" title="NuGet" aria-label="NuGet tag"><i class="fas fa-tag" aria-hidden="true"></i>&nbsp;NuGet</a></li><li class="tag" role="listitem"><a href="/tags/softwareengineering/" hreflang="en" rel="tag" title="Software Engineering" aria-label="Software Engineering tag"><i class="fas fa-tag" aria-hidden="true"></i>&nbsp;Software Engineering</a></li></ul></section><section class="sidecar links" aria-labelledby="links-heading"><header><h2 id="links-heading">Additional links</h2></header><nav class="links-nav" role="navigation" aria-label="Additional links"><ul role="list"><li role="listitem"><a href="https://docs.hangfire.io/" title="Hangfire Documentation" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right" aria-hidden="true"></i>&nbsp;
Hangfire Documentation</a></li><li role="listitem"><a href="https://github.com/HangfireIO/Hangfire" title="Hangfire on GitHub" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right" aria-hidden="true"></i>&nbsp;
Hangfire on GitHub</a></li></ul></nav></section><section class="sidecar related" aria-labelledby="related-heading"><header><h2 id="related-heading">Related content</h2></header><article class="post"><figure class="square"><picture><source srcset="/images/nuget-scheduler-80x80.webp?v=4e5974129f045a8390e2e29b217f7ecc" type="image/webp"><source srcset="/images/nuget-scheduler-80x80.png?v=21983cb7d1aaee6a20b10806f639db1c" type="image/png"><img src="/images/nuget-scheduler.png?v=4159bfd7c08b58b0fc741782fe532741" alt=".NET Job Scheduling — The Landscape" loading="lazy" decoding="async" title=".NET Job Scheduling — The Landscape"></picture></figure><header><h2><a href="/posts/dotnet-job-scheduling-1-landscape/" rel="bookmark">.NET Job Scheduling — The Landscape</a></h2></header><section class="content" role="region">Explore the spectrum of .NET job scheduling from lightweight in-memory solutions to enterprise-grade distributed systems.
Understand which approach fits your operational model and why background processing architecture matters.</section></article><article class="post"><figure class="square"><picture><source srcset="/images/dotnet-paradox-80x80.webp?v=a76b10cb59eb84e618d091091ee7d79c" type="image/webp"><source srcset="/images/dotnet-paradox-80x80.png?v=29e2f5a0c373c3060fc6fc04c3fd3c63" type="image/png"><img src="/images/dotnet-paradox.png?v=fab3db4941c79e6e7ad156d66492c87b" alt=".NET 10 and the Release Cycle Paradox" loading="lazy" decoding="async" title=".NET 10 and the Release Cycle Paradox"></picture></figure><header><h2><a href="/posts/dotnet-10-release-cycle-paradox/" rel="bookmark">.NET 10 and the Release Cycle Paradox</a></h2></header><section class="content" role="region"><p>.NET’s yearly rhythm has become a symbol of stability — yet also a source of pressure.
The <strong>release cycle paradox</strong> describes the tension between predictability and exhaustion: a release schedule that keeps the ecosystem healthy, but teams constantly catching up.</p><p>With .NET 10 on the horizon, developers must learn to navigate this rhythm rather than fight it.</p></section></article><article class="post"><figure class="square"><picture><source srcset="/images/package-manager-80x80.webp?v=511fdb8a7197cb20401abc8c2a7b2d51" type="image/webp"><source srcset="/images/package-manager-80x80.png?v=e2d9bba485820dc0336d1253eb4dd7a1" type="image/png"><img src="/images/package-manager.png?v=19ac8eda9b0cc3394a0da24151d44079" alt="Modern Defensive Programming in .NET — Unified Throw-Helpers and Multi-Framework Compatibility" loading="lazy" decoding="async" title="Modern Defensive Programming in .NET — Unified Throw-Helpers and Multi-Framework Compatibility"></picture></figure><header><h2><a href="/posts/modern-defensive-programming/" rel="bookmark">Modern Defensive Programming in .NET — Unified Throw-Helpers and Multi-Framework Compatibility</a></h2></header><section class="content" role="region">Modern .NET introduces powerful throw-helper methods such as <code>ArgumentNullException.ThrowIfNull</code> and <code>ArgumentException.ThrowIfNullOrEmpty</code> to simplify defensive programming.
However, many projects still target older frameworks where these APIs are missing.
This article explores how the <strong>NetEvolve.Arguments</strong> library delivers a unified, backward-compatible API that brings modern guard clause patterns to every .NET version, ensuring consistent validation, maintainability, and multi-framework compatibility.</section></article></section></aside><nav class="pager" aria-label="Article navigation" role="navigation"><a class="next" href="/posts/dotnet-job-scheduling-3-quartznet/" rel="next" aria-label="Next: .NET Job Scheduling — Quartz.NET for Enterprise Scale"><span class="sub"><i class="fas fa-backward" aria-hidden="true"></i>&emsp;<span class="sr-only">Next</span></span><p class="title">.NET Job Scheduling — Quartz.NET for Enterprise Scale</p></a><a class="prev" href="/posts/dotnet-job-scheduling-1-landscape/" rel="prev" aria-label="Previous: .NET Job Scheduling — The Landscape"><span class="sub"><span class="sr-only">Previous</span>&emsp;<i class="fas fa-forward" aria-hidden="true"></i></span><p class="title">.NET Job Scheduling — The Landscape</p></a></nav></main><footer class="footer"><div class="divider"></div><nav><ul class="navigation"><li><a href="/tags/">Tags</a></li><li><a href="/legal-notice/">Legal notice</a></li></ul></nav><div class="copyright">&copy; 2023 - 2026 Daily DevOps & .NET</div></footer><script defer src="/js/below.min.a6ce9164454b6077f17ae856f280442d9f3a1e21f06189f71c21f75144b22a0c8cf32bafd61d440e9d90ca02bf738b6a8ef19f5ec20285d8ca574f98c91ebaf2.js" integrity="sha512-ps6RZEVLYHfxeuhW8oBELZ86HiHwYYn3HCH3UUSyKgyM8yuv1h1EDp2QygK/c4tqjvGfXsIChdjKV0+YyR668g==" crossorigin="anonymous"></script><img class="vgwort" src="https://vg05.met.vgwort.de/na/e7ffe6bcb3e14b4c8d88e99e6c8607a9" width="1" height="1" alt="VG Wort" title="VG Wort"></body></html>