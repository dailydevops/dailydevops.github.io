<!doctype html><html class="no-js" lang="en" dir="ltr"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="theme-color" content="#15a"><title>.NET CLI 10 – Microsoft Finally Realizes DevOps Exists — Daily DevOps & .NET</title><meta name="description" content="The .NET CLI? Reliable. Boring. You run dotnet build, dotnet test, dotnet publish, done. Real DevOps work happens in …"><meta name="twitter:description" property="og:description" content="The .NET CLI? Reliable. Boring. You run dotnet build, dotnet test, dotnet publish, done. Real DevOps work happens in …"><meta name="author" content="Martin Stühmer"><link rel="icon" href="/logo.svg?v=b9e294dc5c6fa04439c8c803d8e981a9" sizes="any" type="image/svg+xml"><meta name="twitter:title" property="og:title" content=".NET CLI 10 – Microsoft Finally Realizes DevOps Exists — Daily DevOps & .NET"><meta property="og:updated_time" content="2025-12-25T20:02:23+01:00"><meta property="article:modified_time" content="2025-12-25T20:02:23+01:00"><meta property="article:published_time" content="2025-12-25T17:00:00+01:00"><meta property="og:type" content="article"><meta property="og:site_name" content="Daily DevOps & .NET"><meta property="og:url" content="https://daily-devops.net/posts/dotnet-10-cli-devops/"><meta property="og:locale" content="en_US"><meta name="twitter:card" content="summary_large_image"><meta property="og:image" name="twitter:image" content="https://daily-devops.net/images/cli-1200x630.webp?v=f1c2870b0ac825fad6ebc8ac4a1f2368"><meta property="og:image:secure_url" content="https://daily-devops.net/images/cli-1200x630.webp?v=f1c2870b0ac825fad6ebc8ac4a1f2368"><meta property="og:image:alt" name="twitter:image:alt" content=".NET CLI 10 – Microsoft Finally Realizes DevOps Exists"><meta property="og:image:type" content="image/webp"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta property="og:image" name="twitter:image" content="https://daily-devops.net/images/cli-1200x630.png?v=ff2b9271110e030dbfaf200a81fa89a5"><meta property="og:image:secure_url" content="https://daily-devops.net/images/cli-1200x630.png?v=ff2b9271110e030dbfaf200a81fa89a5"><meta property="og:image:alt" name="twitter:image:alt" content=".NET CLI 10 – Microsoft Finally Realizes DevOps Exists"><meta property="og:image:type" content="image/png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><link rel="dns-prefetch" href="https://www.clarity.ms"><link rel="preconnect" href="https://www.clarity.ms" crossorigin><link rel="stylesheet" href="/css/style.min.0b2ef4378cd908eb695017aaa74603d244ff2b38c8068b4b51d76cad830c8ee5e3a40b67ab5b860a542c8bae73d8ba90cfbe9249b59c733a50de74cc32af818a.css" integrity="sha512-Cy70N4zZCOtpUBeqp0YD0kT/KzjIBotLUddsrYMMjuXjpAtnq1uGClQsi65z2LqQz76SSbWcczpQ3nTMMq+Big==" crossorigin="anonymous"><link rel="alternate" href='https://daily-devops.net/posts/dotnet-10-cli-devops/' hreflang="x-default" title=".NET CLI 10 – Microsoft Finally Realizes DevOps Exists &mdash; Daily DevOps & .NET"><link rel="canonical" href="https://daily-devops.net/posts/dotnet-10-cli-devops/" hreflang="en-us" title=".NET CLI 10 – Microsoft Finally Realizes DevOps Exists &mdash; Daily DevOps & .NET"><link rel="home" href="https://daily-devops.net/" hreflang="en-us" title="Daily DevOps & .NET"><link rel="next" href="https://daily-devops.net/posts/dotnet-2025-year-in-review/" hreflang="en-us" title="2025 in Review: The Year .NET Stopped Lying to Itself"><link rel="prev" href="https://daily-devops.net/posts/dotnet-advanced-logging/" hreflang="en-us" title="Why Your Logging Strategy Fails in Production"><link rel="author" href="https://daily-devops.net/authors/martin/" hreflang="en-us" title="Martin Stühmer &mdash; Daily DevOps & .NET"><meta name="giscus:backlink" content="https://daily-devops.net/posts/dotnet-10-cli-devops/"><script defer src="/js/above.min.cb42b2c9a453e49e278326637d72d2f01e7f32e3f91e9cdde8fb587793d05514efd2f5cc5021c9658ca0f73876dbdcd1f7cb4a37c0bebc9df01110926b6d7cba.js" integrity="sha512-y0KyyaRT5J4ngyZjfXLS8B5/MuP5Hpzd6PtYd5PQVRTv0vXMUCHJZYyg9zh229zR98tKN8C+vJ3wERCSa218ug==" crossorigin="anonymous"></script><script type="text/javascript">(function(e,t,n,s,o,i,a){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)},i=t.createElement(s),i.async=1,i.src="https://www.clarity.ms/tag/"+o,a=t.getElementsByTagName(s)[0],a.parentNode.insertBefore(i,a)})(window,document,"clarity","script","o0pr4n9gg3")</script></head><body class="container"><header class="header"><a class="logo" href="/" title="Daily DevOps & .NET" rel="home"><figure class="page-logo"><picture><img src="/logo.svg?v=b9e294dc5c6fa04439c8c803d8e981a9" alt="Daily DevOps & .NET" title="Daily DevOps & .NET"></picture></figure><span class="title">Daily DevOps & .NET</span></a><nav class="menu"><button class="burger" aria-haspopup="true" aria-expanded="false" tabindex="0">
<i class="fas fa-burger"></i></button><ul class="navigation"><li class="active"><a href="/posts/">Posts</a></li><li><a href="/authors/">About us</a></li></ul></nav><div class="divider"></div></header><main class="body"><figure class="hero"><picture><source srcset="/images/cli-544x136.webp?v=b56f1d95d52c832d1eefb6ad95321b4b" type="image/webp" media="(max-width: 575.98px)"><source srcset="/images/cli-544x136.png?v=96d5a0dedf7867abbe1aa2e313ee2b9b" type="image/png" media="(max-width: 575.98px)"><source srcset="/images/cli-672x168.webp?v=0d04c546ccf44c990cce6cdc6f109cd7" type="image/webp" media="(max-width: 767.98px)"><source srcset="/images/cli-672x168.png?v=47a7ae99884adda9b9b4ad52afbbe98c" type="image/png" media="(max-width: 767.98px)"><source srcset="/images/cli-896x224.webp?v=cfa443d4e8a83c2dfa7d3a3f3bfda70b" type="image/webp" media="(max-width: 991.98px)"><source srcset="/images/cli-896x224.png?v=1ed446efaa6b341256d55722bd560290" type="image/png" media="(max-width: 991.98px)"><source srcset="/images/cli-1104x276.webp?v=4d91808bdbad9d949949875e68db9c35" type="image/webp" media="(max-width: 1199.98px)"><source srcset="/images/cli-1104x276.png?v=45b99363d29db43fdc1393f6463adeb8" type="image/png" media="(max-width: 1199.98px)"><source srcset="/images/cli-1444x361.webp?v=624c006b19da4c4fd07b628480786884" type="image/webp"><source srcset="/images/cli-1444x361.png?v=0fd5ca62ad024c28bf36e0e051e0763e" type="image/png"><img src="/images/cli.png?v=74daed50d0ea188d53fcad80f79e87ba" alt=".NET CLI 10 – Microsoft Finally Realizes DevOps Exists" loading="lazy" decoding="async" title=".NET CLI 10 – Microsoft Finally Realizes DevOps Exists"></picture></figure><article class="post"><header><h1>.NET CLI 10 – Microsoft Finally Realizes DevOps Exists</h1></header><section class="content"><p>The .NET CLI? Reliable. Boring. You run <code>dotnet build</code>, <code>dotnet test</code>, <code>dotnet publish</code>, done. Real DevOps work happens in Dockerfiles, CI/CD configs, and specialized tools. The CLI does its job but was never built for actual operational workflows.</p><p>.NET 10 changes this. Four additions that sound minor but fix real problems I&rsquo;ve hit in production pipelines for years: native container publishing, ephemeral tool execution, better cross-platform packaging, and machine-readable schemas. Not flashy. Not keynote material. But they&rsquo;re the kind of improvements that save hours every week once you&rsquo;re running them at scale.</p><p>Will they replace your current workflow? Depends on what you&rsquo;re building. Let&rsquo;s look at what actually changed.</p><h2 id="built-in-container-publishing-dockerfiles-become-optional"><a href="/posts/dotnet-10-cli-devops/#built-in-container-publishing-dockerfiles-become-optional" title="Built-in Container Publishing: Dockerfiles Become Optional">Built-in Container Publishing: Dockerfiles Become Optional</a></h2><p>Let&rsquo;s start with the biggest change: <code>dotnet publish</code> now generates container images directly. No Dockerfile needed.</p><p>You know the drill. Write a Dockerfile (full control, maintenance hell) or use Docker Build Cloud (more dependencies, more complexity). Both work. Both suck in their own ways.</p><p>.NET 8 tried this with <code>Microsoft.NET.Build.Containers</code>—opt-in, awkward, felt bolted-on. .NET 10 makes it first-class. There are still limits, but the core experience is solid.</p><h3 id="how-it-works"><a href="/posts/dotnet-10-cli-devops/#how-it-works" title="How It Works">How It Works</a></h3><p>One command:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">dotnet publish --os linux --arch x64 /t:PublishContainer
</span></span></code></pre></div><p>Compiles for Linux x64. Packages as OCI container. Tags from project metadata. Pushes if you have credentials.</p><p>No Dockerfile. No multi-stage builds. No base image debates. The CLI handles it using project defaults—works great for standard apps, questionable for edge cases.</p><h3 id="practical-implications"><a href="/posts/dotnet-10-cli-devops/#practical-implications" title="Practical Implications">Practical Implications</a></h3><p>Where this really shines: CI/CD pipelines. I&rsquo;ve been maintaining GitHub Actions workflows that look like this for years:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl">- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">Build</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">run</span><span class="p">:</span><span class="w"> </span><span class="l">dotnet build --configuration Release</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl">- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">Build Docker Image</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">run</span><span class="p">:</span><span class="w"> </span><span class="l">docker build -t myapp:latest .</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl">- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">Push to Registry</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">run</span><span class="p">:</span><span class="w"> </span><span class="l">docker push myapp:latest</span><span class="w">
</span></span></span></code></pre></div><p>Now:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl">- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">Publish Container</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">run</span><span class="p">:</span><span class="w"> </span><span class="l">dotnet publish --os linux --arch x64 /t:PublishContainer</span><span class="w">
</span></span></span></code></pre></div><p>Docker&rsquo;s gone. The CLI handles everything. For lightweight build agents or K8s-based CI, this cuts build times and removes a dependency I&rsquo;ve been wanting to ditch.</p><p>But here&rsquo;s the trade-off—you surrender control to CLI defaults. Standard app? Perfect. Need custom base images, specific layers, or complex configs? You&rsquo;re back to Dockerfiles. The CLI won&rsquo;t bend that far yet.</p><h3 id="when-dockerfiles-remain-necessary"><a href="/posts/dotnet-10-cli-devops/#when-dockerfiles-remain-necessary" title="When Dockerfiles Remain Necessary">When Dockerfiles Remain Necessary</a></h3><p>Dockerfiles aren&rsquo;t dead—just optional for simple cases. Need custom layers, multi-stage builds, or complex runtime configs? Use Dockerfiles. For standard ASP.NET Core on Linux? CLI wins.</p><p>The philosophy makes sense: You shouldn&rsquo;t need Docker expertise to containerize a .NET app. But production systems need security scanning, vulnerability patches, compliance checks. The CLI gives you a working container. Whether it&rsquo;s production-ready depends on your standards.</p><p>Containers are one piece. The other friction point in DevOps pipelines? Tool management.</p><h2 id="one-shot-global-tools-dotnet-tool-exec"><a href="/posts/dotnet-10-cli-devops/#one-shot-global-tools-dotnet-tool-exec" title="One-Shot Global Tools: dotnet tool exec">One-Shot Global Tools: <code>dotnet tool exec</code></a></h2><p>Global tools have been around since .NET Core 2.1. Install, then execute. Two steps, every time, and it gets messy fast in CI environments.</p><p>.NET 10 adds <code>dotnet tool exec</code>. Run tools without installing. Like <code>npx</code> in Node.js.</p><h3 id="before"><a href="/posts/dotnet-10-cli-devops/#before" title="Before">Before</a></h3><p>Here&rsquo;s what I&rsquo;ve been doing in CI pipelines:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">dotnet tool install --global dotnet-format
</span></span><span class="line"><span class="cl">dotnet format --verify-no-changes
</span></span></code></pre></div><p>Already installed? First command fails (or needs <code>--ignore-failed-sources</code>). Not installed? Second fails. Managing this state across multiple build agents turns into a fragile mess with conditional logic everywhere.</p><h3 id="now"><a href="/posts/dotnet-10-cli-devops/#now" title="Now">Now</a></h3><p>.NET 10 adds <code>dotnet tool exec</code>:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">dotnet tool <span class="nb">exec</span> dotnet-format -- --verify-no-changes
</span></span></code></pre></div><p>Fetch, run, discard. No global state. No cleanup. No version conflicts between pipeline runs.</p><h3 id="why-this-matters-for-cicd"><a href="/posts/dotnet-10-cli-devops/#why-this-matters-for-cicd" title="Why This Matters for CI/CD">Why This Matters for CI/CD</a></h3><p>CI needs stateless builds. This delivers exactly that. Each run fetches the exact tool version, executes, done. No version conflicts. No pre-baking tools into build images.</p><p>Working with minimal base images? Just run tools on-demand. No more Dockerfile layers dedicated to tool installations that bloat your images.</p><p>The catch is download overhead per execution. For tools you run repeatedly in tight loops, add caching. The CLI doesn&rsquo;t auto-cache between <code>exec</code> calls, so repeated executions add latency. In most scenarios, simplicity beats speed. High-frequency pipelines? Measure first.</p><h3 id="local-development-benefits"><a href="/posts/dotnet-10-cli-devops/#local-development-benefits" title="Local Development Benefits">Local Development Benefits</a></h3><p>This isn&rsquo;t just for CI. Working across multiple projects, I&rsquo;ve always hated maintaining a global tool collection that inevitably ends up with version conflicts. Now I run project-specific tools without polluting my environment. Node.js devs have had this with <code>npx</code> for years—about time .NET caught up.</p><p>Versioning still matters. Need a specific version? Specify it or use <code>dotnet-tools.json</code>. The CLI won&rsquo;t guess.</p><p>While we&rsquo;re talking about tools, there&rsquo;s another improvement that tool authors will appreciate.</p><h2 id="multi-platform-global-tool-packaging"><a href="/posts/dotnet-10-cli-devops/#multi-platform-global-tool-packaging" title="Multi-Platform Global Tool Packaging">Multi-Platform Global Tool Packaging</a></h2><p>Older .NET versions claimed cross-platform support for tools. Reality? Separate packages for <code>linux-x64</code>, <code>win-x64</code>, <code>osx-arm64</code>. Add native dependencies and you&rsquo;re in for a nightmare.</p><p>.NET 10 improves RID handling. One NuGet package, multiple platforms. The CLI resolves the right binary at runtime based on the target platform.</p><p>Works well for simple cases. Complex native dependencies? Still rough, but better than before.</p><h3 id="impact-on-tool-authors"><a href="/posts/dotnet-10-cli-devops/#impact-on-tool-authors" title="Impact on Tool Authors">Impact on Tool Authors</a></h3><p>If you maintain global tools, you can finally ship one package for all platforms. Less packaging hell, fewer user install failures due to platform mismatches.</p><p>Not revolutionary. Incremental. Should&rsquo;ve been fixed years ago, but I&rsquo;ll take it.</p><p>Now here&rsquo;s the feature that flew completely under the radar but might end up being the most useful for automation.</p><h2 id="cli-schema-export-automation-meets-introspection"><a href="/posts/dotnet-10-cli-devops/#cli-schema-export-automation-meets-introspection" title="CLI Schema Export: Automation Meets Introspection">CLI Schema Export: Automation Meets Introspection</a></h2><p>Machine-readable CLI schemas. Sounds boring. Actually game-changing for tooling and automation that currently relies on parsing brittle text output.</p><h3 id="what-is-a-cli-schema"><a href="/posts/dotnet-10-cli-devops/#what-is-a-cli-schema" title="What Is a CLI Schema?">What Is a CLI Schema?</a></h3><p>It&rsquo;s structured data describing CLI commands, options, and arguments. What the CLI can execute, what parameters it accepts, how they interact.</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">dotnet --info --format json
</span></span></code></pre></div><p>JSON output: CLI capabilities, SDKs, runtimes, commands. Queryable, parseable, stable across versions.</p><h3 id="use-cases"><a href="/posts/dotnet-10-cli-devops/#use-cases" title="Use Cases">Use Cases</a></h3><p>Where this gets practical:</p><p><strong>IDE Integration:</strong> VS Code could add IntelliSense for CLI commands directly in terminal windows. They&rsquo;d need to implement it first, but the foundation&rsquo;s there.</p><p><strong>CI/CD Validation:</strong> Check .NET versions before your build fails halfway through. Catch environment mismatches early instead of debugging why the pipeline suddenly broke.</p><p><strong>Tooling Development:</strong> Third-party tools can adapt to CLI capabilities dynamically. No more hardcoded assumptions that break when the SDK updates.</p><p><strong>Documentation Generation:</strong> Auto-generate CLI reference docs from the schema. Always current, never stale.</p><p>This assumes the schema stays stable across releases. So far Microsoft&rsquo;s track record is decent. Worth monitoring as it matures.</p><h3 id="real-world-scenario"><a href="/posts/dotnet-10-cli-devops/#real-world-scenario" title="Real-World Scenario">Real-World Scenario</a></h3><p>Here&rsquo;s a concrete example. Your build script needs .NET 10 before it proceeds. Before, you&rsquo;d parse text output from <code>dotnet --version</code>—fragile and breaks whenever Microsoft tweaks the format.</p><p>Now:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">dotnet --info --format json <span class="p">|</span> jq -r <span class="s1">&#39;.sdks[] | select(.version | startswith(&#34;10.&#34;))&#39;</span>
</span></span></code></pre></div><p>No results? .NET 10 isn&rsquo;t installed. Results? You have the exact version and installation path. Structured, reliable, resistant to cosmetic changes.</p><p>The catch is you need <code>jq</code> or equivalent JSON parsing. Modern CI systems? Not a problem. Windows environments without JSON tooling pre-installed? You&rsquo;ve just shifted the complexity somewhere else.</p><h3 id="the-bigger-picture"><a href="/posts/dotnet-10-cli-devops/#the-bigger-picture" title="The Bigger Picture">The Bigger Picture</a></h3><p>This isn&rsquo;t flashy. It&rsquo;s foundational. The CLI transforms from a black box you invoke to a queryable API. That enables an entire class of tooling improvements—assuming the ecosystem actually builds them.</p><h2 id="why-these-changes-matter"><a href="/posts/dotnet-10-cli-devops/#why-these-changes-matter" title="Why These Changes Matter">Why These Changes Matter</a></h2><p>None of these features made keynotes. No press coverage. Not language features or runtime magic. But here&rsquo;s what&rsquo;s significant: Microsoft&rsquo;s finally investing in workflow ergonomics instead of just piling on features.</p><p>DevOps teams don&rsquo;t need more frameworks. We need less friction. Fewer dependencies, fewer scripts, fewer components that break when environments change. The .NET 10 CLI moves toward that—not perfectly, but noticeably.</p><p>Built-in containers eliminate Docker as a build dependency for standard cases. Tool exec removes global state from CI pipelines, though you pay in download overhead. Multi-platform packaging simplifies distribution when native dependencies cooperate. Schemas enable automation if you have JSON parsing infrastructure.</p><p>Real pain points addressed. Real trade-offs introduced. The CLI shifted from &ldquo;good enough&rdquo; to &ldquo;actually designed for ops work.&rdquo; It&rsquo;s not finished, but the direction is right.</p><h2 id="conclusion-evolution-not-revolution"><a href="/posts/dotnet-10-cli-devops/#conclusion-evolution-not-revolution" title="Conclusion: Evolution, Not Revolution">Conclusion: Evolution, Not Revolution</a></h2><p>.NET 10 isn&rsquo;t revolutionary. It&rsquo;s evolutionary. That&rsquo;s exactly what maturing platforms need—incremental wins that compound over time.</p><p>If you&rsquo;re running DevOps pipelines, building CI/CD workflows, or maintaining .NET tooling, these features aren&rsquo;t curiosities. They&rsquo;re practical improvements that&rsquo;ll simplify your work, speed execution, and improve reliability. You just need to understand the limits.</p><p>In environments where every eliminated dependency multiplies across thousands of builds monthly, &ldquo;simpler&rdquo; becomes a legitimate feature. Whether .NET 10&rsquo;s CLI improvements hit &ldquo;simple enough&rdquo; depends on your operational context and tolerance for trade-offs.</p><p>The direction is right. Whether it&rsquo;s sufficient for your specific needs? Test it in your environment. The CLI&rsquo;s finally built for DevOps work. Time to see if it holds up to production reality.</p></section><h2>Comments</h2><aside class="giscus"></aside><script src="https://giscus.app/client.js" data-repo="dailydevops/dailydevops.github.io" data-repo-id="R_kgDOHA8eFg" data-category="Announcements" data-category-id="DIC_kwDOHA8eFs4COIqL" data-mapping="pathname" data-strict="1" data-reactions-enabled="0" data-emit-metadata="0" data-input-position="bottom" data-theme="light" data-lang="en" crossorigin="anonymous" async></script></article><aside class="sidebar divider"><section class="sidecar info"><ul><li><time datetime="2025-12-25T17:00:00+01:00">Published on 12/25/25 5:00 pm</time></li><li>Read in 7 minutes</li></ul></section><section class="sidecar series"><header><h2>Series content</h2></header><a href="https://daily-devops.net/posts/dotnet-10-released/" title=".NET 10: Boring by Design, Reliable by Default
" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right"></i>&nbsp;
.NET 10: Boring by Design, Reliable by Default
</a><a href="https://daily-devops.net/posts/dotnet-10-testing/" title=".NET 10 Testing: Microsoft Finally Fixed the Test Runner (Mostly)
" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right"></i>&nbsp;
.NET 10 Testing: Microsoft Finally Fixed the Test Runner (Mostly)
</a><a href="https://daily-devops.net/posts/dotnet-power-of-ten-rules/" title="Power of Ten Rules: More Relevant Than Ever for .NET" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right"></i>&nbsp;
Power of Ten Rules: More Relevant Than Ever for .NET
</a><a href="https://daily-devops.net/posts/dotnet-10-cli-devops/" title=".NET CLI 10 – Microsoft Finally Realizes DevOps Exists" target="_blank" rel="noopener external noreferrer"><i class="fas fa-angles-right"></i>&nbsp;
.NET CLI 10 – Microsoft Finally Realizes DevOps Exists</a></section><section class="sidecar author"><header><h2><a href="/authors/martin/" rel="author" title="Martin Stühmer">Author Martin Stühmer</a></h2></header><figure class="round"><picture><img src="https://www.gravatar.com/avatar/6da4a47ff9cc2b750452225fdb2582f7?d=identicon&amp;s=200" alt="Martin Stühmer" loading="lazy" decoding="async" title="Martin Stühmer"></picture></figure><section class="content">Martin is a software architect and developer who has spent nearly two decades navigating the .NET ecosystem from Framework 2.0 to modern .NET 10. As Director Consulting Services at CGI and a Microsoft Certified Trainer, he specializes in cloud-native solutions, enterprise architecture, and Risk and Cost Driven Architecture (RCDA). His mission is straightforward - help teams build quality software that survives contact with production. He contributes to open-source communities through NuGet packages, writes about pragmatic software engineering on this blog, and trains developers who want substance over buzzwords.</section><a class="link" href="/authors/martin/" rel="author" title="Martin Stühmer"></a></section><section class="sidecar social"><header><h2>Social media</h2></header><a class="icon bluesky" href="https://bsky.app/profile/samtrion.net" rel="noopener external" title="Follow me on Bluesky" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-bluesky fa-stack-1x fa-inverse"></i>
</span></a><a class="icon github" href="https://github.com/samtrion" rel="noopener external" title="Follow me on GitHub" target="_blank"><i class="fa-brands fa-fw fa-github fa-2x"></i></a>
<a class="icon linkedin" href="https://www.linkedin.com/in/martin-stuehmer" rel="noopener external" title="Follow me on LinkedIn" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-linkedin-in fa-stack-1x fa-inverse"></i>
</span></a><a class="icon stackoverflow" href="https://stackoverflow.com/users/10574963" rel="noopener external" title="Follow me on Stack Overflow" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-stack-overflow fa-stack-1x fa-inverse"></i>
</span></a><a class="icon mail" href="mailto:martin@daily-devops.net" title="Contact me by e-mail" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
</span></a><a class="icon feed" href="/authors/martin/feed.rss" title="My RSS feed" target="_blank"><span class="fa-stack fa-fw fa-1x"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></section><section class="sidecar share"><header><h2>Share this content</h2></header><a class="icon linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fdaily-devops.net%2fposts%2fdotnet-10-cli-devops%2f&text=.NET%20CLI%2010%20%e2%80%93%20Microsoft%20Finally%20Realizes%20DevOps%20Exists%20%26mdash%3b%20Daily%20DevOps%20%26%20.NET" target="_blank" rel="noopener external" aria-label="Share on LinkedIn" title="Share on LinkedIn" target="_blank"><i class="fa-brands fa-fw fa-linkedin-in fa-2x"></i></a>
<a class="icon bluesky" href="https://bsky.app/intent/compose?text=.NET%20CLI%2010%20%e2%80%93%20Microsoft%20Finally%20Realizes%20DevOps%20Exists%20%26mdash%3b%20Daily%20DevOps%20%26%20.NET%20https%3a%2f%2fdaily-devops.net%2fposts%2fdotnet-10-cli-devops%2f" target="_blank" rel="noopener external" aria-label="Share on Bluesky" title="Share on Bluesky" target="_blank"><i class="fa-brands fa-fw fa-bluesky fa-2x"></i></a></section><section class="sidecar tags"><header><h2>Tags</h2></header><ul><li class="tag"><a href="/tags/dotnet/" hreflang="en" rel="tag" title=".NET"><i class="fas fa-tag"></i>&nbsp;.NET</a></li><li class="tag"><a href="/tags/bestpractices/" hreflang="en" rel="tag" title="Best Practices"><i class="fas fa-tag"></i>&nbsp;Best Practices</a></li><li class="tag"><a href="/tags/csharp/" hreflang="en" rel="tag" title="C#"><i class="fas fa-tag"></i>&nbsp;C#</a></li><li class="tag"><a href="/tags/cli/" hreflang="en" rel="tag" title="CLI"><i class="fas fa-tag"></i>&nbsp;CLI</a></li><li class="tag"><a href="/tags/devops/" hreflang="en" rel="tag" title="DevOps"><i class="fas fa-tag"></i>&nbsp;DevOps</a></li></ul></section><section class="sidecar related"><header><h2>Related content</h2></header><article class="post"><figure class="square"><picture><source srcset="/images/cli-80x80.webp?v=3e7f031ecf6dda72f28b932c76833165" type="image/webp"><source srcset="/images/cli-80x80.png?v=f6a47c2f53449fab29fe424492397326" type="image/png"><img src="/images/cli.png?v=74daed50d0ea188d53fcad80f79e87ba" alt="Stop Typing: The .NET CLI Tab Completion You've Been Missing" loading="lazy" decoding="async" title="Stop Typing: The .NET CLI Tab Completion You've Been Missing"></picture></figure><header><h2><a href="/posts/dotnet-cli-expanding-scope-autocomplete/" rel="bookmark">Stop Typing: The .NET CLI Tab Completion You've Been Missing</a></h2></header><section class="content">One command to transform your .NET CLI workflow—tab completion so responsive you&rsquo;ll wonder how you survived without it
Finally, a productivity boost that&rsquo;s actually worth your time</section></article><article class="post"><figure class="square"><picture><source srcset="/images/csharp-80x80.webp?v=0f7110ee2851196f14d99463a855759d" type="image/webp"><source srcset="/images/csharp-80x80.png?v=c5d685b0d4fa9ec69bd959ee04beb903" type="image/png"><img src="/images/csharp.png?v=21ff9dcf5d1da7bfa80141c972c117da" alt="Stop Parsing the Same String Twice: CompositeFormat in .NET" loading="lazy" decoding="async" title="Stop Parsing the Same String Twice: CompositeFormat in .NET"></picture></figure><header><h2><a href="/posts/compositeformat-performance-boost/" rel="bookmark">Stop Parsing the Same String Twice: CompositeFormat in .NET</a></h2></header><section class="content">Every time you call <code>string.Format()</code> with the same format string, .NET parses it again. And again. And again. CompositeFormat changes that: parse once, reuse forever. The result? Up to 30% faster formatting, fewer allocations, and a one-line code change. Here&rsquo;s why this matters and how to use it.</section></article><article class="post"><figure class="square"><picture><source srcset="/images/dotnet-80x80.webp?v=1d4b2dd465d7c025d943b4468cbf1985" type="image/webp"><source srcset="/images/dotnet-80x80.png?v=98376a285f07b0021d3118e0523d147a" type="image/png"><img src="/images/dotnet.png?v=8142ec8a038ba14415ff0d0434c78182" alt="ConstantExpectedAttribute: Unlocking Performance Through Compiler Awareness" loading="lazy" decoding="async" title="ConstantExpectedAttribute: Unlocking Performance Through Compiler Awareness"></picture></figure><header><h2><a href="/posts/constant-expected-attribute/" rel="bookmark">ConstantExpectedAttribute: Unlocking Performance Through Compiler Awareness</a></h2></header><section class="content">The ConstantExpectedAttribute, introduced in .NET 7, provides a powerful mechanism to signal compiler expectations about constant values. This enables better performance optimizations, enhanced IDE tooling, and clearer API contracts. Learn how to leverage this attribute to build more efficient and maintainable .NET applications.</section></article></section></aside><nav class="pager"><a class="next" href="/posts/dotnet-2025-year-in-review/" title="2025 in Review: The Year .NET Stopped Lying to Itself" rel="next"><span class="sub"><i class="fas fa-backward"></i>&emsp;Next</span><p class="title">2025 in Review: The Year .NET Stopped Lying to Itself</p></a><a class="prev" href="/posts/dotnet-advanced-logging/" title="Why Your Logging Strategy Fails in Production" rel="prev"><span class="sub">Previous&emsp;<i class="fas fa-forward"></i></span><p class="title">Why Your Logging Strategy Fails in Production</p></a></nav></main><footer class="footer"><div class="divider"></div><nav><ul class="navigation"><li><a href="/tags/">Tags</a></li><li><a href="/legal-notice/">Legal notice</a></li></ul></nav><div class="copyright">&copy; 2023 - 2025 Daily DevOps & .NET</div></footer><script defer src="/js/below.min.a6ce9164454b6077f17ae856f280442d9f3a1e21f06189f71c21f75144b22a0c8cf32bafd61d440e9d90ca02bf738b6a8ef19f5ec20285d8ca574f98c91ebaf2.js" integrity="sha512-ps6RZEVLYHfxeuhW8oBELZ86HiHwYYn3HCH3UUSyKgyM8yuv1h1EDp2QygK/c4tqjvGfXsIChdjKV0+YyR668g==" crossorigin="anonymous"></script><img class="vgwort" src="https://vg06.met.vgwort.de/na/2722d81f9f5a4c7a900b612325f4cb9d" width="1" height="1" alt="VG Wort" title="VG Wort"></body></html>