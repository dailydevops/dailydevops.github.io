<!doctype html><html class="no-js" lang="en" dir="ltr"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="theme-color" content="#15a"><title>C# Programming Language Articles — Daily DevOps & .NET</title><meta name="description" content="Explore C# tips, tricks, latest language features, and practical examples to enhance your .NET development skills, productivity, and code quality."><meta name="twitter:description" property="og:description" content="Explore C# tips, tricks, latest language features, and practical examples to enhance your .NET development skills, productivity, and code quality."><meta name="author" content="Daily DevOps"><link rel="icon" href="/logo.svg?v=b9e294dc5c6fa04439c8c803d8e981a9" sizes="any" type="image/svg+xml"><meta name="twitter:title" property="og:title" content="C# Programming Language Articles — Daily DevOps & .NET"><meta property="og:updated_time" content="2026-01-05T12:05:23+01:00"><meta property="article:modified_time" content="2026-01-05T12:05:23+01:00"><meta property="article:published_time" content="0001-01-01T00:00:00+00:00"><meta property="og:type" content="website"><meta property="og:site_name" content="Daily DevOps & .NET"><meta property="og:url" content="https://daily-devops.net/tags/csharp/"><meta property="og:locale" content="en"><meta name="twitter:card" content="summary_large_image"><meta property="og:image" name="twitter:image" content="https://daily-devops.net/images/csharp-1200x630.webp?v=c3708bde3d96269eb3e395537eb7c5d4"><meta property="og:image:secure_url" content="https://daily-devops.net/images/csharp-1200x630.webp?v=c3708bde3d96269eb3e395537eb7c5d4"><meta property="og:image:alt" name="twitter:image:alt" content="C# Programming Language Articles"><meta property="og:image:type" content="image/webp"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta property="og:image" name="twitter:image" content="https://daily-devops.net/images/csharp-1200x630.png?v=547760eed18b566792e92844110e5c96"><meta property="og:image:secure_url" content="https://daily-devops.net/images/csharp-1200x630.png?v=547760eed18b566792e92844110e5c96"><meta property="og:image:alt" name="twitter:image:alt" content="C# Programming Language Articles"><meta property="og:image:type" content="image/png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><link rel="dns-prefetch" href="https://www.clarity.ms"><link rel="preconnect" href="https://www.clarity.ms" crossorigin><link rel="stylesheet" href="/css/style.min.0b2ef4378cd908eb695017aaa74603d244ff2b38c8068b4b51d76cad830c8ee5e3a40b67ab5b860a542c8bae73d8ba90cfbe9249b59c733a50de74cc32af818a.css" integrity="sha512-Cy70N4zZCOtpUBeqp0YD0kT/KzjIBotLUddsrYMMjuXjpAtnq1uGClQsi65z2LqQz76SSbWcczpQ3nTMMq+Big==" crossorigin="anonymous"><link rel="alternate" href='https://daily-devops.net/tags/csharp/' hreflang="x-default" title="C# Programming Language Articles &mdash; Daily DevOps & .NET"><link rel="alternate" href="https://daily-devops.net/en/tags/csharp" hreflang="en" title="C# Programming Language Articles &mdash; Daily DevOps & .NET"><link rel="canonical" href="https://daily-devops.net/tags/csharp/" hreflang="en" title="C# Programming Language Articles &mdash; Daily DevOps & .NET"><link rel="home" href="https://daily-devops.net/" hreflang="en" title="Daily DevOps & .NET"><script defer src="/js/above.min.cb42b2c9a453e49e278326637d72d2f01e7f32e3f91e9cdde8fb587793d05514efd2f5cc5021c9658ca0f73876dbdcd1f7cb4a37c0bebc9df01110926b6d7cba.js" integrity="sha512-y0KyyaRT5J4ngyZjfXLS8B5/MuP5Hpzd6PtYd5PQVRTv0vXMUCHJZYyg9zh229zR98tKN8C+vJ3wERCSa218ug==" crossorigin="anonymous"></script><script type="text/javascript">(function(e,t,n,s,o,i,a){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)},i=t.createElement(s),i.async=1,i.src="https://www.clarity.ms/tag/"+o,a=t.getElementsByTagName(s)[0],a.parentNode.insertBefore(i,a)})(window,document,"clarity","script","o0pr4n9gg3")</script><script src="https://analytics.ahrefs.com/analytics.js" data-key="C5Iv+2Rb9el+FLJqVw2QGA" async></script></head><body class="container"><header class="header"><a class="logo" href="/" title="Daily DevOps & .NET" rel="home"><figure class="page-logo"><picture><img src="/logo.svg?v=b9e294dc5c6fa04439c8c803d8e981a9" alt="Daily DevOps & .NET" title="Daily DevOps & .NET"></picture></figure><span class="title">Daily DevOps & .NET</span></a><nav class="menu" aria-label="Main navigation"><button class="burger" type="button" aria-haspopup="menu" aria-expanded="false" aria-label="Toggle menu">
<i class="fas fa-burger" aria-hidden="true"></i></button><ul class="navigation"><li><a href="/posts/">Posts</a></li><li><a href="/authors/">About us</a></li></ul></nav><div class="divider"></div></header><main class="body"><main class="board" role="main"><header><h1>C# Programming Language Articles</h1></header><section class="content" role="region"><p>C# is Microsoft&rsquo;s modern, statically-typed language for .NET development. This collection explores C# features, language evolution, practical patterns, and techniques for writing clear, efficient code in the C# ecosystem.</p><h2 id="language-evolution-and-features"><a href="/tags/csharp/#language-evolution-and-features" title="Language Evolution and Features">Language Evolution and Features</a></h2><p>C# has evolved significantly since its creation, adopting features from other languages and innovating independently. Modern C# (10+) includes records for immutable types, nullable reference types for null-safety, pattern matching for elegant code flow, and async/await for asynchronous programming.</p><p><strong>Records</strong> provide concise syntax for immutable data types with structural equality, ideal for domain models and data transfer objects.</p><p><strong>Nullable Reference Types</strong> make null-safety explicit at compile time, preventing the infamous &ldquo;billion-dollar mistake&rdquo; of null reference exceptions.</p><p><strong>Pattern Matching</strong> enables elegant code for type checking, null checking, and property matching without verbose if-else chains.</p><p><strong>Async/Await</strong> abstracts the complexity of asynchronous programming, enabling responsive applications without callback hell.</p><h2 id="practical-c-development"><a href="/tags/csharp/#practical-c-development" title="Practical C# Development">Practical C# Development</a></h2><p>Articles in this section cover language features, effective C# patterns, performance optimization, LINQ mastery, and integration with .NET libraries. Topics include null handling strategies, immutability patterns, error handling approaches, and leveraging type system features.</p><p>The goal is writing C# code that&rsquo;s not just correct but also expressive, maintainable, and performant—code that communicates intent clearly and resists bugs through type safety and language features.</p></section><section class="card"><figure class="square"><picture><source srcset="/images/csharp-80x80.webp?v=dde339133eaa56ccd6589bc15a46fbc6" type="image/webp"><source srcset="/images/csharp-80x80.png?v=c5d685b0d4fa9ec69bd959ee04beb903" type="image/png"><img src="/images/csharp.png?v=21ff9dcf5d1da7bfa80141c972c117da" alt="Gradually Introducing Nullability in Legacy Code: A Practical Guide for .NET and C#" loading="lazy" decoding="async" title="Gradually Introducing Nullability in Legacy Code: A Practical Guide for .NET and C#"></picture></figure><header><h2>Gradually Introducing Nullability in Legacy Code: A Practical Guide for .NET and C#</h2></header><section class="content" role="region"><p>As developers, we’re often tasked with maintaining and modernizing legacy codebases that were written long before some of the best practices of today—such as nullability annotations—were available. While modern C# now supports nullable reference types, enabling us to avoid the dreaded <code>NullReferenceException</code>, introducing this feature to existing, large codebases can be a challenge.</p><p>In this article, I’ll share my step-by-step approach for introducing nullability into a legacy .NET and C# project. You’ll learn how to apply nullability in a controlled, incremental manner using project-level settings, scoped annotations, and file/method-level directives, all while maintaining the integrity of your legacy codebase. After all, modernizing your code doesn’t have to be an all-or-nothing endeavor—gradual change is key to a successful transition. Let’s get started!</p></section><a class="link" href="/posts/introducing-nullability-in-legacy-code/" rel="tag" title="Gradually Introducing Nullability in Legacy Code: A Practical Guide for .NET and C#"></a></section><section class="card"><figure class="square"><picture><source srcset="/images/csharp-80x80.webp?v=dde339133eaa56ccd6589bc15a46fbc6" type="image/webp"><source srcset="/images/csharp-80x80.png?v=c5d685b0d4fa9ec69bd959ee04beb903" type="image/png"><img src="/images/csharp.png?v=21ff9dcf5d1da7bfa80141c972c117da" alt="Mastering .NET Project Properties: The `BuildingInsideVisualStudio` Flag" loading="lazy" decoding="async" title="Mastering .NET Project Properties: The `BuildingInsideVisualStudio` Flag"></picture></figure><header><h2>Mastering .NET Project Properties: The `BuildingInsideVisualStudio` Flag</h2></header><section class="content" role="region"><p>In the ever-evolving world of .NET development, managing project configurations effectively is crucial for maintaining a clean and efficient build process. One of the less frequently discussed but highly useful properties is <code>BuildingInsideVisualStudio</code>. This property, when correctly utilized, can streamline your build process and ensure that your project is configured properly depending on the build environment. In this article, we&rsquo;ll explore the <code>BuildingInsideVisualStudio</code> property with concrete examples and discuss best practices for using it effectively.</p></section><a class="link" href="/posts/buildinginsidevisualstudio/" rel="tag" title="Mastering .NET Project Properties: The `BuildingInsideVisualStudio` Flag"></a></section><section class="card"><figure class="square"><picture><source srcset="/images/package-manager-80x80.webp?v=e3dd7029dd839b6d7ab6d8b2f7b28401" type="image/webp"><source srcset="/images/package-manager-80x80.png?v=e2d9bba485820dc0336d1253eb4dd7a1" type="image/png"><img src="/images/package-manager.png?v=19ac8eda9b0cc3394a0da24151d44079" alt="Manage NuGet Packages Centrally" loading="lazy" decoding="async" title="Manage NuGet Packages Centrally"></picture></figure><header><h2>Manage NuGet Packages Centrally</h2></header><section class="content" role="region"><p>For over 12 years, NuGet package management has been part of the .NET ecosystem with direct integrations to various IDEs, CLIs and build systems. But a feature took 12 years before it appeared and certainly needs some more maintenance until it is mature!</p></section><a class="link" href="/posts/manage-nuget-packages-centrally/" rel="tag" title="Manage NuGet Packages Centrally"></a></section></main><nav class="pagination" aria-label="Pagination"><a class="item" href="/tags/csharp/page/3/" hreflang="en" title="C# Programming Language Articles &mdash; Daily DevOps & .NET &mdash; Page 3" rel="next"><i class="fas fa-backward" aria-hidden="true"></i></a>
<span class="current item" aria-current="page">4&nbsp;/&nbsp;4</span>
<a class="item" rel="prev" disabled><i class="fas fa-forward" aria-hidden="true"></i></a></nav></main><footer class="footer"><div class="divider"></div><nav><ul class="navigation"><li><a href="/tags/">Tags</a></li><li><a href="/legal-notice/">Legal notice</a></li></ul></nav><div class="copyright">&copy; 2023 - 2026 Daily DevOps & .NET</div></footer><script defer src="/js/below.min.a6ce9164454b6077f17ae856f280442d9f3a1e21f06189f71c21f75144b22a0c8cf32bafd61d440e9d90ca02bf738b6a8ef19f5ec20285d8ca574f98c91ebaf2.js" integrity="sha512-ps6RZEVLYHfxeuhW8oBELZ86HiHwYYn3HCH3UUSyKgyM8yuv1h1EDp2QygK/c4tqjvGfXsIChdjKV0+YyR668g==" crossorigin="anonymous"></script></body></html>