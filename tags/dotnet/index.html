<!doctype html><html class="no-js" lang="en" dir="ltr"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="theme-color" content="#15a"><title>.NET Development and Framework â€” Daily DevOps & .NET</title><meta name="description" content="Comprehensive .NET coverage including C#, ASP.NET Core, performance optimization, latest framework features, updates, and development best practices."><meta name="twitter:description" property="og:description" content="Comprehensive .NET coverage including C#, ASP.NET Core, performance optimization, latest framework features, updates, and development best practices."><meta name="author" content="Daily DevOps"><link rel="icon" href="/logo.svg?v=b9e294dc5c6fa04439c8c803d8e981a9" sizes="any" type="image/svg+xml"><meta name="twitter:title" property="og:title" content=".NET Development and Framework â€” Daily DevOps & .NET"><meta property="og:updated_time" content="2026-01-05T12:05:23+01:00"><meta property="article:modified_time" content="2026-01-05T12:05:23+01:00"><meta property="article:published_time" content="0001-01-01T00:00:00+00:00"><meta property="og:type" content="website"><meta property="og:site_name" content="Daily DevOps & .NET"><meta property="og:url" content="https://daily-devops.net/tags/dotnet/"><meta property="og:locale" content="en"><meta name="twitter:card" content="summary_large_image"><meta property="og:image" name="twitter:image" content="https://daily-devops.net/images/dotnet-1200x630.webp?v=702d3f257b5257bcbf784656664907a5"><meta property="og:image:secure_url" content="https://daily-devops.net/images/dotnet-1200x630.webp?v=702d3f257b5257bcbf784656664907a5"><meta property="og:image:alt" name="twitter:image:alt" content=".NET Development and Framework"><meta property="og:image:type" content="image/webp"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta property="og:image" name="twitter:image" content="https://daily-devops.net/images/dotnet-1200x630.png?v=f24aeee339dcfec95b7e986627b47e80"><meta property="og:image:secure_url" content="https://daily-devops.net/images/dotnet-1200x630.png?v=f24aeee339dcfec95b7e986627b47e80"><meta property="og:image:alt" name="twitter:image:alt" content=".NET Development and Framework"><meta property="og:image:type" content="image/png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><link rel="dns-prefetch" href="https://www.clarity.ms"><link rel="preconnect" href="https://www.clarity.ms" crossorigin><link rel="stylesheet" href="/css/style.min.0b2ef4378cd908eb695017aaa74603d244ff2b38c8068b4b51d76cad830c8ee5e3a40b67ab5b860a542c8bae73d8ba90cfbe9249b59c733a50de74cc32af818a.css" integrity="sha512-Cy70N4zZCOtpUBeqp0YD0kT/KzjIBotLUddsrYMMjuXjpAtnq1uGClQsi65z2LqQz76SSbWcczpQ3nTMMq+Big==" crossorigin="anonymous"><link rel="alternate" href='https://daily-devops.net/tags/dotnet/' hreflang="x-default" title=".NET Development and Framework &mdash; Daily DevOps & .NET"><link rel="alternate" href="https://daily-devops.net/en/tags/dotnet" hreflang="en" title=".NET Development and Framework &mdash; Daily DevOps & .NET"><link rel="canonical" href="https://daily-devops.net/tags/dotnet/" hreflang="en" title=".NET Development and Framework &mdash; Daily DevOps & .NET"><link rel="home" href="https://daily-devops.net/" hreflang="en" title="Daily DevOps & .NET"><script defer src="/js/above.min.cb42b2c9a453e49e278326637d72d2f01e7f32e3f91e9cdde8fb587793d05514efd2f5cc5021c9658ca0f73876dbdcd1f7cb4a37c0bebc9df01110926b6d7cba.js" integrity="sha512-y0KyyaRT5J4ngyZjfXLS8B5/MuP5Hpzd6PtYd5PQVRTv0vXMUCHJZYyg9zh229zR98tKN8C+vJ3wERCSa218ug==" crossorigin="anonymous"></script><script type="text/javascript">(function(e,t,n,s,o,i,a){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)},i=t.createElement(s),i.async=1,i.src="https://www.clarity.ms/tag/"+o,a=t.getElementsByTagName(s)[0],a.parentNode.insertBefore(i,a)})(window,document,"clarity","script","o0pr4n9gg3")</script><script src="https://analytics.ahrefs.com/analytics.js" data-key="C5Iv+2Rb9el+FLJqVw2QGA" async></script></head><body class="container"><header class="header"><a class="logo" href="/" title="Daily DevOps & .NET" rel="home"><figure class="page-logo"><picture><img src="/logo.svg?v=b9e294dc5c6fa04439c8c803d8e981a9" alt="Daily DevOps & .NET" title="Daily DevOps & .NET"></picture></figure><span class="title">Daily DevOps & .NET</span></a><nav class="menu" aria-label="Main navigation"><button class="burger" type="button" aria-haspopup="menu" aria-expanded="false" aria-label="Toggle menu">
<i class="fas fa-burger" aria-hidden="true"></i></button><ul class="navigation"><li><a href="/posts/">Posts</a></li><li><a href="/authors/">About us</a></li></ul></nav><div class="divider"></div></header><main class="body"><main class="board" role="main"><header><h1>.NET Development and Framework</h1></header><section class="content" role="region"><p>.NET is Microsoft&rsquo;s open-source, cross-platform development framework for building modern applications. From web APIs and cloud services to desktop and mobile apps, .NET provides a comprehensive ecosystem for software development across platforms and deployment targets.</p><h2 id="net-platform-evolution"><a href="/tags/dotnet/#net-platform-evolution" title=".NET Platform Evolution">.NET Platform Evolution</a></h2><p><strong>.NET 6+</strong> unified the framework, bringing together .NET Core, .NET Framework, Xamarin, and Mono into a single platform with consistent APIs, performance improvements, and long-term support releases. Modern .NET emphasizes cross-platform compatibility, cloud-native architecture, and high-performance runtime characteristics.</p><p><strong>ASP.NET Core</strong> powers web applications and APIs with minimal APIs, Blazor for interactive web UIs, SignalR for real-time communication, and gRPC for high-performance service communication.</p><p><strong>Performance and Productivity</strong> drive .NET evolution. Each release brings runtime improvements, compiler optimizations, and language features that reduce boilerplate while maintaining type safety and performance.</p><h2 id="net-ecosystem"><a href="/tags/dotnet/#net-ecosystem" title=".NET Ecosystem">.NET Ecosystem</a></h2><p>Articles in this section explore .NET runtime features, framework updates, ASP.NET Core patterns, performance optimization, deployment strategies, and integration with cloud platforms. Topics include new language features, framework capabilities, migration paths, and best practices for .NET development.</p><p>The focus is practical .NET development: leveraging framework capabilities effectively, staying current with platform evolution, and building maintainable applications that scale.</p></section><section class="card"><figure class="square"><picture><source srcset="/images/security-80x80.webp?v=35f82cde59317b992b40db6eee90c415" type="image/webp"><source srcset="/images/security-80x80.png?v=6b7b9203a90fa2d6df665509ee32b1e2" type="image/png"><img src="/images/security.png?v=530c4f0b5995d08df3450423fd03c5e0" alt="Your appsettings.json Is a Compliance Violation" loading="lazy" decoding="async" title="Your appsettings.json Is a Compliance Violation"></picture></figure><header><h2>Your appsettings.json Is a Compliance Violation</h2></header><section class="content" role="region">Hardcoded secrets aren&rsquo;t just bad practiceâ€”they&rsquo;re ISO 27017 violations with real consequences: failed audits, denied insurance claims, contractual penalties. That connection string in your appsettings.Production.json? It represents a compliance gap your organization probably doesn&rsquo;t even know exists. Azure Key Vault with Managed Identity isn&rsquo;t an optional security enhancementâ€”it&rsquo;s the minimum viable implementation of standards you already claim to follow.</section><a class="link" href="/posts/secrets-management-azure-keyvault/" rel="tag" title="Your appsettings.json Is a Compliance Violation"></a></section><section class="card"><figure class="square"><picture><source srcset="/images/observability-80x80.webp?v=e029eb3d74e4d67f04990ad14af8ed68" type="image/webp"><source srcset="/images/observability-80x80.png?v=53f54ab518d5253040a9c4eff2a6b8ff" type="image/png"><img src="/images/observability.png?v=48acbd668436dc9dd3287b4ec5564639" alt="Audit Logging That Survives Your Next Security Incident" loading="lazy" decoding="async" title="Audit Logging That Survives Your Next Security Incident"></picture></figure><header><h2>Audit Logging That Survives Your Next Security Incident</h2></header><section class="content" role="region">Your audit logs probably won&rsquo;t survive a real security incident. Most implementations log too much, protect too little, and provide zero value when something breaks at 2 AM. Here&rsquo;s how to fix that with structured logging that actually works.</section><a class="link" href="/posts/audit-logging-azure-app-insights/" rel="tag" title="Audit Logging That Survives Your Next Security Incident"></a></section><section class="card"><figure class="square"><picture><source srcset="/images/security-80x80.webp?v=35f82cde59317b992b40db6eee90c415" type="image/webp"><source srcset="/images/security-80x80.png?v=6b7b9203a90fa2d6df665509ee32b1e2" type="image/png"><img src="/images/security.png?v=530c4f0b5995d08df3450423fd03c5e0" alt="Your [Authorize] Attribute Is Compliance Theater
" loading="lazy" decoding="async" title="Your [Authorize] Attribute Is Compliance Theater
"></picture></figure><header><h2>Your [Authorize] Attribute Is Compliance Theater</h2></header><section class="content" role="region"><p><strong>Your <code>[Authorize]</code> attributes give you a false sense of security. ISO 27001 auditors see right through it.</strong></p><p>I&rsquo;ve reviewed dozens of ASP.NET Core apps that authenticate flawlessly â€” then scatter role strings across business logic, skip audit logs, and wonder why they fail compliance. Here&rsquo;s the pattern that kills audits, and how to actually fix it.</p></section><a class="link" href="/posts/access-control-aspnet-core/" rel="tag" title="Your [Authorize] Attribute Is Compliance Theater
"></a></section><section class="card"><figure class="square"><picture><source srcset="/images/security-80x80.webp?v=35f82cde59317b992b40db6eee90c415" type="image/webp"><source srcset="/images/security-80x80.png?v=6b7b9203a90fa2d6df665509ee32b1e2" type="image/png"><img src="/images/security.png?v=530c4f0b5995d08df3450423fd03c5e0" alt="Why ISO Standards Actually Matter for .NET Developers" loading="lazy" decoding="async" title="Why ISO Standards Actually Matter for .NET Developers"></picture></figure><header><h2>Why ISO Standards Actually Matter for .NET Developers</h2></header><section class="content" role="region">Cloud-native .NET development has transformed ISO/IEC 27001, 27017, and 27701 from abstract compliance requirements into concrete daily coding decisions. This guide shows .NET developers how security standards directly map to Azure Key Vault integration, Azure AD authentication, and proper loggingâ€”with real code examples demonstrating compliant vs. non-compliant implementations.</section><a class="link" href="/posts/iso-standards-intro-dotnet-developers/" rel="tag" title="Why ISO Standards Actually Matter for .NET Developers"></a></section><section class="card"><figure class="square"><picture><source srcset="/images/code-sharpens-thinking-80x80.webp?v=2448ccbe45295198cef354e0bb551a5a" type="image/webp"><source srcset="/images/code-sharpens-thinking-80x80.png?v=a151d2d240b300c6db90670c63c640fa" type="image/png"><img src="/images/code-sharpens-thinking.png?v=9022f5abe33b87869328198596f2ad25" alt="Real Professional Software Engineering in the AI Era
" loading="lazy" decoding="async" title="Real Professional Software Engineering in the AI Era
"></picture></figure><header><h2>Real Professional Software Engineering in the AI Era</h2></header><section class="content" role="region">Throughout this series, we&rsquo;ve established that AI-generated code without understanding creates productivity illusions that collapse in production (Part 1), and that <strong>the feedback loop</strong> between code and realityâ€”compilation, testing, profiling, productionâ€”sharpens thinking in ways AI can&rsquo;t replicate (Part 2). Now we confront the practical question: What defines professional software engineering when code generation becomes trivial? This final part examines the irreplaceable skillset: understanding execution characteristics (recognizing allocation patterns that cause GC pressure before deployment), asking questions AI can&rsquo;t formulate (What&rsquo;s the failure mode when this service is unavailable?), recognizing when plausible AI solutions diverge from correct ones, debugging production failures AI has no execution model to reason about, and evaluating maintainability for code that becomes tomorrow&rsquo;s burden. We explore why prompt engineering optimizes for speed while architecture optimizes for survival, why &ldquo;AI productivity&rdquo; often means faster technical debt accumulation, and why the economic reality favors organizations that measure system reliability over lines of code generated. The feedback loop can&rsquo;t be automated because closing it requires learning from production failures and applying that knowledge to prevent future onesâ€”the irreplaceable discipline that defines real professionals in 2026 and beyond.</section><a class="link" href="/posts/real-professional-software-engineering-ai-era/" rel="tag" title="Real Professional Software Engineering in the AI Era
"></a></section><section class="card"><figure class="square"><picture><source srcset="/images/code-sharpens-thinking-80x80.webp?v=2448ccbe45295198cef354e0bb551a5a" type="image/webp"><source srcset="/images/code-sharpens-thinking-80x80.png?v=a151d2d240b300c6db90670c63c640fa" type="image/png"><img src="/images/code-sharpens-thinking.png?v=9022f5abe33b87869328198596f2ad25" alt="The Feedback Loop That AI Can't Replace
" loading="lazy" decoding="async" title="The Feedback Loop That AI Can't Replace
"></picture></figure><header><h2>The Feedback Loop That AI Can't Replace</h2></header><section class="content" role="region">In the first part of this series, we established that AI-generated code without understanding creates an illusion of productivity that collapses under production load. The differentiator isn&rsquo;t typing speedâ€”it&rsquo;s <strong>the feedback loop</strong> where code meets reality and exposes incomplete thinking. But what exactly is this feedback loop, and why can&rsquo;t AI replicate it? Modern compilers validate logical consistency, catching gaps pure thought leaves unresolved. Profilers expose the 75x performance difference between &ldquo;seems reasonable&rdquo; and &ldquo;actually performs.&rdquo; Production environments reveal every assumption abstract thinking deferredâ€”scale, concurrency, failure modes. This article explores the mechanisms that transform vague reasoning into concrete understanding: compilation validates logic instantly, testing catches behavioral mismatches, profiling measures what abstract analysis guesses, and production exposes the cost of every deferred decision. Real professionals don&rsquo;t just write codeâ€”they master the iterative discipline of watching it fail, understanding why, and refining their thinking. AI participates in parts of this loop, but it can&rsquo;t close it. That&rsquo;s where professionals remain irreplaceable.</section><a class="link" href="/posts/feedback-loop-ai-cant-replace/" rel="tag" title="The Feedback Loop That AI Can't Replace
"></a></section><section class="card"><figure class="square"><picture><source srcset="/images/kubernetes-dotnet-80x80.webp?v=0450f030e95aa39f420ab5574d631a3a" type="image/webp"><source srcset="/images/kubernetes-dotnet-80x80.png?v=ba43b03f30af199c2cc897219ea304a3" type="image/png"><img src="/images/kubernetes-dotnet.png?v=b153621c9ec4d670255b761ea2954ae8" alt="Kubernetes Is Not a Platform Strategy
" loading="lazy" decoding="async" title="Kubernetes Is Not a Platform Strategy
"></picture></figure><header><h2>Kubernetes Is Not a Platform Strategy</h2></header><section class="content" role="region">Kubernetes has become an assumed default in many organizations, positioned as a universal platform that absorbs governance, security, observability, and operational responsibility. This narrative is incomplete. Kubernetes is a powerful runtime orchestrator that solves one phase of the software lifecycle. Architectural risk, cost decisions, and operational failure occur elsewhere. A critical examination of where Kubernetes&rsquo;s responsibility ends, and what remains the architect&rsquo;s job.</section><a class="link" href="/posts/kubernetes-not-platform-strategy/" rel="tag" title="Kubernetes Is Not a Platform Strategy
"></a></section><section class="card"><figure class="square"><picture><source srcset="/images/alphabet-soup-80x80.webp?v=51d8152fa240e21cf474169262680a58" type="image/webp"><source srcset="/images/alphabet-soup-80x80.png?v=5a407fbaa92f53ddec89eed051039476" type="image/png"><img src="/images/alphabet-soup.png?v=5e2437740d1d58b05fdcd89b395a4261" alt="Alphabet Soup: The Format Buffet Nobody Ordered
" loading="lazy" decoding="async" title="Alphabet Soup: The Format Buffet Nobody Ordered
"></picture></figure><header><h2>Format Buffet Nobody Ordered</h2></header><section class="content" role="region">Developers wanted one format. We got twenty. CSV mangles data, XML drowns in tags, JSON forbids comments, YAML punishes spaces. TOML tried fixing it. TAML went minimal. TOON optimized for AI. CCL brought category theory. Result? Five formats per project, three parsers, and debugging why <code>NO</code> became <code>false</code>. AI can&rsquo;t save us either. Welcome to format hell.</section><a class="link" href="/posts/alphabet-soup-file-formats/" rel="tag" title="Format Buffet Nobody Ordered"></a></section><section class="card"><figure class="square"><picture><source srcset="/images/code-sharpens-thinking-80x80.webp?v=2448ccbe45295198cef354e0bb551a5a" type="image/webp"><source srcset="/images/code-sharpens-thinking-80x80.png?v=a151d2d240b300c6db90670c63c640fa" type="image/png"><img src="/images/code-sharpens-thinking.png?v=9022f5abe33b87869328198596f2ad25" alt="Why Real Professionals Will Never Be Replaced by AI
" loading="lazy" decoding="async" title="Why Real Professionals Will Never Be Replaced by AI
"></picture></figure><header><h2>Why Real Professionals Will Never Be Replaced by AI</h2></header><section class="content" role="region">The elephant everyone ignores: AI can generate code faster than you can type. GitHub Copilot autocompletes entire functions. ChatGPT builds APIs from prompts. Typing is dead. So why will real professionals never be replaced? Because <strong>&ldquo;vibe coding&rdquo;</strong>â€”describe what you want, ship what AI generatesâ€”is a productivity illusion that collapses spectacularly in production. When code generation becomes trivial, understanding what that code costs, where it fails, why it breaks under load becomes everything. AI generates syntax. Professionals understand execution, failure modes, operational cost, and production consequences. The differentiator isn&rsquo;t typing speedâ€”it&rsquo;s mastering <strong>the feedback loop</strong>: write code, watch it fail, understand why, refine thinking. This discipline can&rsquo;t be automated. Prompt engineers generate code. Real professionals ensure it survives contact with reality.</section><a class="link" href="/posts/code-sharpens-thinking/" rel="tag" title="Why Real Professionals Will Never Be Replaced by AI
"></a></section><section class="card"><figure class="square"><picture><source srcset="/images/new-year-2026-80x80.webp?v=2476759f22a4755d050a56a7b018a8b6" type="image/webp"><source srcset="/images/new-year-2026-80x80.png?v=db4e671d343ad5dd738fcd14fe372dbb" type="image/png"><img src="/images/new-year-2026.png?v=22310b8a2e5efdb6edc4fbefed808306" alt="Most Software Teams Are Lying to Themselvesâ€”2026 Needs to Be Different" loading="lazy" decoding="async" title="Most Software Teams Are Lying to Themselvesâ€”2026 Needs to Be Different"></picture></figure><header><h2>Most Software Teams Are Lying to Themselvesâ€”2026 Needs to Be Different</h2></header><section class="content" role="region"><p><em><strong>Happy New Year 2026! ðŸŽ‰</strong></em></p><p>Fix one piece of technical debt this weekâ€”not next quarter.
.NET 10, analyzers, and tests are ready; discipline is the only missing part.</p></section><a class="link" href="/posts/happy-new-year-2026/" rel="tag" title="Most Software Teams Are Lying to Themselvesâ€”2026 Needs to Be Different"></a></section><section class="card"><figure class="square"><picture><source srcset="/images/review-2025-80x80.webp?v=945e1fce6ce1f264488a6f95b6262107" type="image/webp"><source srcset="/images/review-2025-80x80.png?v=9795ee729ecaeab4a5b0dd949192cd72" type="image/png"><img src="/images/review-2025.png?v=2cd18cbff5eeb978a3df449bf107e5c2" alt="2025 in Review: The Year .NET Stopped Lying to Itself" loading="lazy" decoding="async" title="2025 in Review: The Year .NET Stopped Lying to Itself"></picture></figure><header><h2>2025 in Review: The Year .NET Stopped Lying to Itself</h2></header><section class="content" role="region">Forget the hypeâ€”2025 was when .NET tooling finally stopped pretending complexity doesn&rsquo;t exist
Three tools won by being honest: Aspire exposed topology, TUnit killed flaky tests, Testcontainers made infrastructure real</section><a class="link" href="/posts/dotnet-2025-year-in-review/" rel="tag" title="2025 in Review: The Year .NET Stopped Lying to Itself"></a></section><section class="card"><figure class="square"><picture><source srcset="/images/cli-80x80.webp?v=c759da156fe7970f4c3d03c3fa04644b" type="image/webp"><source srcset="/images/cli-80x80.png?v=f6a47c2f53449fab29fe424492397326" type="image/png"><img src="/images/cli.png?v=74daed50d0ea188d53fcad80f79e87ba" alt=".NET CLI 10 â€“ Microsoft Finally Realizes DevOps Exists" loading="lazy" decoding="async" title=".NET CLI 10 â€“ Microsoft Finally Realizes DevOps Exists"></picture></figure><header><h2>.NET CLI 10 â€“ Microsoft Finally Realizes DevOps Exists</h2></header><section class="content" role="region"><p>The .NET CLI? Reliable. Boring. You run <code>dotnet build</code>, <code>dotnet test</code>, <code>dotnet publish</code>, done. Real DevOps work happens in Dockerfiles, CI/CD configs, and specialized tools. The CLI does its job but was never built for actual operational workflows.</p><p>.NET 10 changes this. Four additions that sound minor but fix real problems I&rsquo;ve hit in production pipelines for years: native container publishing, ephemeral tool execution, better cross-platform packaging, and machine-readable schemas. Not flashy. Not keynote material. But they&rsquo;re the kind of improvements that save hours every week once you&rsquo;re running them at scale.</p><p>Will they replace your current workflow? Depends on what you&rsquo;re building. Let&rsquo;s look at what actually changed.</p></section><a class="link" href="/posts/dotnet-10-cli-devops/" rel="tag" title=".NET CLI 10 â€“ Microsoft Finally Realizes DevOps Exists"></a></section></main><nav class="pagination" aria-label="Pagination"><a class="item" rel="next" disabled><i class="fas fa-backward" aria-hidden="true"></i></a>
<span class="current item" aria-current="page">1&nbsp;/&nbsp;5</span>
<a class="item" href="/tags/dotnet/page/2/" hreflang="en" title=".NET Development and Framework &mdash; Daily DevOps & .NET &mdash; Page 2" rel="prev"><i class="fas fa-forward" aria-hidden="true"></i></a></nav></main><footer class="footer"><div class="divider"></div><nav><ul class="navigation"><li><a href="/tags/">Tags</a></li><li><a href="/legal-notice/">Legal notice</a></li></ul></nav><div class="copyright">&copy; 2023 - 2026 Daily DevOps & .NET</div></footer><script defer src="/js/below.min.a6ce9164454b6077f17ae856f280442d9f3a1e21f06189f71c21f75144b22a0c8cf32bafd61d440e9d90ca02bf738b6a8ef19f5ec20285d8ca574f98c91ebaf2.js" integrity="sha512-ps6RZEVLYHfxeuhW8oBELZ86HiHwYYn3HCH3UUSyKgyM8yuv1h1EDp2QygK/c4tqjvGfXsIChdjKV0+YyR668g==" crossorigin="anonymous"></script></body></html>