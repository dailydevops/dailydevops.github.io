<!doctype html><html class="no-js" lang="en" dir="ltr"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="theme-color" content="#15a"><title>.NET — Daily DevOps & .NET</title><meta name="description" content="All about .NET"><meta name="twitter:description" property="og:description" content="All about .NET"><meta name="author" content="Daily DevOps"><link rel="icon" href="/logo.svg?v=b9e294dc5c6fa04439c8c803d8e981a9" sizes="any" type="image/svg+xml"><meta name="twitter:title" property="og:title" content=".NET — Daily DevOps & .NET"><meta property="og:updated_time" content="2024-12-31T09:35:40+01:00"><meta property="article:modified_time" content="2024-12-31T09:35:40+01:00"><meta property="article:published_time" content="0001-01-01T00:00:00+00:00"><meta property="og:type" content="website"><meta property="og:site_name" content="Daily DevOps & .NET"><meta property="og:url" content="https://daily-devops.net/tags/dotnet/"><meta property="og:locale" content="en_US"><meta name="twitter:card" content="summary_large_image"><meta property="og:image" name="twitter:image" content="https://daily-devops.net/images/dotnet-1200x630.webp?v=cbb7eb6fbeb91103cd1a09f828e0e20f"><meta property="og:image:secure_url" content="https://daily-devops.net/images/dotnet-1200x630.webp?v=cbb7eb6fbeb91103cd1a09f828e0e20f"><meta property="og:image:alt" name="twitter:image:alt" content=".NET"><meta property="og:image:type" content="image/webp"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta property="og:image" name="twitter:image" content="https://daily-devops.net/images/dotnet-1200x630.png?v=f24aeee339dcfec95b7e986627b47e80"><meta property="og:image:secure_url" content="https://daily-devops.net/images/dotnet-1200x630.png?v=f24aeee339dcfec95b7e986627b47e80"><meta property="og:image:alt" name="twitter:image:alt" content=".NET"><meta property="og:image:type" content="image/png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><link rel="dns-prefetch" href="https://www.clarity.ms"><link rel="preconnect" href="https://www.clarity.ms" crossorigin><link rel="stylesheet" href="/css/style.min.bd3384c8856830ca9acea97c7aaad6cea2adc40b13c05131543af7ba35a9ef54e279811d27ca92f7acd5086f2e54461b78445d6fa3e9b151f91613876066f037.css" integrity="sha512-vTOEyIVoMMqazql8eqrWzqKtxAsTwFExVDr3ujWp71TieYEdJ8qS96zVCG8uVEYbeERdb6PpsVH5FhOHYGbwNw==" crossorigin="anonymous"><link rel="alternate" href='https://daily-devops.net/tags/dotnet/' hreflang="x-default" title=".NET &mdash; Daily DevOps & .NET"><link rel="alternate" href="https://daily-devops.net/en/tags/dotnet/" hreflang="en-us" title=".NET &mdash; Daily DevOps & .NET"><link rel="alternate" href="https://daily-devops.net/de/tags/dotnet/" hreflang="en-us" title=".NET &mdash; Daily DevOps & .NET"><link rel="canonical" href="https://daily-devops.net/tags/dotnet/" hreflang="en-us" title=".NET &mdash; Daily DevOps & .NET"><link rel="home" href="https://daily-devops.net/" hreflang="en-us" title="Daily DevOps & .NET"><script defer src="/js/above.min.cb42b2c9a453e49e278326637d72d2f01e7f32e3f91e9cdde8fb587793d05514efd2f5cc5021c9658ca0f73876dbdcd1f7cb4a37c0bebc9df01110926b6d7cba.js" integrity="sha512-y0KyyaRT5J4ngyZjfXLS8B5/MuP5Hpzd6PtYd5PQVRTv0vXMUCHJZYyg9zh229zR98tKN8C+vJ3wERCSa218ug==" crossorigin="anonymous"></script><script type="text/javascript">(function(e,t,n,s,o,i,a){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)},i=t.createElement(s),i.async=1,i.src="https://www.clarity.ms/tag/"+o,a=t.getElementsByTagName(s)[0],a.parentNode.insertBefore(i,a)})(window,document,"clarity","script","o0pr4n9gg3")</script></head><body class="container"><header class="header"><a class="logo" href="/" title="Daily DevOps & .NET" rel="home"><figure class="page-logo"><picture><img src="/logo.svg?v=b9e294dc5c6fa04439c8c803d8e981a9" alt="Daily DevOps & .NET" title="Daily DevOps & .NET"></picture></figure><span class="title">Daily DevOps & .NET</span></a><nav class="menu"><button class="burger" aria-haspopup="true" aria-expanded="false" tabindex="0">
<i class="fas fa-burger"></i></button><ul class="navigation"><li><a href="/posts/">Posts</a></li><li><a href="/authors/">About us</a></li></ul></nav><div class="divider"></div></header><main class="body"><main class="board" role="main"><header><h1>.NET</h1></header><section class="card"><figure class="square"><picture><source srcset="/images/dotnet-80x80.webp?v=362353a62d867b7e3a0f33ec80e2eebf" type="image/webp"><source srcset="/images/dotnet-80x80.png?v=98376a285f07b0021d3118e0523d147a" type="image/png"><img src="/images/dotnet.png?v=8142ec8a038ba14415ff0d0434c78182" alt="ConstantExpectedAttribute: Unlocking Performance Through Compiler Awareness" loading="lazy" decoding="async" title="ConstantExpectedAttribute: Unlocking Performance Through Compiler Awareness"></picture></figure><header><h2>ConstantExpectedAttribute: Unlocking Performance Through Compiler Awareness</h2></header><section class="content">The ConstantExpectedAttribute, introduced in .NET 7, provides a powerful mechanism to signal compiler expectations about constant values. This enables better performance optimizations, enhanced IDE tooling, and clearer API contracts. Learn how to leverage this attribute to build more efficient and maintainable .NET applications.</section><a class="link" href="/posts/constant-expected-attribute/" rel="tag" title="ConstantExpectedAttribute: Unlocking Performance Through Compiler Awareness"></a></section><section class="card"><figure class="square"><picture><source srcset="/images/dotnet-legacy-80x80.webp?v=77bba5bb40284e7e8e55fce3e073a198" type="image/webp"><source srcset="/images/dotnet-legacy-80x80.png?v=02f6f9e0fee8bb64b36e167f428e0b3a" type="image/png"><img src="/images/dotnet-legacy.png?v=7bd80b7a1578771ea0e9fe9cfde2f5b1" alt="Retiring Legacy .NET Projects — Balancing Risk, Cost, and Forward Value
" loading="lazy" decoding="async" title="Retiring Legacy .NET Projects — Balancing Risk, Cost, and Forward Value
"></picture></figure><header><h2>Retiring Legacy .NET Projects — Balancing Risk, Cost, and Forward Value</h2></header><section class="content"><p>In every mature .NET landscape, legacy projects represent both heritage and hazard.
They once powered entire business models — now they silently consume time, budget, and attention.
The decision to retire or modernize them isn’t about technology fashion. It’s about sustaining the organization’s <strong>capacity for value creation</strong>.</p></section><a class="link" href="/posts/retiring-legacy-dotnet-projects/" rel="tag" title="Retiring Legacy .NET Projects — Balancing Risk, Cost, and Forward Value
"></a></section><section class="card"><figure class="square"><picture><source srcset="/images/dotnet-80x80.webp?v=362353a62d867b7e3a0f33ec80e2eebf" type="image/webp"><source srcset="/images/dotnet-80x80.png?v=98376a285f07b0021d3118e0523d147a" type="image/png"><img src="/images/dotnet.png?v=8142ec8a038ba14415ff0d0434c78182" alt="TUnit — A Pragmatic Evaluation for .NET Teams
" loading="lazy" decoding="async" title="TUnit — A Pragmatic Evaluation for .NET Teams
"></picture></figure><header><h2>TUnit — A Pragmatic Evaluation for .NET Teams</h2></header><section class="content">TUnit brings compile-time test discovery and native AOT support to .NET testing — but is it ready for enterprise adoption? A pragmatic analysis of performance gains, tooling maturity, and migration timing for teams evaluating alternatives to MSTest, xUnit, and NUnit.</section><a class="link" href="/posts/tunit-a-pragmatic-evaluation-for-dotnet-teams/" rel="tag" title="TUnit — A Pragmatic Evaluation for .NET Teams
"></a></section><section class="card"><figure class="square"><picture><source srcset="/images/csharp-80x80.webp?v=2009610da0e7ad52e611197cf3092830" type="image/webp"><source srcset="/images/csharp-80x80.png?v=c5d685b0d4fa9ec69bd959ee04beb903" type="image/png"><img src="/images/csharp.png?v=21ff9dcf5d1da7bfa80141c972c117da" alt="Still Waiting for the Final Piece: When C# 14 Comes Close, But Not Quite There
" loading="lazy" decoding="async" title="Still Waiting for the Final Piece: When C# 14 Comes Close, But Not Quite There
"></picture></figure><header><h2>Still Waiting for the Final Piece: When C# 14 Comes Close, But Not Quite There</h2></header><section class="content">C# 14 introduces the new &lsquo;Extension Everything&rsquo; syntax—an elegant step toward more expressive code, yet one that still can’t quite match VB.NET’s classic ByRef magic. A humorous reflection on what’s almost, but not fully, possible in .NET 10.</section><a class="link" href="/posts/still-waiting-for-the-final-piece/" rel="tag" title="Still Waiting for the Final Piece: When C# 14 Comes Close, But Not Quite There
"></a></section><section class="card"><figure class="square"><picture><source srcset="/images/dotnet-80x80.webp?v=362353a62d867b7e3a0f33ec80e2eebf" type="image/webp"><source srcset="/images/dotnet-80x80.png?v=98376a285f07b0021d3118e0523d147a" type="image/png"><img src="/images/dotnet.png?v=8142ec8a038ba14415ff0d0434c78182" alt="The Generous Gift? Microsoft Extends .NET STS Support to 24 Months" loading="lazy" decoding="async" title="The Generous Gift? Microsoft Extends .NET STS Support to 24 Months"></picture></figure><header><h2>The Generous Gift? Microsoft Extends .NET STS Support to 24 Months</h2></header><section class="content">Microsoft has extended .NET STS support from 18 to 24 months. A genuine gift to developers or just catching up with reality? Let&rsquo;s analyze what this means for your development planning.</section><a class="link" href="/posts/extended-dotnet-sts-support-timeframe/" rel="tag" title="The Generous Gift? Microsoft Extends .NET STS Support to 24 Months"></a></section><section class="card"><figure class="square"><picture><source srcset="/images/dotnet-80x80.webp?v=362353a62d867b7e3a0f33ec80e2eebf" type="image/webp"><source srcset="/images/dotnet-80x80.png?v=98376a285f07b0021d3118e0523d147a" type="image/png"><img src="/images/dotnet.png?v=8142ec8a038ba14415ff0d0434c78182" alt=".NET 10 RC 1 is Knocking at the Door: Architectural Impact, C# 14, and Performance" loading="lazy" decoding="async" title=".NET 10 RC 1 is Knocking at the Door: Architectural Impact, C# 14, and Performance"></picture></figure><header><h2>.NET 10 RC 1 is Knocking at the Door: Architectural Impact, C# 14, and Performance</h2></header><section class="content"><p>.NET 10 RC 1 is knocking at the door, marking the first release candidate and offering the .NET community a detailed preview of what’s to come in the next LTS cycle. While not the final release, RC 1 is “go-live” supported and represents the feature-complete platform that will soon become .NET 10 LTS. In this article, I’ll try to give a rough overview of the architectural impact of .NET 10 RC 1, focusing on the latest C# 14 features, under-the-hood performance improvements, and strategic considerations for the upcoming LTS.</p></section><a class="link" href="/posts/dotnet10rc1-is-knocking-at-the-door/" rel="tag" title=".NET 10 RC 1 is Knocking at the Door: Architectural Impact, C# 14, and Performance"></a></section><section class="card"><figure class="square"><picture><source srcset="/images/visual-studio-2026-80x80.webp?v=a6d2520795aa9b77b1d2d718c6144dfb" type="image/webp"><source srcset="/images/visual-studio-2026-80x80.png?v=7215a1adbe12d1d8f6d80d3691d0a310" type="image/png"><img src="/images/visual-studio-2026.png?v=5500010504ec02c46e793c2c9ac682aa" alt="Visual Studio 2026 - Why AI-Native Tooling Will Matter" loading="lazy" decoding="async" title="Visual Studio 2026 - Why AI-Native Tooling Will Matter"></picture></figure><header><h2>Visual Studio 2026 - Why AI-Native Tooling Will Matter</h2></header><section class="content"><p>Let’s skip the typical release-cycle enthusiasm for a second: Most IDE updates come and go. New features, some refactoring helpers, a bit of polish, then back to business as usual. <strong>Visual Studio 2026 is different.</strong> For once, the promise of “AI-native” isn’t just marketing. If Microsoft lands even half of what they’re previewing, it’s going to matter—a lot.</p></section><a class="link" href="/posts/visual-studio-2026/" rel="tag" title="Visual Studio 2026 - Why AI-Native Tooling Will Matter"></a></section><section class="card"><figure class="square"><picture><source srcset="/images/dotnet-80x80.webp?v=362353a62d867b7e3a0f33ec80e2eebf" type="image/webp"><source srcset="/images/dotnet-80x80.png?v=98376a285f07b0021d3118e0523d147a" type="image/png"><img src="/images/dotnet.png?v=8142ec8a038ba14415ff0d0434c78182" alt="Buzzword-Driven Development vs. Fundamental Software Quality" loading="lazy" decoding="async" title="Buzzword-Driven Development vs. Fundamental Software Quality"></picture></figure><header><h2>Buzzword-Driven Development vs. Fundamental Software Quality</h2></header><section class="content">Explore why fundamental software quality practices in .NET must never be overlooked for trendy buzzwords, including recommended analyzers and project settings for managing technical debt effectively.</section><a class="link" href="/posts/buzzword-driven-development/" rel="tag" title="Buzzword-Driven Development vs. Fundamental Software Quality"></a></section><section class="card"><figure class="square"><picture><source srcset="/posts/copilot-without-becoming-its-puppet/logo-80x80.webp?v=618e758108bc3f699f33fecb7c26fca6" type="image/webp"><source srcset="/posts/copilot-without-becoming-its-puppet/logo-80x80.png?v=268847a67d3678572b99a408a0d978b9" type="image/png"><img src="/posts/copilot-without-becoming-its-puppet/logo.png?v=7ee44a01c1e128d6d72b7a93ece42b4d" alt="How to Use Copilot Without Becoming Its Puppet" loading="lazy" decoding="async" title="How to Use Copilot Without Becoming Its Puppet"></picture></figure><header><h2>How to Use Copilot Without Becoming Its Puppet</h2></header><section class="content"><p>In a previous article, we laid it out – unfiltered: <strong>Copilot turns junior devs into syntax secretaries.</strong></p><p>Not because it’s evil. But because it <strong>removes friction before understanding</strong>.</p><p>It gives you working code before you know what <em>working</em> even means. It creates the illusion of progress, while slowly eroding the very skills that define a software engineer: reasoning, decision-making, and technical ownership.</p></section><a class="link" href="/posts/copilot-without-becoming-its-puppet/" rel="tag" title="How to Use Copilot Without Becoming Its Puppet"></a></section><section class="card"><figure class="square"><picture><source srcset="/posts/copilot-turns-junior-devs-into-syntax-secretaries/logo-80x80.webp?v=6fb8a2f9a99b840185c830b4bad632d5" type="image/webp"><source srcset="/posts/copilot-turns-junior-devs-into-syntax-secretaries/logo-80x80.png?v=9c12d22e11b337633f458806c721afd6" type="image/png"><img src="/posts/copilot-turns-junior-devs-into-syntax-secretaries/logo.png?v=2e75b6998a3d30de0c11c2d16dbce697" alt="Copilot Turns Junior Devs Into Syntax Secretaries" loading="lazy" decoding="async" title="Copilot Turns Junior Devs Into Syntax Secretaries"></picture></figure><header><h2>Copilot Turns Junior Devs Into Syntax Secretaries</h2></header><section class="content"><p>The hype around GitHub Copilot (or any other AI code assistant) is deafening. AI-assisted coding. Effortless automation. <em><strong>10x productivity.</strong></em></p><p>But here’s the harsh truth: <strong>Copilot isn’t empowering junior developers – it’s deskilling them.</strong></p></section><a class="link" href="/posts/copilot-turns-junior-devs-into-syntax-secretaries/" rel="tag" title="Copilot Turns Junior Devs Into Syntax Secretaries"></a></section><section class="card"><figure class="square"><picture><source srcset="/images/vibecoding-80x80.webp?v=627bd7d4bf89f079951c78503a124358" type="image/webp"><source srcset="/images/vibecoding-80x80.png?v=7617a55dbdf6bd7939238821b77c1a82" type="image/png"><img src="/images/vibecoding.png?v=9a36076d86533930bbd6319c257968b9" alt="Vibe Coding in .NET: Creative Catalyst or Maintenance Risk?" loading="lazy" decoding="async" title="Vibe Coding in .NET: Creative Catalyst or Maintenance Risk?"></picture></figure><header><h2>Vibe Coding in .NET: Creative Catalyst or Maintenance Risk?</h2></header><section class="content"><p>In the world of software development, there’s a recurring tension between <strong>discipline and improvisation</strong>. Somewhere along that spectrum lies a phenomenon increasingly referred to as <strong>Vibe Coding</strong>. The term evokes a style of development where engineers follow intuition and momentum rather than formal plans, processes, or design patterns.</p><p>It’s fast, fluid, and occasionally brilliant. But is it sustainable in a .NET-based enterprise context?</p></section><a class="link" href="/posts/vibe-coding-isnt-wrong-its-unfinished/" rel="tag" title="Vibe Coding in .NET: Creative Catalyst or Maintenance Risk?"></a></section><section class="card"><figure class="square"><picture><source srcset="/images/csharp-80x80.webp?v=2009610da0e7ad52e611197cf3092830" type="image/webp"><source srcset="/images/csharp-80x80.png?v=c5d685b0d4fa9ec69bd959ee04beb903" type="image/png"><img src="/images/csharp.png?v=21ff9dcf5d1da7bfa80141c972c117da" alt="Understanding the C# `StringValues`: A Comprehensive Guide" loading="lazy" decoding="async" title="Understanding the C# `StringValues`: A Comprehensive Guide"></picture></figure><header><h2>Understanding the C# `StringValues`: A Comprehensive Guide</h2></header><section class="content"><p>In C#, the <code>StringValues</code> struct belongs to the <code>Microsoft.Extensions.Primitives</code> namespace, which is widely used in modern .NET applications. This struct plays a crucial role in efficiently managing string collections, especially when handling efficiently, particularly in contexts where multiple strings are involved. In this blog post, we’ll explore the purpose, usage, and key features of the <code>StringValues</code> struct in C#.</p></section><a class="link" href="/posts/understanding-csharp-stringvalues/" rel="tag" title="Understanding the C# `StringValues`: A Comprehensive Guide"></a></section></main><nav class="pagination"><a class="item" rel="next" disabled><i class="fas fa-backward"></i></a>
<span class="current item">1&nbsp;/&nbsp;2</span>
<a class="item" href="/tags/dotnet/2/" hreflang="en-us" title=".NET &mdash; Daily DevOps & .NET &mdash; Page 2" rel="prev"><i class="fas fa-forward"></i></a></nav></main><footer class="footer"><div class="divider"></div><nav><ul class="navigation"><li><a href="/tags/">Tags</a></li><li><a href="/legal-notice/">Legal notice</a></li></ul></nav><div class="copyright">&copy; 2023 - 2025 Daily DevOps & .NET</div></footer><script defer src="/js/below.min.a6ce9164454b6077f17ae856f280442d9f3a1e21f06189f71c21f75144b22a0c8cf32bafd61d440e9d90ca02bf738b6a8ef19f5ec20285d8ca574f98c91ebaf2.js" integrity="sha512-ps6RZEVLYHfxeuhW8oBELZ86HiHwYYn3HCH3UUSyKgyM8yuv1h1EDp2QygK/c4tqjvGfXsIChdjKV0+YyR668g==" crossorigin="anonymous"></script></body></html>