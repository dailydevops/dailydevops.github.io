<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Daily DevOps &amp; .NET - Where Code Meets Culture on Daily DevOps &amp; .NET</title>
    <link>https://daily-devops.net/</link>
    <description>Recent content in Daily DevOps &amp;amp; .NET - Where Code Meets Culture on Daily DevOps &amp; .NET</description>
    <language>en-US</language>
    <lastBuildDate>Mon, 01 Dec 2025 18:24:06 +0000</lastBuildDate>
    <atom:link type="application/rss+xml" href="https://daily-devops.net/feed.rss" hreflang="en-US" rel="self"/>
    <atom:link type="text/html" href="https://daily-devops.net/" hreflang="en-US" rel="alternate"/>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/dotnet-job-scheduling-2-hangfire/</guid>
      <link>https://daily-devops.net/posts/dotnet-job-scheduling-2-hangfire/</link>
      <title>.NET Job Scheduling — Hangfire and Persistent Reliability</title>
      <pubDate>Thu, 27 Nov 2025 17:00:00 +0100</pubDate>
      <description>Hangfire combines persistent job storage, automatic retries, and real-time monitoring to simplify background processing.
Learn when database-backed reliability matters and how Hangfire scales from single instances to distributed workers.</description>
      <category>architecture</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>nuget</category>
      <category>softwareengineering</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/dotnet-job-scheduling-1-landscape/</guid>
      <link>https://daily-devops.net/posts/dotnet-job-scheduling-1-landscape/</link>
      <title>.NET Job Scheduling — The Landscape</title>
      <pubDate>Tue, 25 Nov 2025 17:00:00 +0100</pubDate>
      <description>Explore the spectrum of .NET job scheduling from lightweight in-memory solutions to enterprise-grade distributed systems.
Understand which approach fits your operational model and why background processing architecture matters.</description>
      <category>architecture</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>nuget</category>
      <category>softwareengineering</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/healthchecks-5-0/</guid>
      <link>https://daily-devops.net/posts/healthchecks-5-0/</link>
      <title>NetEvolve.HealthChecks 5.0: 27+ Targeted Probes, Zero Boilerplate
</title>
      <pubDate>Thu, 20 Nov 2025 23:00:00 +0100</pubDate>
      <description>NetEvolve.HealthChecks 5.0 is a decisive expansion—broader coverage scope, less boilerplate.
New domain‑specific packages extend monitoring across cloud services, messaging platforms, graph, time‑series, vector and AI backends. In parallel, the former inheritance‑driven shared base library (abstract classes + repetitive DI wiring) was replaced by purpose-built source generators—removing manual registration churn and consolidating intent. Release 5.0 also formalizes full support for .NET 10—aligning with current trimming and analyzer improvements.
</description>
      <category>csharp</category>
      <category>dotnet</category>
      <category>netevolve</category>
      <category>nuget</category>
      <category>performance</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/dotnet-10-testing/</guid>
      <link>https://daily-devops.net/posts/dotnet-10-testing/</link>
      <title>.NET 10 Testing: Microsoft Finally Fixed the Test Runner (Mostly)
</title>
      <pubDate>Thu, 20 Nov 2025 17:00:00 +0100</pubDate>
      <description>.NET 10 replaces VSTest with Microsoft.Testing.Platform, bringing SDK-integrated testing with faster discovery, consistent behavior across environments, and explicit configuration contracts. But it requires .NET 10, breaks old test adapters, and demands CI pipeline discipline. Here’s what actually changes, who should migrate now, and who should wait.</description>
      <category>csharp</category>
      <category>devops</category>
      <category>dotnet</category>
      <category>github-actions</category>
      <category>softwareengineering</category>
      <category>testing</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/code-metrics-configuration/</guid>
      <link>https://daily-devops.net/posts/code-metrics-configuration/</link>
      <title>Code Metrics and Configuration: Beyond the Numbers Game</title>
      <pubDate>Tue, 18 Nov 2025 17:00:00 +0100</pubDate>
      <description>Code metrics have become a standard feature in modern development environments, yet their implementation and interpretation often leave much to be desired. While Visual Studio and .NET provide comprehensive code metrics analysis, the way these metrics are configured, presented, and (more critically) acted upon reveals a fundamental disconnect between measurement and meaningful improvement.
What code metrics actually measure, how to configure them properly, and (more importantly) why blindly following thresholds without understanding context is, frankly, a recipe for misguided refactoring efforts that waste your team’s time and actively damage your codebase.
</description>
      <category>bestpractices</category>
      <category>codequality</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>softwareengineering</category>
      <category>visualstudio</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/dotnet-10-released/</guid>
      <link>https://daily-devops.net/posts/dotnet-10-released/</link>
      <title>.NET 10: Boring by Design, Reliable by Default
</title>
      <pubDate>Thu, 13 Nov 2025 18:00:00 +0100</pubDate>
      <description>Microsoft wants you to believe .NET 10 is boring. They’re right — and that’s the best news we’ve had in years.
.NET 10 is here, and for once, Microsoft didn’t oversell it. LTS support through 2028, JIT improvements that actually matter, and C# 14 features that won’t rewrite your architecture. Here’s what you need to know before migrating.
</description>
      <category>architecture</category>
      <category>codequality</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>microsoft</category>
      <category>performance</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/timing-is-the-new-technical-debt/</guid>
      <link>https://daily-devops.net/posts/timing-is-the-new-technical-debt/</link>
      <title>.NET 10: Timing Is the New Technical Debt
</title>
      <pubDate>Wed, 12 Nov 2025 18:00:00 +0100</pubDate>
      <description>2025 reshapes the .NET ecosystem with faster release cycles and shared responsibility. Discover why migrating to .NET 10 by Q1 2026 — and supporting your dependencies — turns timing into sustainable ROI.</description>
      <category>architecture</category>
      <category>bestpractices</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>performance</category>
      <category>technicaldebt</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/dotnet-10-release-cycle-paradox/</guid>
      <link>https://daily-devops.net/posts/dotnet-10-release-cycle-paradox/</link>
      <title>.NET 10 and the Release Cycle Paradox</title>
      <pubDate>Tue, 11 Nov 2025 16:30:00 +0100</pubDate>
      <description>.NET’s yearly rhythm has become a symbol of stability — yet also a source of pressure. The release cycle paradox describes the tension between predictability and exhaustion: a release schedule that keeps the ecosystem healthy, but teams constantly catching up.
With .NET 10 on the horizon, developers must learn to navigate this rhythm rather than fight it.
</description>
      <category>architecture</category>
      <category>bestpractices</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>softwareengineering</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/proper-use-of-targetframework-conditions/</guid>
      <link>https://daily-devops.net/posts/proper-use-of-targetframework-conditions/</link>
      <title>Stop Breaking Multi-Targeting Builds with String Comparisons</title>
      <pubDate>Thu, 06 Nov 2025 17:30:00 +0100</pubDate>
      <description>String-based TargetFramework conditions fail silently in multi-targeting builds. IsTargetFrameworkCompatible() understands framework semantics and prevents production nightmares.</description>
      <category>bestpractices</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>msbuild</category>
      <category>softwareengineering</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/modern-defensive-programming/</guid>
      <link>https://daily-devops.net/posts/modern-defensive-programming/</link>
      <title>Modern Defensive Programming in .NET — Unified Throw-Helpers and Multi-Framework Compatibility</title>
      <pubDate>Mon, 03 Nov 2025 18:00:00 +0200</pubDate>
      <description>Modern .NET introduces powerful throw-helper methods such as ArgumentNullException.ThrowIfNull and ArgumentException.ThrowIfNullOrEmpty to simplify defensive programming. However, many projects still target older frameworks where these APIs are missing. This article explores how the NetEvolve.Arguments library delivers a unified, backward-compatible API that brings modern guard clause patterns to every .NET version, ensuring consistent validation, maintainability, and multi-framework compatibility.</description>
      <category>csharp</category>
      <category>dotnet</category>
      <category>netevolve</category>
      <category>nuget</category>
      <category>softwareengineering</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/tests-are-lying/</guid>
      <link>https://daily-devops.net/posts/tests-are-lying/</link>
      <title>Your Tests Are Lying — Mutation Testing in .NET</title>
      <pubDate>Thu, 30 Oct 2025 18:00:00 +0200</pubDate>
      <description>It begins like many stories in software: a well-intentioned developer joining a project, determined to do things properly. You arrive at a codebase that has grown organically, perhaps even chaotically. You decide you will bring order. You set up unit testing, you configure continuous integration, you measure code coverage. You write dozens or hundreds of tests. Every public method is touched, every branch is at least executed. The dashboard lights up green. You feel, quite frankly, on top of things.
Then one day, production breaks under your watch
</description>
      <category>csharp</category>
      <category>dotnet</category>
      <category>nuget</category>
      <category>technicaldebt</category>
      <category>testing</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/nuget-packagedownload-functionality/</guid>
      <link>https://daily-devops.net/posts/nuget-packagedownload-functionality/</link>
      <title>PackageDownload: NuGet's Forgotten Power Tool
</title>
      <pubDate>Wed, 29 Oct 2025 18:00:00 +0100</pubDate>
      <description>PackageDownload arrived in NuGet 4.8 to solve a niche but genuine problem: downloading packages without adding assembly references. It works. But its version syntax requirements and complete disregard for Central Package Management reveal the messy reality of platform evolution.</description>
      <category>bestpractices</category>
      <category>dependency-management</category>
      <category>dotnet</category>
      <category>msbuild</category>
      <category>nuget</category>
      <category>technicaldebt</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/netevolve-healthchecks/</guid>
      <link>https://daily-devops.net/posts/netevolve-healthchecks/</link>
      <title>Configuration-First Health Checks for Modern .NET</title>
      <pubDate>Tue, 28 Oct 2025 18:00:00 +0200</pubDate>
      <description>Let’s be honest: health checks are the broccoli of .NET projects. Everyone says they have them, but nobody’s excited to eat their greens. What starts as a humble SELECT 1 in a try/catch quickly explodes into a wild jungle of scripts, copy-pasted connection strings, and endpoints that only half the team remembers. Sure, it works—until it doesn’t. And when it breaks, it’s never at a good time.
</description>
      <category>csharp</category>
      <category>dotnet</category>
      <category>netevolve</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/compositeformat-performance-boost/</guid>
      <link>https://daily-devops.net/posts/compositeformat-performance-boost/</link>
      <title>Stop Parsing the Same String Twice: CompositeFormat in .NET</title>
      <pubDate>Thu, 23 Oct 2025 17:00:00 +0200</pubDate>
      <description>Every time you call string.Format() with the same format string, .NET parses it again. And again. And again. CompositeFormat changes that: parse once, reuse forever. The result? Up to 30% faster formatting, fewer allocations, and a one-line code change. Here’s why this matters and how to use it.</description>
      <category>bestpractices</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>hidden-gems</category>
      <category>performance</category>
      <category>softwareengineering</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/searchvalues-saved-us-from-scaling-hell/</guid>
      <link>https://daily-devops.net/posts/searchvalues-saved-us-from-scaling-hell/</link>
      <title>How SearchValues Saved Us From Scaling Hell</title>
      <pubDate>Mon, 20 Oct 2025 17:30:00 +0100</pubDate>
      <description>While you’re busy optimizing database queries and adding cache layers, thousands of string searches per second are quietly eating your CPU budget. The problem isn’t visible in your APM dashboard because it’s distributed across every request. But it’s there. Compounding. Scaling linearly with load.
I discovered this the hard way when a log processing API started choking under production traffic. The bottleneck? String validation and sanitization. The fix? A .NET 8 feature that delivered a 5x performance improvement and let us shut down servers instead of adding them. And it’s gotten even better in .NET 9 and 10.
</description>
      <category>bestpractices</category>
      <category>codequality</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>hidden-gems</category>
      <category>performance</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/clean-code-lip-service-not-a-standard/</guid>
      <link>https://daily-devops.net/posts/clean-code-lip-service-not-a-standard/</link>
      <title>Clean Code: A Lip Service, Not a Standard
</title>
      <pubDate>Thu, 16 Oct 2025 13:00:00 +0200</pubDate>
      <description>Clean Code is often praised but rarely practiced effectively. This article explores how misunderstood ideals and over-engineering harm .NET systems, how to recognize such failures early, and which C# best practices and official guidelines truly support maintainable software.</description>
      <category>bestpractices</category>
      <category>codequality</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>softwareengineering</category>
      <category>technicaldebt</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/constant-expected-attribute/</guid>
      <link>https://daily-devops.net/posts/constant-expected-attribute/</link>
      <title>ConstantExpectedAttribute: Unlocking Performance Through Compiler Awareness</title>
      <pubDate>Tue, 14 Oct 2025 14:30:00 +0200</pubDate>
      <description>The ConstantExpectedAttribute, introduced in .NET 7, provides a powerful mechanism to signal compiler expectations about constant values. This enables better performance optimizations, enhanced IDE tooling, and clearer API contracts. Learn how to leverage this attribute to build more efficient and maintainable .NET applications.</description>
      <category>bestpractices</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>performance</category>
      <category>softwareengineering</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/retiring-legacy-dotnet-projects/</guid>
      <link>https://daily-devops.net/posts/retiring-legacy-dotnet-projects/</link>
      <title>Retiring Legacy .NET Projects — Balancing Risk, Cost, and Forward Value
</title>
      <pubDate>Mon, 13 Oct 2025 11:30:00 +0200</pubDate>
      <description>In every mature .NET landscape, legacy projects represent both heritage and hazard. They once powered entire business models — now they silently consume time, budget, and attention. The decision to retire or modernize them isn’t about technology fashion. It’s about sustaining the organization’s capacity for value creation.
</description>
      <category>architecture</category>
      <category>bestpractices</category>
      <category>dotnet</category>
      <category>rcda</category>
      <category>softwareengineering</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/tunit-a-pragmatic-evaluation-for-dotnet-teams/</guid>
      <link>https://daily-devops.net/posts/tunit-a-pragmatic-evaluation-for-dotnet-teams/</link>
      <title>TUnit — A Pragmatic Evaluation for .NET Teams
</title>
      <pubDate>Thu, 09 Oct 2025 11:30:00 +0200</pubDate>
      <description>TUnit brings compile-time test discovery and native AOT support to .NET testing — but is it ready for enterprise adoption? A pragmatic analysis of performance gains, tooling maturity, and migration timing for teams evaluating alternatives to MSTest, xUnit, and NUnit.</description>
      <category>architecture</category>
      <category>bestpractices</category>
      <category>dotnet</category>
      <category>performance</category>
      <category>rcda</category>
      <category>softwareengineering</category>
      <category>testing</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/still-waiting-for-the-final-piece/</guid>
      <link>https://daily-devops.net/posts/still-waiting-for-the-final-piece/</link>
      <title>Still Waiting for the Final Piece: When C# 14 Comes Close, But Not Quite There
</title>
      <pubDate>Mon, 06 Oct 2025 09:00:00 +0200</pubDate>
      <description>C# 14 introduces the new ‘Extension Everything’ syntax—an elegant step toward more expressive code, yet one that still can’t quite match VB.NET’s classic ByRef magic. A humorous reflection on what’s almost, but not fully, possible in .NET 10.</description>
      <category>csharp</category>
      <category>dotnet</category>
      <category>extensions</category>
      <category>hidden-gems</category>
      <category>vbnet</category>
      <category>visualstudio</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/extended-dotnet-sts-support-timeframe/</guid>
      <link>https://daily-devops.net/posts/extended-dotnet-sts-support-timeframe/</link>
      <title>The Generous Gift? Microsoft Extends .NET STS Support to 24 Months</title>
      <pubDate>Tue, 30 Sep 2025 11:30:00 +0200</pubDate>
      <description>Microsoft has extended .NET STS support from 18 to 24 months. A genuine gift to developers or just catching up with reality? Let’s analyze what this means for your development planning.</description>
      <category>dotnet</category>
      <category>microsoft</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/dotnet10rc1-is-knocking-at-the-door/</guid>
      <link>https://daily-devops.net/posts/dotnet10rc1-is-knocking-at-the-door/</link>
      <title>.NET 10 RC 1 is Knocking at the Door: Architectural Impact, C# 14, and Performance</title>
      <pubDate>Wed, 10 Sep 2025 09:00:00 +0200</pubDate>
      <description>.NET 10 RC 1 is knocking at the door, marking the first release candidate and offering the .NET community a detailed preview of what’s to come in the next LTS cycle. While not the final release, RC 1 is “go-live” supported and represents the feature-complete platform that will soon become .NET 10 LTS. In this article, I’ll try to give a rough overview of the architectural impact of .NET 10 RC 1, focusing on the latest C# 14 features, under-the-hood performance improvements, and strategic considerations for the upcoming LTS.
</description>
      <category>architecture</category>
      <category>csharp</category>
      <category>dotnet</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/visual-studio-2026/</guid>
      <link>https://daily-devops.net/posts/visual-studio-2026/</link>
      <title>Visual Studio 2026 - Why AI-Native Tooling Will Matter</title>
      <pubDate>Wed, 10 Sep 2025 01:00:00 +0200</pubDate>
      <description>Let’s skip the typical release-cycle enthusiasm for a second: Most IDE updates come and go. New features, some refactoring helpers, a bit of polish, then back to business as usual. Visual Studio 2026 is different. For once, the promise of “AI-native” isn’t just marketing. If Microsoft lands even half of what they’re previewing, it’s going to matter—a lot.
</description>
      <category>csharp</category>
      <category>dotnet</category>
      <category>visualstudio</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/buzzword-driven-development/</guid>
      <link>https://daily-devops.net/posts/buzzword-driven-development/</link>
      <title>Buzzword-Driven Development vs. Fundamental Software Quality</title>
      <pubDate>Wed, 23 Jul 2025 17:00:00 +0200</pubDate>
      <description>Explore why fundamental software quality practices in .NET must never be overlooked for trendy buzzwords, including recommended analyzers and project settings for managing technical debt effectively.</description>
      <category>ai-code-assistant</category>
      <category>bestpractices</category>
      <category>codequality</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>nuget</category>
      <category>softwareengineering</category>
      <category>technicaldebt</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/instruction-by-design/</guid>
      <link>https://daily-devops.net/posts/instruction-by-design/</link>
      <title>Instruction by Design: Transforming ADRs into Actionable AI Guidance</title>
      <pubDate>Tue, 15 Jul 2025 10:30:00 +0200</pubDate>
      <description>Discover how to transform architectural decision records (ADRs) into actionable, AI-ready guidance for teams and copilots—boosting consistency, onboarding, and automation in your development workflow.</description>
      <category>ai-code-assistant</category>
      <category>architecture</category>
      <category>bestpractices</category>
      <category>github</category>
      <category>github-copilot</category>
      <category>rcda</category>
      <category>softwareengineering</category>
      <category>technicaldebt</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/copilot-without-becoming-its-puppet/</guid>
      <link>https://daily-devops.net/posts/copilot-without-becoming-its-puppet/</link>
      <title>How to Use Copilot Without Becoming Its Puppet</title>
      <pubDate>Wed, 14 May 2025 17:30:00 +0200</pubDate>
      <description>In a previous article, we laid it out – unfiltered: Copilot turns junior devs into syntax secretaries.
Not because it’s evil. But because it removes friction before understanding.
It gives you working code before you know what working even means. It creates the illusion of progress, while slowly eroding the very skills that define a software engineer: reasoning, decision-making, and technical ownership.
</description>
      <category>ai-code-assistant</category>
      <category>bestpractices</category>
      <category>dotnet</category>
      <category>github</category>
      <category>github-copilot</category>
      <category>testing</category>
      <category>visualstudio</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/copilot-turns-junior-devs-into-syntax-secretaries/</guid>
      <link>https://daily-devops.net/posts/copilot-turns-junior-devs-into-syntax-secretaries/</link>
      <title>Copilot Turns Junior Devs Into Syntax Secretaries</title>
      <pubDate>Tue, 13 May 2025 17:30:00 +0200</pubDate>
      <description>The hype around GitHub Copilot (or any other AI code assistant) is deafening. AI-assisted coding. Effortless automation. 10x productivity.
But here’s the harsh truth: Copilot isn’t empowering junior developers – it’s deskilling them.
</description>
      <category>ai-code-assistant</category>
      <category>bestpractices</category>
      <category>dotnet</category>
      <category>github</category>
      <category>github-copilot</category>
      <category>testing</category>
      <category>visualstudio</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/vibe-coding-isnt-wrong-its-unfinished/</guid>
      <link>https://daily-devops.net/posts/vibe-coding-isnt-wrong-its-unfinished/</link>
      <title>Vibe Coding in .NET: Creative Catalyst or Maintenance Risk?</title>
      <pubDate>Wed, 07 May 2025 12:00:00 +0200</pubDate>
      <description>In the world of software development, there’s a recurring tension between discipline and improvisation. Somewhere along that spectrum lies a phenomenon increasingly referred to as Vibe Coding. The term evokes a style of development where engineers follow intuition and momentum rather than formal plans, processes, or design patterns.
It’s fast, fluid, and occasionally brilliant. But is it sustainable in a .NET-based enterprise context?
</description>
      <category>bestpractices</category>
      <category>codequality</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>softwareengineering</category>
      <category>technicaldebt</category>
      <category>testing</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/understanding-csharp-stringvalues/</guid>
      <link>https://daily-devops.net/posts/understanding-csharp-stringvalues/</link>
      <title>Understanding the C# `StringValues`: A Comprehensive Guide</title>
      <pubDate>Mon, 30 Dec 2024 16:00:00 +0100</pubDate>
      <description>In C#, the StringValues struct belongs to the Microsoft.Extensions.Primitives namespace, which is widely used in modern .NET applications. This struct plays a crucial role in efficiently managing string collections, especially when handling efficiently, particularly in contexts where multiple strings are involved. In this blog post, we’ll explore the purpose, usage, and key features of the StringValues struct in C#.
</description>
      <category>csharp</category>
      <category>dotnet</category>
      <category>hidden-gems</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/managing-errors-warnings-and-configurations/</guid>
      <link>https://daily-devops.net/posts/managing-errors-warnings-and-configurations/</link>
      <title>Managing Errors, Warnings, and Configurations in C# and .NET</title>
      <pubDate>Mon, 23 Dec 2024 16:00:00 +0100</pubDate>
      <description>When we activated static code analysis for the first time in one of my last projects, the overwhelming number of warnings exceeded expectations and highlighted gaps in the code. Without making any changes, the project already had a significant number of warnings. After activating additional analyzers and updating some configurations, this number temporarily increased dramatically.
The high number of warnings was initially daunting, but we saw it as an opportunity to significantly improve our code quality. At first glance, it seemed easier to suppress or ignore these warnings. But as I often remind my team, “The code you create is a valuable legacy, so it’s important to build it carefully.” Ignoring warnings today creates obstacles for future developers—and that could very well include you six months down the line.
This experience reinforced the importance of managing warnings and errors systematically. Let me share some of the lessons we learned, the strategies we used to tame those 60,000 warnings, and how you can apply these techniques to your own projects.
</description>
      <category>bestpractices</category>
      <category>codequality</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>msbuild</category>
      <category>softwareengineering</category>
      <category>technicaldebt</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/tale-of-forgotten-pennies-and-lost-dollars/</guid>
      <link>https://daily-devops.net/posts/tale-of-forgotten-pennies-and-lost-dollars/</link>
      <title>A Tale of Forgotten Pennies and Lost Dollars</title>
      <pubDate>Fri, 22 Nov 2024 16:45:00 +0100</pubDate>
      <description>In software development, there’s a silent debt that accrues interest over time, often hidden beneath layers of code and decisions made in haste or ignorance. This debt is aptly termed technical debt. Much like the german proverb, “Wer den Pfennig nicht ehrt, ist den Taler nicht wert”, (or the english equivalent, “A penny saved is a penny earned”) technical debt reminds us that small oversights or compromises in the present can snowball into significant challenges down the road. This article critically examines the parallels between financial principles and technical debt, emphasizing the importance of addressing both direct and indirect debt while understanding its distinction from external risks such as hacking or abuse.
</description>
      <category>bestpractices</category>
      <category>dependency-management</category>
      <category>rcda</category>
      <category>softwareengineering</category>
      <category>technicaldebt</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/dependamerge-action/</guid>
      <link>https://daily-devops.net/posts/dependamerge-action/</link>
      <title>Master dependency management with automation: story behind `dependamerge`</title>
      <pubDate>Wed, 13 Nov 2024 09:00:00 +0100</pubDate>
      <description>In software development, dependencies are inevitable - any project worth its salt relies on various libraries, frameworks, or packages. However, as I found in my own work, managing these dependencies can be an onerous task. Constant updates, new vulnerabilities, and endless manual approvals were draining my time and focus. What if, I thought, these processes could be automated? This thought led to the creation of dependamerge, a GitHub Action designed to free developers from the drudgery of manual dependency maintenance and let us get back to what we do best: building great software.
</description>
      <category>bestpractices</category>
      <category>dependency-management</category>
      <category>github</category>
      <category>github-actions</category>
      <category>nuget</category>
      <category>technicaldebt</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/introducing-nullability-in-legacy-code/</guid>
      <link>https://daily-devops.net/posts/introducing-nullability-in-legacy-code/</link>
      <title>Gradually Introducing Nullability in Legacy Code: A Practical Guide for .NET and C#</title>
      <pubDate>Mon, 07 Oct 2024 17:15:00 +0200</pubDate>
      <description>As developers, we’re often tasked with maintaining and modernizing legacy codebases that were written long before some of the best practices of today—such as nullability annotations—were available. While modern C# now supports nullable reference types, enabling us to avoid the dreaded NullReferenceException, introducing this feature to existing, large codebases can be a challenge.
In this article, I’ll share my step-by-step approach for introducing nullability into a legacy .NET and C# project. You’ll learn how to apply nullability in a controlled, incremental manner using project-level settings, scoped annotations, and file/method-level directives, all while maintaining the integrity of your legacy codebase. After all, modernizing your code doesn’t have to be an all-or-nothing endeavor—gradual change is key to a successful transition. Let’s get started!
</description>
      <category>bestpractices</category>
      <category>codequality</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>softwareengineering</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/buildinginsidevisualstudio/</guid>
      <link>https://daily-devops.net/posts/buildinginsidevisualstudio/</link>
      <title>Mastering .NET Project Properties: The `BuildingInsideVisualStudio` Flag</title>
      <pubDate>Tue, 10 Sep 2024 17:00:00 +0200</pubDate>
      <description>In the ever-evolving world of .NET development, managing project configurations effectively is crucial for maintaining a clean and efficient build process. One of the less frequently discussed but highly useful properties is BuildingInsideVisualStudio. This property, when correctly utilized, can streamline your build process and ensure that your project is configured properly depending on the build environment. In this article, we’ll explore the BuildingInsideVisualStudio property with concrete examples and discuss best practices for using it effectively.
</description>
      <category>bestpractices</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>hidden-gems</category>
      <category>msbuild</category>
      <category>visualstudio</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/reimagining-the-microsoft-certification-exam-ui/</guid>
      <link>https://daily-devops.net/posts/reimagining-the-microsoft-certification-exam-ui/</link>
      <title>Reimagining the Microsoft Certification Exam UI Experience</title>
      <pubDate>Thu, 14 Mar 2024 09:00:00 +0100</pubDate>
      <description>Embark on a journey through Microsoft’s redesigned certification exam UI. Discover streamlined navigation, enhanced accessibility, and personalized experiences, revolutionizing the exam-taking experience.</description>
      <category>azure</category>
      <category>certification</category>
      <category>microsoft</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/manage-nuget-packages-centrally/</guid>
      <link>https://daily-devops.net/posts/manage-nuget-packages-centrally/</link>
      <title>Manage NuGet Packages Centrally</title>
      <pubDate>Mon, 17 Apr 2023 08:30:00 +0200</pubDate>
      <description>For over 12 years, NuGet package management has been part of the .NET ecosystem with direct integrations to various IDEs, CLIs and build systems. But a feature took 12 years before it appeared and certainly needs some more maintenance until it is mature!
</description>
      <category>bestpractices</category>
      <category>csharp</category>
      <category>dependency-management</category>
      <category>dotnet</category>
      <category>hidden-gems</category>
      <category>nuget</category>
      <category>technicaldebt</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/illuminate-technical-debt/</guid>
      <link>https://daily-devops.net/posts/illuminate-technical-debt/</link>
      <title>Illuminate Technical Debt</title>
      <pubDate>Wed, 12 Apr 2023 17:00:00 +0200</pubDate>
      <description>Whatever our role, be it developer, IT professional or architect, we try to avoid technical debt. If this is not possible from the outset, or if we decide to accept this technical debt for a limited period of time, we usually lack the tools to do so. This is where this article may help.
</description>
      <category>azuredevops</category>
      <category>extensions</category>
      <category>rcda</category>
      <category>technicaldebt</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/when-can-i-finally-renew-my-microsoft-certification/</guid>
      <link>https://daily-devops.net/posts/when-can-i-finally-renew-my-microsoft-certification/</link>
      <title>When Can I Finally Renew My Microsoft Certification</title>
      <pubDate>Tue, 11 Apr 2023 09:00:00 +0200</pubDate>
      <description>When can I finally renew my Microsoft certification? - I’m certainly not alone with this or similar questions and the associated uncertainty. Okay, a certain impatience certainly resonates as well. After all, I would also like to schedule it into my daily routine. But how?
</description>
      <category>azure</category>
      <category>certification</category>
      <category>microsoft</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/how-to-prepare-for-microsoft-certification/</guid>
      <link>https://daily-devops.net/posts/how-to-prepare-for-microsoft-certification/</link>
      <title>How to Prepare for Microsoft Certification</title>
      <pubDate>Fri, 27 Jan 2023 21:00:00 +0100</pubDate>
      <description>How do I best prepare for a Microsoft certification? - this or a similar question is asked by everyone who wants to deal with the topics Microsoft, Azure, Microsoft 365, Power Platform or Dynamics 365. In this article, I would like to go into the possibilities that Microsoft offers us for preparation.
</description>
      <category>azure</category>
      <category>certification</category>
      <category>microsoft</category>
    </item>
  </channel>
</rss>
