<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Daily DevOps &amp; .NET - Where Code Meets Culture on Daily DevOps &amp; .NET</title>
    <link>https://daily-devops.net/</link>
    <description>Recent content in Daily DevOps &amp; .NET - Where Code Meets Culture on Daily DevOps &amp; .NET</description>
    <language>en</language>
    <lastBuildDate>Wed, 04 Feb 2026 16:08:12 +0000</lastBuildDate>
    <atom:link type="application/rss+xml" href="https://daily-devops.net/feed.rss" hreflang="en" rel="self"/>
    <atom:link type="text/html" href="https://daily-devops.net/" hreflang="en" rel="alternate"/>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/storage-architecture-stateful-workloads-aks/</guid>
      <link>https://daily-devops.net/posts/storage-architecture-stateful-workloads-aks/</link>
      <title>Storage Architecture &amp; Stateful Workloads in AKS</title>
      <pubDate>Wed, 04 Feb 2026 17:00:00 +0100</pubDate>
      <description>Stateful workloads in Kubernetes require understanding PersistentVolume architecture, Azure storage trade-offs, and backup strategies. This article covers PVC/PV patterns, Azure Disk vs Files performance profiles, Velero backup configurations, and multi-cluster replication patterns based on production experience.</description>
      <category>azure</category>
      <category>cloud</category>
      <category>kubernetes</category>
      <category>operations</category>
      <category>platform-engineering</category>
      <category>reliability</category>
      <category>storage</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/secrets-management-azure-keyvault/</guid>
      <link>https://daily-devops.net/posts/secrets-management-azure-keyvault/</link>
      <title>Your appsettings.json Is a Compliance Violation</title>
      <pubDate>Tue, 03 Feb 2026 17:00:00 +0100</pubDate>
      <description>Hardcoded secrets aren‚Äôt just bad practice‚Äîthey‚Äôre ISO 27017 violations with real consequences: failed audits, denied insurance claims, contractual penalties. That connection string in your appsettings.Production.json? It represents a compliance gap your organization probably doesn‚Äôt even know exists. Azure Key Vault with Managed Identity isn‚Äôt an optional security enhancement‚Äîit‚Äôs the minimum viable implementation of standards you already claim to follow.</description>
      <category>azure</category>
      <category>cloud</category>
      <category>dotnet</category>
      <category>iso-standards</category>
      <category>security</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/audit-logging-azure-app-insights/</guid>
      <link>https://daily-devops.net/posts/audit-logging-azure-app-insights/</link>
      <title>Audit Logging That Survives Your Next Security Incident</title>
      <pubDate>Thu, 29 Jan 2026 17:00:00 +0100</pubDate>
      <description>Your audit logs probably won‚Äôt survive a real security incident. Most implementations log too much, protect too little, and provide zero value when something breaks at 2 AM. Here‚Äôs how to fix that with structured logging that actually works.</description>
      <category>azure</category>
      <category>bestpractices</category>
      <category>compliance</category>
      <category>dotnet</category>
      <category>iso-standards</category>
      <category>logging</category>
      <category>observability</category>
      <category>security</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/cluster-upgrades-zero-downtime-aks/</guid>
      <link>https://daily-devops.net/posts/cluster-upgrades-zero-downtime-aks/</link>
      <title>AKS Cluster Upgrades: Zero-Downtime Operations That Actually Work</title>
      <pubDate>Wed, 28 Jan 2026 17:00:00 +0100</pubDate>
      <description>AKS cluster upgrades involve node replacement and pod eviction, which can cause service disruption without proper controls. This article explains cordon and drain mechanics, Pod Disruption Budget configuration, and multi-node-pool rollout strategies with validation-driven automation for reliable zero-downtime upgrades.</description>
      <category>aks</category>
      <category>azure</category>
      <category>cloud</category>
      <category>devops</category>
      <category>kubernetes</category>
      <category>operations</category>
      <category>reliability</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/access-control-aspnet-core/</guid>
      <link>https://daily-devops.net/posts/access-control-aspnet-core/</link>
      <title>Your [Authorize] Attribute Is Compliance Theater</title>
      <pubDate>Tue, 27 Jan 2026 17:00:00 +0100</pubDate>
      <description>Your [Authorize] attributes give you a false sense of security. ISO 27001 auditors see right through it.
I‚Äôve reviewed dozens of ASP.NET Core apps that authenticate flawlessly ‚Äî then scatter role strings across business logic, skip audit logs, and wonder why they fail compliance. Here‚Äôs the pattern that kills audits, and how to actually fix it.
</description>
      <category>authentication</category>
      <category>bestpractices</category>
      <category>dotnet</category>
      <category>iso-standards</category>
      <category>security</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/iso-standards-intro-dotnet-developers/</guid>
      <link>https://daily-devops.net/posts/iso-standards-intro-dotnet-developers/</link>
      <title>Why ISO Standards Actually Matter for .NET Developers</title>
      <pubDate>Thu, 22 Jan 2026 17:00:00 +0100</pubDate>
      <description>Cloud-native .NET development has transformed ISO/IEC 27001, 27017, and 27701 from abstract compliance requirements into concrete daily coding decisions. This guide shows .NET developers how security standards directly map to Azure Key Vault integration, Azure AD authentication, and proper logging‚Äîwith real code examples demonstrating compliant vs. non-compliant implementations.</description>
      <category>azure</category>
      <category>cloud</category>
      <category>cloudnative</category>
      <category>compliance</category>
      <category>dotnet</category>
      <category>security</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/pod-identity-access-control-aks/</guid>
      <link>https://daily-devops.net/posts/pod-identity-access-control-aks/</link>
      <title>Pod Identity &amp; Access Control in AKS: What Actually Breaks</title>
      <pubDate>Wed, 21 Jan 2026 17:00:00 +0100</pubDate>
      <description>Traditional AKS authentication relied on service principals and mounted secrets. Workload Identity Federation eliminates credential lifecycle problems, but introduces new failure modes. This article covers the operational realities: where credentials still leak, how RBAC layers compound across Kubernetes and Azure, and validation patterns that prevent identity failures in production.</description>
      <category>azure</category>
      <category>cloud</category>
      <category>devops</category>
      <category>identity</category>
      <category>kubernetes</category>
      <category>rbac</category>
      <category>security</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/real-professional-software-engineering-ai-era/</guid>
      <link>https://daily-devops.net/posts/real-professional-software-engineering-ai-era/</link>
      <title>Real Professional Software Engineering in the AI Era</title>
      <pubDate>Tue, 20 Jan 2026 17:00:00 +0100</pubDate>
      <description>Throughout this series, we‚Äôve established that AI-generated code without understanding creates productivity illusions that collapse in production (Part 1), and that the feedback loop between code and reality‚Äîcompilation, testing, profiling, production‚Äîsharpens thinking in ways AI can‚Äôt replicate (Part 2). Now we confront the practical question: What defines professional software engineering when code generation becomes trivial? This final part examines the irreplaceable skillset: understanding execution characteristics (recognizing allocation patterns that cause GC pressure before deployment), asking questions AI can‚Äôt formulate (What‚Äôs the failure mode when this service is unavailable?), recognizing when plausible AI solutions diverge from correct ones, debugging production failures AI has no execution model to reason about, and evaluating maintainability for code that becomes tomorrow‚Äôs burden. We explore why prompt engineering optimizes for speed while architecture optimizes for survival, why ‚ÄúAI productivity‚Äù often means faster technical debt accumulation, and why the economic reality favors organizations that measure system reliability over lines of code generated. The feedback loop can‚Äôt be automated because closing it requires learning from production failures and applying that knowledge to prevent future ones‚Äîthe irreplaceable discipline that defines real professionals in 2026 and beyond.</description>
      <category>ai-code-assistant</category>
      <category>architecture</category>
      <category>bestpractices</category>
      <category>codequality</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>github-copilot</category>
      <category>softwareengineering</category>
      <category>technicaldebt</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/stossluften-and-software-systems/</guid>
      <link>https://daily-devops.net/posts/stossluften-and-software-systems/</link>
      <title>Sto√ül√ºften: The Architecture of Intentional Resets</title>
      <pubDate>Fri, 16 Jan 2026 11:30:00 +0100</pubDate>
      <description>A Swabian habit teaches a DevOps lesson: open windows fully and often, or invisible decay accumulates. Sto√ül√ºften isn‚Äôt about comfort‚Äîit‚Äôs about forcing systems to prove they‚Äôre healthy. Regular restarts, infrastructure-as-code, and reproducibility checks catch the problems that green metrics miss.</description>
      <category>architecture</category>
      <category>devops</category>
      <category>reliability</category>
      <category>technicaldebt</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/feedback-loop-ai-cant-replace/</guid>
      <link>https://daily-devops.net/posts/feedback-loop-ai-cant-replace/</link>
      <title>The Feedback Loop That AI Can&#39;t Replace</title>
      <pubDate>Thu, 15 Jan 2026 17:00:00 +0100</pubDate>
      <description>In the first part of this series, we established that AI-generated code without understanding creates an illusion of productivity that collapses under production load. The differentiator isn‚Äôt typing speed‚Äîit‚Äôs the feedback loop where code meets reality and exposes incomplete thinking. But what exactly is this feedback loop, and why can‚Äôt AI replicate it? Modern compilers validate logical consistency, catching gaps pure thought leaves unresolved. Profilers expose the 75x performance difference between ‚Äúseems reasonable‚Äù and ‚Äúactually performs.‚Äù Production environments reveal every assumption abstract thinking deferred‚Äîscale, concurrency, failure modes. This article explores the mechanisms that transform vague reasoning into concrete understanding: compilation validates logic instantly, testing catches behavioral mismatches, profiling measures what abstract analysis guesses, and production exposes the cost of every deferred decision. Real professionals don‚Äôt just write code‚Äîthey master the iterative discipline of watching it fail, understanding why, and refining their thinking. AI participates in parts of this loop, but it can‚Äôt close it. That‚Äôs where professionals remain irreplaceable.</description>
      <category>ai-code-assistant</category>
      <category>architecture</category>
      <category>bestpractices</category>
      <category>codequality</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>github-copilot</category>
      <category>softwareengineering</category>
      <category>technicaldebt</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/kubernetes-not-platform-strategy/</guid>
      <link>https://daily-devops.net/posts/kubernetes-not-platform-strategy/</link>
      <title>Kubernetes Is Not a Platform Strategy</title>
      <pubDate>Tue, 13 Jan 2026 17:00:00 +0100</pubDate>
      <description>Kubernetes has become an assumed default in many organizations, positioned as a universal platform that absorbs governance, security, observability, and operational responsibility. This narrative is incomplete. Kubernetes is a powerful runtime orchestrator that solves one phase of the software lifecycle. Architectural risk, cost decisions, and operational failure occur elsewhere. A critical examination of where Kubernetes‚Äôs responsibility ends, and what remains the architect‚Äôs job.</description>
      <category>architecture</category>
      <category>cloudnative</category>
      <category>dotnet</category>
      <category>kubernetes</category>
      <category>platform-engineering</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/kehrwoche-technical-debt/</guid>
      <link>https://daily-devops.net/posts/kehrwoche-technical-debt/</link>
      <title>Kehrwoche: What Swabian Cleaning Teaches About Technical Debt</title>
      <pubDate>Fri, 09 Jan 2026 11:00:00 +0100</pubDate>
      <description>Kehrwoche‚Äîa Swabian cleaning tradition‚Äîis scarier than breaking the build on Friday afternoon. At least the build doesn‚Äôt remember next Tuesday. Mrs. Schmid from the second floor does, and she remembers well. What does a weekly cleaning schedule in southern Germany have to do with technical debt? More than most software teams want to admit.</description>
      <category>bestpractices</category>
      <category>codequality</category>
      <category>softwareengineering</category>
      <category>technicaldebt</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/alphabet-soup-file-formats/</guid>
      <link>https://daily-devops.net/posts/alphabet-soup-file-formats/</link>
      <title>Alphabet Soup: The Format Buffet Nobody Ordered</title>
      <pubDate>Thu, 08 Jan 2026 17:00:00 +0100</pubDate>
      <description>Developers wanted one format. We got twenty. CSV mangles data, XML drowns in tags, JSON forbids comments, YAML punishes spaces. TOML tried fixing it. TAML went minimal. TOON optimized for AI. CCL brought category theory. Result? Five formats per project, three parsers, and debugging why NO became false. AI can‚Äôt save us either. Welcome to format hell.</description>
      <category>bestpractices</category>
      <category>codequality</category>
      <category>configuration</category>
      <category>devops</category>
      <category>dotnet</category>
      <category>softwareengineering</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/code-sharpens-thinking/</guid>
      <link>https://daily-devops.net/posts/code-sharpens-thinking/</link>
      <title>Why Real Professionals Will Never Be Replaced by AI</title>
      <pubDate>Tue, 06 Jan 2026 17:00:00 +0100</pubDate>
      <description>The elephant everyone ignores: AI can generate code faster than you can type. GitHub Copilot autocompletes entire functions. ChatGPT builds APIs from prompts. Typing is dead. So why will real professionals never be replaced? Because ‚Äúvibe coding‚Äù‚Äîdescribe what you want, ship what AI generates‚Äîis a productivity illusion that collapses spectacularly in production. When code generation becomes trivial, understanding what that code costs, where it fails, why it breaks under load becomes everything. AI generates syntax. Professionals understand execution, failure modes, operational cost, and production consequences. The differentiator isn‚Äôt typing speed‚Äîit‚Äôs mastering the feedback loop: write code, watch it fail, understand why, refine thinking. This discipline can‚Äôt be automated. Prompt engineers generate code. Real professionals ensure it survives contact with reality.</description>
      <category>ai-code-assistant</category>
      <category>architecture</category>
      <category>bestpractices</category>
      <category>codequality</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>github-copilot</category>
      <category>softwareengineering</category>
      <category>technicaldebt</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/happy-new-year-2026/</guid>
      <link>https://daily-devops.net/posts/happy-new-year-2026/</link>
      <title>Most Software Teams Are Lying to Themselves‚Äî2026 Needs to Be Different</title>
      <pubDate>Thu, 01 Jan 2026 14:00:00 +0100</pubDate>
      <description>Happy New Year 2026! üéâ
Fix one piece of technical debt this week‚Äînot next quarter. .NET 10, analyzers, and tests are ready; discipline is the only missing part.
</description>
      <category>codequality</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>softwareengineering</category>
      <category>technicaldebt</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/dotnet-2025-year-in-review/</guid>
      <link>https://daily-devops.net/posts/dotnet-2025-year-in-review/</link>
      <title>2025 in Review: The Year .NET Stopped Lying to Itself</title>
      <pubDate>Tue, 30 Dec 2025 17:00:00 +0100</pubDate>
      <description>Forget the hype‚Äî2025 was when .NET tooling finally stopped pretending complexity doesn‚Äôt exist
Three tools won by being honest: Aspire exposed topology, TUnit killed flaky tests, Testcontainers made infrastructure real</description>
      <category>architecture</category>
      <category>aspire</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>opensource</category>
      <category>softwareengineering</category>
      <category>technicaldebt</category>
      <category>testing</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/dotnet-10-cli-devops/</guid>
      <link>https://daily-devops.net/posts/dotnet-10-cli-devops/</link>
      <title>.NET CLI 10 ‚Äì Microsoft Finally Realizes DevOps Exists</title>
      <pubDate>Thu, 25 Dec 2025 17:00:00 +0100</pubDate>
      <description>The .NET CLI? Reliable. Boring. You run dotnet build, dotnet test, dotnet publish, done. Real DevOps work happens in Dockerfiles, CI/CD configs, and specialized tools. The CLI does its job but was never built for actual operational workflows.
.NET 10 changes this. Four additions that sound minor but fix real problems I‚Äôve hit in production pipelines for years: native container publishing, ephemeral tool execution, better cross-platform packaging, and machine-readable schemas. Not flashy. Not keynote material. But they‚Äôre the kind of improvements that save hours every week once you‚Äôre running them at scale.
Will they replace your current workflow? Depends on what you‚Äôre building. Let‚Äôs look at what actually changed.
</description>
      <category>bestpractices</category>
      <category>cli</category>
      <category>csharp</category>
      <category>devops</category>
      <category>dotnet</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/dotnet-advanced-logging/</guid>
      <link>https://daily-devops.net/posts/dotnet-advanced-logging/</link>
      <title>Why Your Logging Strategy Fails in Production</title>
      <pubDate>Tue, 23 Dec 2025 17:00:00 +0100</pubDate>
      <description>Let me tell you what I‚Äôve learned over the years from watching teams deploy logging strategies that looked great on paper and failed spectacularly at 3 AM when production burned.
It‚Äôs not that they didn‚Äôt know the theory. They‚Äôd read the Azure documentation. They‚Äôd seen the structured logging samples. They‚Äôd studied distributed tracing. The real problem was different: they knew what to do but had no idea why it mattered until production broke catastrophically.
</description>
      <category>architecture</category>
      <category>bestpractices</category>
      <category>cloudnative</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>observability</category>
      <category>performance</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/dotnet-cli-expanding-scope-autocomplete/</guid>
      <link>https://daily-devops.net/posts/dotnet-cli-expanding-scope-autocomplete/</link>
      <title>Stop Typing: The .NET CLI Tab Completion You&#39;ve Been Missing</title>
      <pubDate>Thu, 18 Dec 2025 17:00:00 +0100</pubDate>
      <description>One command to transform your .NET CLI workflow‚Äîtab completion so responsive you‚Äôll wonder how you survived without it
Finally, a productivity boost that‚Äôs actually worth your time</description>
      <category>bestpractices</category>
      <category>cli</category>
      <category>devops</category>
      <category>dotnet</category>
      <category>softwareengineering</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/dotnet-job-scheduling-7-comparative-review/</guid>
      <link>https://daily-devops.net/posts/dotnet-job-scheduling-7-comparative-review/</link>
      <title>.NET Job Scheduling ‚Äî Choosing the Right Framework</title>
      <pubDate>Tue, 16 Dec 2025 17:00:00 +0100</pubDate>
      <description>Synthesizing the series into actionable guidance with feature comparisons, suitability ratings, and decision frameworks.
Select the scheduler that matches your operational model, infrastructure constraints, and team priorities.</description>
      <category>architecture</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>nuget</category>
      <category>softwareengineering</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/dotnet-job-scheduling-6-tickerq/</guid>
      <link>https://daily-devops.net/posts/dotnet-job-scheduling-6-tickerq/</link>
      <title>.NET Job Scheduling ‚Äî TickerQ and Modern Architecture</title>
      <pubDate>Thu, 11 Dec 2025 17:00:00 +0100</pubDate>
      <description>TickerQ represents the next generation of .NET schedulers with compile-time validation, reflection-free execution, and SignalR-powered monitoring.
Understand when modern architecture patterns and performance optimizations justify adopting newer frameworks over established alternatives.</description>
      <category>architecture</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>nuget</category>
      <category>softwareengineering</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/dotnet-power-of-ten-rules/</guid>
      <link>https://daily-devops.net/posts/dotnet-power-of-ten-rules/</link>
      <title>Power of Ten Rules: More Relevant Than Ever for .NET</title>
      <pubDate>Wed, 10 Dec 2025 16:45:00 +0100</pubDate>
      <description>Gerard Holzmann‚Äôs Power of Ten rules prevented spacecraft failures and exposed Toyota‚Äôs fatal throttle bugs. Four rules transfer directly to C# with superior enforcement. Three become irrelevant thanks to the managed runtime.
The verdict: These principles aren‚Äôt just valid. They‚Äôre finally enforceable without heroic manual effort.
</description>
      <category>bestpractices</category>
      <category>codequality</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>softwareengineering</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/aks-network-policies-zero-trust/</guid>
      <link>https://daily-devops.net/posts/aks-network-policies-zero-trust/</link>
      <title>AKS Network Policies: The Security Layer Your Cluster Is Missing</title>
      <pubDate>Wed, 10 Dec 2025 11:45:00 +0100</pubDate>
      <description>Network segmentation is a fundamental security control for modern Kubernetes environments. AKS supports multiple networking models such as kubenet, Azure CNI, and overlay CNIs. The networking model matters, but the decisive factor for enforcing isolation and compliance is the consistent application of network policies.
This article describes how network policies work in AKS, the available engines, practical examples, and recommended practices for enforcing a zero-trust posture within a cluster.
</description>
      <category>azure</category>
      <category>cloud</category>
      <category>kubernetes</category>
      <category>networking</category>
      <category>platform-engineering</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/dotnet-job-scheduling-5-ncronjob/</guid>
      <link>https://daily-devops.net/posts/dotnet-job-scheduling-5-ncronjob/</link>
      <title>.NET Job Scheduling ‚Äî NCronJob and Native Minimalism</title>
      <pubDate>Tue, 09 Dec 2025 17:00:00 +0100</pubDate>
      <description>NCronJob leverages IHostedService for lightweight scheduling with zero external dependencies.
Understand when minimal infrastructure and native ASP.NET Core integration outweigh advanced features for cloud-native architectures.</description>
      <category>architecture</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>nuget</category>
      <category>softwareengineering</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/dotnet-job-scheduling-4-coravel/</guid>
      <link>https://daily-devops.net/posts/dotnet-job-scheduling-4-coravel/</link>
      <title>.NET Job Scheduling ‚Äî Coravel and Fluent Simplicity</title>
      <pubDate>Thu, 04 Dec 2025 17:00:00 +0100</pubDate>
      <description>Coravel prioritizes developer velocity with fluent APIs, zero infrastructure, and integrated features like queuing and caching.
Understand when convenience and rapid iteration trump persistence and clustering for practical application development.</description>
      <category>architecture</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>nuget</category>
      <category>softwareengineering</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/aks-networking-clash/</guid>
      <link>https://daily-devops.net/posts/aks-networking-clash/</link>
      <title>AKS Networking Clash: kubenet vs. CNI vs. CNI Overlay</title>
      <pubDate>Wed, 03 Dec 2025 11:45:00 +0100</pubDate>
      <description>Selecting the right network model is arguably one of the most critical architectural decisions you will make when deploying a Kubernetes cluster on Azure Kubernetes Service (AKS). This choice ripples through nearly every aspect of your cluster‚Äôs lifecycle, influencing how pods communicate, how efficiently you use your IP address space, which Azure services integrate seamlessly with your workloads, and ultimately, how well your infrastructure scales to meet future demands. It affects scalability, security posture, operational cost, performance characteristics, available integration options, and your long-term operational flexibility.
</description>
      <category>azure</category>
      <category>cloud</category>
      <category>kubernetes</category>
      <category>networking</category>
      <category>platform-engineering</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/dotnet-job-scheduling-3-quartznet/</guid>
      <link>https://daily-devops.net/posts/dotnet-job-scheduling-3-quartznet/</link>
      <title>.NET Job Scheduling ‚Äî Quartz.NET for Enterprise Scale</title>
      <pubDate>Tue, 02 Dec 2025 17:00:00 +0100</pubDate>
      <description>Quartz.NET provides advanced scheduling semantics, database-backed clustering, and flexible storage for systems demanding complex workflows.
Understand when enterprise features justify operational complexity and how Quartz.NET scales across distributed deployments.</description>
      <category>architecture</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>nuget</category>
      <category>softwareengineering</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/dotnet-job-scheduling-2-hangfire/</guid>
      <link>https://daily-devops.net/posts/dotnet-job-scheduling-2-hangfire/</link>
      <title>.NET Job Scheduling ‚Äî Hangfire and Persistent Reliability</title>
      <pubDate>Thu, 27 Nov 2025 17:00:00 +0100</pubDate>
      <description>Hangfire combines persistent job storage, automatic retries, and real-time monitoring to simplify background processing.
Learn when database-backed reliability matters and how Hangfire scales from single instances to distributed workers.</description>
      <category>architecture</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>nuget</category>
      <category>softwareengineering</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/dotnet-job-scheduling-1-landscape/</guid>
      <link>https://daily-devops.net/posts/dotnet-job-scheduling-1-landscape/</link>
      <title>.NET Job Scheduling ‚Äî The Landscape</title>
      <pubDate>Tue, 25 Nov 2025 17:00:00 +0100</pubDate>
      <description>Explore the spectrum of .NET job scheduling from lightweight in-memory solutions to enterprise-grade distributed systems.
Understand which approach fits your operational model and why background processing architecture matters.</description>
      <category>architecture</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>nuget</category>
      <category>softwareengineering</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/healthchecks-5-0/</guid>
      <link>https://daily-devops.net/posts/healthchecks-5-0/</link>
      <title>NetEvolve.HealthChecks 5.0: 27+ Targeted Probes, Zero Boilerplate</title>
      <pubDate>Thu, 20 Nov 2025 23:00:00 +0100</pubDate>
      <description>NetEvolve.HealthChecks 5.0 is a decisive expansion‚Äîbroader coverage scope, less boilerplate.
New domain‚Äëspecific packages extend monitoring across cloud services, messaging platforms, graph, time‚Äëseries, vector and AI backends. In parallel, the former inheritance‚Äëdriven shared base library (abstract classes + repetitive DI wiring) was replaced by purpose-built source generators‚Äîremoving manual registration churn and consolidating intent. Release 5.0 also formalizes full support for .NET 10‚Äîaligning with current trimming and analyzer improvements.
</description>
      <category>csharp</category>
      <category>dotnet</category>
      <category>netevolve</category>
      <category>nuget</category>
      <category>performance</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/dotnet-10-testing/</guid>
      <link>https://daily-devops.net/posts/dotnet-10-testing/</link>
      <title>.NET 10 Testing: Microsoft Finally Fixed the Test Runner (Mostly)</title>
      <pubDate>Thu, 20 Nov 2025 17:00:00 +0100</pubDate>
      <description>.NET 10 replaces VSTest with Microsoft.Testing.Platform, bringing SDK-integrated testing with faster discovery, consistent behavior across environments, and explicit configuration contracts. But it requires .NET 10, breaks old test adapters, and demands CI pipeline discipline. Here‚Äôs what actually changes, who should migrate now, and who should wait.</description>
      <category>csharp</category>
      <category>devops</category>
      <category>dotnet</category>
      <category>github-actions</category>
      <category>softwareengineering</category>
      <category>testing</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/code-metrics-configuration/</guid>
      <link>https://daily-devops.net/posts/code-metrics-configuration/</link>
      <title>Code Metrics and Configuration: Beyond the Numbers Game</title>
      <pubDate>Tue, 18 Nov 2025 17:00:00 +0100</pubDate>
      <description>Code metrics have become a standard feature in modern development environments, yet their implementation and interpretation often leave much to be desired. While Visual Studio and .NET provide comprehensive code metrics analysis, the way these metrics are configured, presented, and (more critically) acted upon reveals a fundamental disconnect between measurement and meaningful improvement.
What code metrics actually measure, how to configure them properly, and (more importantly) why blindly following thresholds without understanding context is, frankly, a recipe for misguided refactoring efforts that waste your team‚Äôs time and actively damage your codebase.
</description>
      <category>bestpractices</category>
      <category>codequality</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>softwareengineering</category>
      <category>visualstudio</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/dotnet-10-released/</guid>
      <link>https://daily-devops.net/posts/dotnet-10-released/</link>
      <title>.NET 10: Boring by Design, Reliable by Default</title>
      <pubDate>Thu, 13 Nov 2025 18:00:00 +0100</pubDate>
      <description>Microsoft wants you to believe .NET 10 is boring. They‚Äôre right ‚Äî and that‚Äôs the best news we‚Äôve had in years.
.NET 10 is here, and for once, Microsoft didn‚Äôt oversell it. LTS support through 2028, JIT improvements that actually matter, and C# 14 features that won‚Äôt rewrite your architecture. Here‚Äôs what you need to know before migrating.
</description>
      <category>architecture</category>
      <category>codequality</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>microsoft</category>
      <category>performance</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/timing-is-the-new-technical-debt/</guid>
      <link>https://daily-devops.net/posts/timing-is-the-new-technical-debt/</link>
      <title>.NET 10: Timing Is the New Technical Debt</title>
      <pubDate>Wed, 12 Nov 2025 18:00:00 +0100</pubDate>
      <description>2025 reshapes the .NET ecosystem with faster release cycles and shared responsibility. Discover why migrating to .NET 10 by Q1 2026 ‚Äî and supporting your dependencies ‚Äî turns timing into sustainable ROI.</description>
      <category>architecture</category>
      <category>bestpractices</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>performance</category>
      <category>technicaldebt</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/dotnet-10-release-cycle-paradox/</guid>
      <link>https://daily-devops.net/posts/dotnet-10-release-cycle-paradox/</link>
      <title>.NET 10 and the Release Cycle Paradox</title>
      <pubDate>Tue, 11 Nov 2025 16:30:00 +0100</pubDate>
      <description>.NET‚Äôs yearly rhythm has become a symbol of stability ‚Äî yet also a source of pressure. The release cycle paradox describes the tension between predictability and exhaustion: a release schedule that keeps the ecosystem healthy, but teams constantly catching up.
With .NET 10 on the horizon, developers must learn to navigate this rhythm rather than fight it.
</description>
      <category>architecture</category>
      <category>bestpractices</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>softwareengineering</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/proper-use-of-targetframework-conditions/</guid>
      <link>https://daily-devops.net/posts/proper-use-of-targetframework-conditions/</link>
      <title>Stop Breaking Multi-Targeting Builds with String Comparisons</title>
      <pubDate>Thu, 06 Nov 2025 17:30:00 +0100</pubDate>
      <description>String-based TargetFramework conditions fail silently in multi-targeting builds. IsTargetFrameworkCompatible() understands framework semantics and prevents production nightmares.</description>
      <category>bestpractices</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>msbuild</category>
      <category>softwareengineering</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/modern-defensive-programming/</guid>
      <link>https://daily-devops.net/posts/modern-defensive-programming/</link>
      <title>Modern Defensive Programming in .NET ‚Äî Unified Throw-Helpers and Multi-Framework Compatibility</title>
      <pubDate>Mon, 03 Nov 2025 18:00:00 +0200</pubDate>
      <description>Modern .NET introduces powerful throw-helper methods such as ArgumentNullException.ThrowIfNull and ArgumentException.ThrowIfNullOrEmpty to simplify defensive programming. However, many projects still target older frameworks where these APIs are missing. This article explores how the NetEvolve.Arguments library delivers a unified, backward-compatible API that brings modern guard clause patterns to every .NET version, ensuring consistent validation, maintainability, and multi-framework compatibility.</description>
      <category>csharp</category>
      <category>dotnet</category>
      <category>netevolve</category>
      <category>nuget</category>
      <category>softwareengineering</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/tests-are-lying/</guid>
      <link>https://daily-devops.net/posts/tests-are-lying/</link>
      <title>Your Tests Are Lying ‚Äî Mutation Testing in .NET</title>
      <pubDate>Thu, 30 Oct 2025 18:00:00 +0200</pubDate>
      <description>It begins like many stories in software: a well-intentioned developer joining a project, determined to do things properly. You arrive at a codebase that has grown organically, perhaps even chaotically. You decide you will bring order. You set up unit testing, you configure continuous integration, you measure code coverage. You write dozens or hundreds of tests. Every public method is touched, every branch is at least executed. The dashboard lights up green. You feel, quite frankly, on top of things.
Then one day, production breaks under your watch
</description>
      <category>csharp</category>
      <category>dotnet</category>
      <category>nuget</category>
      <category>technicaldebt</category>
      <category>testing</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/nuget-packagedownload-functionality/</guid>
      <link>https://daily-devops.net/posts/nuget-packagedownload-functionality/</link>
      <title>PackageDownload: NuGet&#39;s Forgotten Power Tool</title>
      <pubDate>Wed, 29 Oct 2025 18:00:00 +0100</pubDate>
      <description>PackageDownload arrived in NuGet 4.8 to solve a niche but genuine problem: downloading packages without adding assembly references. It works. But its version syntax requirements and complete disregard for Central Package Management reveal the messy reality of platform evolution.</description>
      <category>bestpractices</category>
      <category>dependency-management</category>
      <category>dotnet</category>
      <category>msbuild</category>
      <category>nuget</category>
      <category>technicaldebt</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/netevolve-healthchecks/</guid>
      <link>https://daily-devops.net/posts/netevolve-healthchecks/</link>
      <title>Configuration-First Health Checks for Modern .NET</title>
      <pubDate>Tue, 28 Oct 2025 18:00:00 +0200</pubDate>
      <description>Let‚Äôs be honest: health checks are the broccoli of .NET projects. Everyone says they have them, but nobody‚Äôs excited to eat their greens. What starts as a humble SELECT 1 in a try/catch quickly explodes into a wild jungle of scripts, copy-pasted connection strings, and endpoints that only half the team remembers. Sure, it works‚Äîuntil it doesn‚Äôt. And when it breaks, it‚Äôs never at a good time.
</description>
      <category>csharp</category>
      <category>dotnet</category>
      <category>netevolve</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/compositeformat-performance-boost/</guid>
      <link>https://daily-devops.net/posts/compositeformat-performance-boost/</link>
      <title>Stop Parsing the Same String Twice: CompositeFormat in .NET</title>
      <pubDate>Thu, 23 Oct 2025 17:00:00 +0200</pubDate>
      <description>Every time you call string.Format() with the same format string, .NET parses it again. And again. And again. CompositeFormat changes that: parse once, reuse forever. The result? Up to 30% faster formatting, fewer allocations, and a one-line code change. Here‚Äôs why this matters and how to use it.</description>
      <category>bestpractices</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>hidden-gems</category>
      <category>performance</category>
      <category>softwareengineering</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/searchvalues-saved-us-from-scaling-hell/</guid>
      <link>https://daily-devops.net/posts/searchvalues-saved-us-from-scaling-hell/</link>
      <title>How SearchValues&lt;T&gt; Saved Us From Scaling Hell</title>
      <pubDate>Mon, 20 Oct 2025 17:30:00 +0100</pubDate>
      <description>While you‚Äôre busy optimizing database queries and adding cache layers, thousands of string searches per second are quietly eating your CPU budget. The problem isn‚Äôt visible in your APM dashboard because it‚Äôs distributed across every request. But it‚Äôs there. Compounding. Scaling linearly with load.
I discovered this the hard way when a log processing API started choking under production traffic. The bottleneck? String validation and sanitization. The fix? A .NET 8 feature that delivered a 5x performance improvement and let us shut down servers instead of adding them. And it‚Äôs gotten even better in .NET 9 and 10.
</description>
      <category>bestpractices</category>
      <category>codequality</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>hidden-gems</category>
      <category>performance</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/clean-code-lip-service-not-a-standard/</guid>
      <link>https://daily-devops.net/posts/clean-code-lip-service-not-a-standard/</link>
      <title>Clean Code: A Lip Service, Not a Standard</title>
      <pubDate>Thu, 16 Oct 2025 13:00:00 +0200</pubDate>
      <description>Clean Code is often praised but rarely practiced effectively. This article explores how misunderstood ideals and over-engineering harm .NET systems, how to recognize such failures early, and which C# best practices and official guidelines truly support maintainable software.</description>
      <category>bestpractices</category>
      <category>codequality</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>softwareengineering</category>
      <category>technicaldebt</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/constant-expected-attribute/</guid>
      <link>https://daily-devops.net/posts/constant-expected-attribute/</link>
      <title>ConstantExpectedAttribute: Unlocking Performance Through Compiler Awareness</title>
      <pubDate>Tue, 14 Oct 2025 14:30:00 +0200</pubDate>
      <description>The ConstantExpectedAttribute, introduced in .NET 7, provides a powerful mechanism to signal compiler expectations about constant values. This enables better performance optimizations, enhanced IDE tooling, and clearer API contracts. Learn how to leverage this attribute to build more efficient and maintainable .NET applications.</description>
      <category>bestpractices</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>performance</category>
      <category>softwareengineering</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/retiring-legacy-dotnet-projects/</guid>
      <link>https://daily-devops.net/posts/retiring-legacy-dotnet-projects/</link>
      <title>Retiring Legacy .NET Projects ‚Äî Balancing Risk, Cost, and Forward Value</title>
      <pubDate>Mon, 13 Oct 2025 11:30:00 +0200</pubDate>
      <description>In every mature .NET landscape, legacy projects represent both heritage and hazard. They once powered entire business models ‚Äî now they silently consume time, budget, and attention. The decision to retire or modernize them isn‚Äôt about technology fashion. It‚Äôs about sustaining the organization‚Äôs capacity for value creation.
</description>
      <category>architecture</category>
      <category>bestpractices</category>
      <category>dotnet</category>
      <category>rcda</category>
      <category>softwareengineering</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/tunit-a-pragmatic-evaluation-for-dotnet-teams/</guid>
      <link>https://daily-devops.net/posts/tunit-a-pragmatic-evaluation-for-dotnet-teams/</link>
      <title>TUnit ‚Äî A Pragmatic Evaluation for .NET Teams</title>
      <pubDate>Thu, 09 Oct 2025 11:30:00 +0200</pubDate>
      <description>TUnit brings compile-time test discovery and native AOT support to .NET testing ‚Äî but is it ready for enterprise adoption? A pragmatic analysis of performance gains, tooling maturity, and migration timing for teams evaluating alternatives to MSTest, xUnit, and NUnit.</description>
      <category>architecture</category>
      <category>bestpractices</category>
      <category>dotnet</category>
      <category>performance</category>
      <category>rcda</category>
      <category>softwareengineering</category>
      <category>testing</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/still-waiting-for-the-final-piece/</guid>
      <link>https://daily-devops.net/posts/still-waiting-for-the-final-piece/</link>
      <title>Still Waiting for the Final Piece: When C# 14 Comes Close, But Not Quite There</title>
      <pubDate>Mon, 06 Oct 2025 09:00:00 +0200</pubDate>
      <description>C# 14 introduces the new ‚ÄòExtension Everything‚Äô syntax‚Äîan elegant step toward more expressive code, yet one that still can‚Äôt quite match VB.NET‚Äôs classic ByRef magic. A humorous reflection on what‚Äôs almost, but not fully, possible in .NET 10.</description>
      <category>csharp</category>
      <category>dotnet</category>
      <category>extensions</category>
      <category>hidden-gems</category>
      <category>vbnet</category>
      <category>visualstudio</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/extended-dotnet-sts-support-timeframe/</guid>
      <link>https://daily-devops.net/posts/extended-dotnet-sts-support-timeframe/</link>
      <title>The Generous Gift? Microsoft Extends .NET STS Support to 24 Months</title>
      <pubDate>Tue, 30 Sep 2025 11:30:00 +0200</pubDate>
      <description>Microsoft has extended .NET STS support from 18 to 24 months. A genuine gift to developers or just catching up with reality? Let‚Äôs analyze what this means for your development planning.</description>
      <category>dotnet</category>
      <category>microsoft</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/dotnet10rc1-is-knocking-at-the-door/</guid>
      <link>https://daily-devops.net/posts/dotnet10rc1-is-knocking-at-the-door/</link>
      <title>.NET 10 RC 1 is Knocking at the Door: Architectural Impact, C# 14, and Performance</title>
      <pubDate>Wed, 10 Sep 2025 09:00:00 +0200</pubDate>
      <description>.NET¬†10 RC¬†1 is knocking at the door, marking the first release candidate and offering the .NET community a detailed preview of what‚Äôs to come in the next LTS cycle. While not the final release, RC¬†1 is ‚Äúgo-live‚Äù supported and represents the feature-complete platform that will soon become .NET¬†10 LTS. In this article, I‚Äôll try to give a rough overview of the architectural impact of .NET¬†10 RC¬†1, focusing on the latest C#¬†14 features, under-the-hood performance improvements, and strategic considerations for the upcoming LTS.
</description>
      <category>architecture</category>
      <category>csharp</category>
      <category>dotnet</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/visual-studio-2026/</guid>
      <link>https://daily-devops.net/posts/visual-studio-2026/</link>
      <title>Visual Studio 2026 - Why AI-Native Tooling Will Matter</title>
      <pubDate>Wed, 10 Sep 2025 01:00:00 +0200</pubDate>
      <description>Let‚Äôs skip the typical release-cycle enthusiasm for a second: Most IDE updates come and go. New features, some refactoring helpers, a bit of polish, then back to business as usual. Visual Studio 2026 is different. For once, the promise of ‚ÄúAI-native‚Äù isn‚Äôt just marketing. If Microsoft lands even half of what they‚Äôre previewing, it‚Äôs going to matter‚Äîa lot.
</description>
      <category>csharp</category>
      <category>dotnet</category>
      <category>visualstudio</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/buzzword-driven-development/</guid>
      <link>https://daily-devops.net/posts/buzzword-driven-development/</link>
      <title>Buzzword-Driven Development vs. Fundamental Software Quality</title>
      <pubDate>Wed, 23 Jul 2025 17:00:00 +0200</pubDate>
      <description>Explore why fundamental software quality practices in .NET must never be overlooked for trendy buzzwords, including recommended analyzers and project settings for managing technical debt effectively.</description>
      <category>ai-code-assistant</category>
      <category>bestpractices</category>
      <category>codequality</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>nuget</category>
      <category>softwareengineering</category>
      <category>technicaldebt</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/instruction-by-design/</guid>
      <link>https://daily-devops.net/posts/instruction-by-design/</link>
      <title>Instruction by Design: Transforming ADRs into Actionable AI Guidance</title>
      <pubDate>Tue, 15 Jul 2025 10:30:00 +0200</pubDate>
      <description>Discover how to transform architectural decision records (ADRs) into actionable, AI-ready guidance for teams and copilots‚Äîboosting consistency, onboarding, and automation in your development workflow.</description>
      <category>ai-code-assistant</category>
      <category>architecture</category>
      <category>bestpractices</category>
      <category>github</category>
      <category>github-copilot</category>
      <category>rcda</category>
      <category>softwareengineering</category>
      <category>technicaldebt</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/copilot-without-becoming-its-puppet/</guid>
      <link>https://daily-devops.net/posts/copilot-without-becoming-its-puppet/</link>
      <title>How to Use Copilot Without Becoming Its Puppet</title>
      <pubDate>Wed, 14 May 2025 17:30:00 +0200</pubDate>
      <description>In a previous article, we laid it out ‚Äì unfiltered: Copilot turns junior devs into syntax secretaries.
Not because it‚Äôs evil. But because it removes friction before understanding.
It gives you working code before you know what working even means. It creates the illusion of progress, while slowly eroding the very skills that define a software engineer: reasoning, decision-making, and technical ownership.
</description>
      <category>ai-code-assistant</category>
      <category>bestpractices</category>
      <category>dotnet</category>
      <category>github</category>
      <category>github-copilot</category>
      <category>testing</category>
      <category>visualstudio</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/copilot-turns-junior-devs-into-syntax-secretaries/</guid>
      <link>https://daily-devops.net/posts/copilot-turns-junior-devs-into-syntax-secretaries/</link>
      <title>Copilot Turns Junior Devs Into Syntax Secretaries</title>
      <pubDate>Tue, 13 May 2025 17:30:00 +0200</pubDate>
      <description>The hype around GitHub Copilot (or any other AI code assistant) is deafening. AI-assisted coding. Effortless automation. 10x productivity.
But here‚Äôs the harsh truth: Copilot isn‚Äôt empowering junior developers ‚Äì it‚Äôs deskilling them.
</description>
      <category>ai-code-assistant</category>
      <category>bestpractices</category>
      <category>dotnet</category>
      <category>github</category>
      <category>github-copilot</category>
      <category>testing</category>
      <category>visualstudio</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/vibe-coding-isnt-wrong-its-unfinished/</guid>
      <link>https://daily-devops.net/posts/vibe-coding-isnt-wrong-its-unfinished/</link>
      <title>Vibe Coding in .NET: Creative Catalyst or Maintenance Risk?</title>
      <pubDate>Wed, 07 May 2025 12:00:00 +0200</pubDate>
      <description>In the world of software development, there‚Äôs a recurring tension between discipline and improvisation. Somewhere along that spectrum lies a phenomenon increasingly referred to as Vibe Coding. The term evokes a style of development where engineers follow intuition and momentum rather than formal plans, processes, or design patterns.
It‚Äôs fast, fluid, and occasionally brilliant. But is it sustainable in a .NET-based enterprise context?
</description>
      <category>bestpractices</category>
      <category>codequality</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>softwareengineering</category>
      <category>technicaldebt</category>
      <category>testing</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/understanding-csharp-stringvalues/</guid>
      <link>https://daily-devops.net/posts/understanding-csharp-stringvalues/</link>
      <title>Understanding the C# `StringValues`: A Comprehensive Guide</title>
      <pubDate>Mon, 30 Dec 2024 16:00:00 +0100</pubDate>
      <description>In C#, the StringValues struct belongs to the Microsoft.Extensions.Primitives namespace, which is widely used in modern .NET applications. This struct plays a crucial role in efficiently managing string collections, especially when handling efficiently, particularly in contexts where multiple strings are involved. In this blog post, we‚Äôll explore the purpose, usage, and key features of the StringValues struct in C#.
</description>
      <category>csharp</category>
      <category>dotnet</category>
      <category>hidden-gems</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/managing-errors-warnings-and-configurations/</guid>
      <link>https://daily-devops.net/posts/managing-errors-warnings-and-configurations/</link>
      <title>Managing Errors, Warnings, and Configurations in C# and .NET</title>
      <pubDate>Mon, 23 Dec 2024 16:00:00 +0100</pubDate>
      <description>When we activated static code analysis for the first time in one of my last projects, the overwhelming number of warnings exceeded expectations and highlighted gaps in the code. Without making any changes, the project already had a significant number of warnings. After activating additional analyzers and updating some configurations, this number temporarily increased dramatically.
The high number of warnings was initially daunting, but we saw it as an opportunity to significantly improve our code quality. At first glance, it seemed easier to suppress or ignore these warnings. But as I often remind my team, ‚ÄúThe code you create is a valuable legacy, so it‚Äôs important to build it carefully.‚Äù Ignoring warnings today creates obstacles for future developers‚Äîand that could very well include you six months down the line.
This experience reinforced the importance of managing warnings and errors systematically. Let me share some of the lessons we learned, the strategies we used to tame those 60,000 warnings, and how you can apply these techniques to your own projects.
</description>
      <category>bestpractices</category>
      <category>codequality</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>msbuild</category>
      <category>softwareengineering</category>
      <category>technicaldebt</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/tale-of-forgotten-pennies-and-lost-dollars/</guid>
      <link>https://daily-devops.net/posts/tale-of-forgotten-pennies-and-lost-dollars/</link>
      <title>A Tale of Forgotten Pennies and Lost Dollars</title>
      <pubDate>Fri, 22 Nov 2024 16:45:00 +0100</pubDate>
      <description>In software development, there‚Äôs a silent debt that accrues interest over time, often hidden beneath layers of code and decisions made in haste or ignorance. This debt is aptly termed technical debt. Much like the german proverb, ‚ÄúWer den Pfennig nicht ehrt, ist den Taler nicht wert‚Äù, (or the english equivalent, ‚ÄúA penny saved is a penny earned‚Äù) technical debt reminds us that small oversights or compromises in the present can snowball into significant challenges down the road. This article critically examines the parallels between financial principles and technical debt, emphasizing the importance of addressing both direct and indirect debt while understanding its distinction from external risks such as hacking or abuse.
</description>
      <category>bestpractices</category>
      <category>dependency-management</category>
      <category>rcda</category>
      <category>softwareengineering</category>
      <category>technicaldebt</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/dependamerge-action/</guid>
      <link>https://daily-devops.net/posts/dependamerge-action/</link>
      <title>Master dependency management with automation: story behind `dependamerge`</title>
      <pubDate>Wed, 13 Nov 2024 09:00:00 +0100</pubDate>
      <description>In software development, dependencies are inevitable - any project worth its salt relies on various libraries, frameworks, or packages. However, as I found in my own work, managing these dependencies can be an onerous task. Constant updates, new vulnerabilities, and endless manual approvals were draining my time and focus. What if, I thought, these processes could be automated? This thought led to the creation of dependamerge, a GitHub Action designed to free developers from the drudgery of manual dependency maintenance and let us get back to what we do best: building great software.
</description>
      <category>bestpractices</category>
      <category>dependency-management</category>
      <category>github</category>
      <category>github-actions</category>
      <category>nuget</category>
      <category>technicaldebt</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/introducing-nullability-in-legacy-code/</guid>
      <link>https://daily-devops.net/posts/introducing-nullability-in-legacy-code/</link>
      <title>Gradually Introducing Nullability in Legacy Code: A Practical Guide for .NET and C#</title>
      <pubDate>Mon, 07 Oct 2024 17:15:00 +0200</pubDate>
      <description>As developers, we‚Äôre often tasked with maintaining and modernizing legacy codebases that were written long before some of the best practices of today‚Äîsuch as nullability annotations‚Äîwere available. While modern C# now supports nullable reference types, enabling us to avoid the dreaded NullReferenceException, introducing this feature to existing, large codebases can be a challenge.
In this article, I‚Äôll share my step-by-step approach for introducing nullability into a legacy .NET and C# project. You‚Äôll learn how to apply nullability in a controlled, incremental manner using project-level settings, scoped annotations, and file/method-level directives, all while maintaining the integrity of your legacy codebase. After all, modernizing your code doesn‚Äôt have to be an all-or-nothing endeavor‚Äîgradual change is key to a successful transition. Let‚Äôs get started!
</description>
      <category>bestpractices</category>
      <category>codequality</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>softwareengineering</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/buildinginsidevisualstudio/</guid>
      <link>https://daily-devops.net/posts/buildinginsidevisualstudio/</link>
      <title>Mastering .NET Project Properties: The `BuildingInsideVisualStudio` Flag</title>
      <pubDate>Tue, 10 Sep 2024 17:00:00 +0200</pubDate>
      <description>In the ever-evolving world of .NET development, managing project configurations effectively is crucial for maintaining a clean and efficient build process. One of the less frequently discussed but highly useful properties is BuildingInsideVisualStudio. This property, when correctly utilized, can streamline your build process and ensure that your project is configured properly depending on the build environment. In this article, we‚Äôll explore the BuildingInsideVisualStudio property with concrete examples and discuss best practices for using it effectively.
</description>
      <category>bestpractices</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>hidden-gems</category>
      <category>msbuild</category>
      <category>visualstudio</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/reimagining-the-microsoft-certification-exam-ui/</guid>
      <link>https://daily-devops.net/posts/reimagining-the-microsoft-certification-exam-ui/</link>
      <title>Reimagining the Microsoft Certification Exam UI Experience</title>
      <pubDate>Thu, 14 Mar 2024 09:00:00 +0100</pubDate>
      <description>Embark on a journey through Microsoft‚Äôs redesigned certification exam UI. Discover streamlined navigation, enhanced accessibility, and personalized experiences, revolutionizing the exam-taking experience.</description>
      <category>azure</category>
      <category>certification</category>
      <category>microsoft</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/manage-nuget-packages-centrally/</guid>
      <link>https://daily-devops.net/posts/manage-nuget-packages-centrally/</link>
      <title>Manage NuGet Packages Centrally</title>
      <pubDate>Mon, 17 Apr 2023 08:30:00 +0200</pubDate>
      <description>For over 12 years, NuGet package management has been part of the .NET ecosystem with direct integrations to various IDEs, CLIs and build systems. But a feature took 12 years before it appeared and certainly needs some more maintenance until it is mature!
</description>
      <category>bestpractices</category>
      <category>csharp</category>
      <category>dependency-management</category>
      <category>dotnet</category>
      <category>hidden-gems</category>
      <category>nuget</category>
      <category>technicaldebt</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/illuminate-technical-debt/</guid>
      <link>https://daily-devops.net/posts/illuminate-technical-debt/</link>
      <title>Illuminate Technical Debt</title>
      <pubDate>Wed, 12 Apr 2023 17:00:00 +0200</pubDate>
      <description>Whatever our role, be it developer, IT professional or architect, we try to avoid technical debt. If this is not possible from the outset, or if we decide to accept this technical debt for a limited period of time, we usually lack the tools to do so. This is where this article may help.
</description>
      <category>azuredevops</category>
      <category>extensions</category>
      <category>rcda</category>
      <category>technicaldebt</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/when-can-i-finally-renew-my-microsoft-certification/</guid>
      <link>https://daily-devops.net/posts/when-can-i-finally-renew-my-microsoft-certification/</link>
      <title>When Can I Finally Renew My Microsoft Certification</title>
      <pubDate>Tue, 11 Apr 2023 09:00:00 +0200</pubDate>
      <description>When can I finally renew my Microsoft certification? - I‚Äôm certainly not alone with this or similar questions and the associated uncertainty. Okay, a certain impatience certainly resonates as well. After all, I would also like to schedule it into my daily routine. But how?
</description>
      <category>azure</category>
      <category>certification</category>
      <category>microsoft</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/how-to-prepare-for-microsoft-certification/</guid>
      <link>https://daily-devops.net/posts/how-to-prepare-for-microsoft-certification/</link>
      <title>How to Prepare for Microsoft Certification</title>
      <pubDate>Fri, 27 Jan 2023 21:00:00 +0100</pubDate>
      <description>How do I best prepare for a Microsoft certification? - this or a similar question is asked by everyone who wants to deal with the topics Microsoft, Azure, Microsoft 365, Power Platform or Dynamics 365. In this article, I would like to go into the possibilities that Microsoft offers us for preparation.
</description>
      <category>azure</category>
      <category>certification</category>
      <category>microsoft</category>
    </item>
  </channel>
</rss>
