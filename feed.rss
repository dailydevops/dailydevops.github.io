<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Daily DevOps &amp; .NET - Where Code Meets Culture on Daily DevOps &amp; .NET</title>
    <link>https://daily-devops.net/</link>
    <description>Recent content in Daily DevOps &amp; .NET - Where Code Meets Culture on Daily DevOps &amp; .NET</description>
    <language>en</language>
    <lastBuildDate>Thu, 22 Jan 2026 15:04:57 +0000</lastBuildDate>
    <atom:link type="application/rss+xml" href="https://daily-devops.net/feed.rss" hreflang="en" rel="self"/>
    <atom:link type="text/html" href="https://daily-devops.net/" hreflang="en" rel="alternate"/>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/pod-identity-access-control-aks/</guid>
      <link>https://daily-devops.net/posts/pod-identity-access-control-aks/</link>
      <title>Pod Identity &amp; Access Control in AKS: What Actually Breaks</title>
      <pubDate>Wed, 21 Jan 2026 17:00:00 +0100</pubDate>
      <description>Traditional AKS authentication relied on service principals and mounted secrets. Workload Identity Federation eliminates credential lifecycle problems, but introduces new failure modes. This article covers the operational realities: where credentials still leak, how RBAC layers compound across Kubernetes and Azure, and validation patterns that prevent identity failures in production.</description>
      <category>azure</category>
      <category>cloud</category>
      <category>devops</category>
      <category>identity</category>
      <category>kubernetes</category>
      <category>rbac</category>
      <category>security</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/real-professional-software-engineering-ai-era/</guid>
      <link>https://daily-devops.net/posts/real-professional-software-engineering-ai-era/</link>
      <title>Real Professional Software Engineering in the AI Era</title>
      <pubDate>Tue, 20 Jan 2026 17:00:00 +0100</pubDate>
      <description>Throughout this series, we&amp;rsquo;ve established that AI-generated code without understanding creates productivity illusions that collapse in production (Part 1), and that &lt;strong&gt;the feedback loop&lt;/strong&gt; between code and realityâ€”compilation, testing, profiling, productionâ€”sharpens thinking in ways AI can&amp;rsquo;t replicate (Part 2). Now we confront the practical question: What defines professional software engineering when code generation becomes trivial? This final part examines the irreplaceable skillset: understanding execution characteristics (recognizing allocation patterns that cause GC pressure before deployment), asking questions AI can&amp;rsquo;t formulate (What&amp;rsquo;s the failure mode when this service is unavailable?), recognizing when plausible AI solutions diverge from correct ones, debugging production failures AI has no execution model to reason about, and evaluating maintainability for code that becomes tomorrow&amp;rsquo;s burden. We explore why prompt engineering optimizes for speed while architecture optimizes for survival, why &amp;ldquo;AI productivity&amp;rdquo; often means faster technical debt accumulation, and why the economic reality favors organizations that measure system reliability over lines of code generated. The feedback loop can&amp;rsquo;t be automated because closing it requires learning from production failures and applying that knowledge to prevent future onesâ€”the irreplaceable discipline that defines real professionals in 2026 and beyond.</description>
      <category>ai-code-assistant</category>
      <category>architecture</category>
      <category>bestpractices</category>
      <category>codequality</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>github-copilot</category>
      <category>softwareengineering</category>
      <category>technicaldebt</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/stossluften-and-software-systems/</guid>
      <link>https://daily-devops.net/posts/stossluften-and-software-systems/</link>
      <title>StoÃŸlÃ¼ften: The Architecture of Intentional Resets</title>
      <pubDate>Fri, 16 Jan 2026 11:30:00 +0100</pubDate>
      <description>A Swabian habit teaches a DevOps lesson: open windows fully and often, or invisible decay accumulates. StoÃŸlÃ¼ften isn&amp;rsquo;t about comfortâ€”it&amp;rsquo;s about forcing systems to prove they&amp;rsquo;re healthy. Regular restarts, infrastructure-as-code, and reproducibility checks catch the problems that green metrics miss.</description>
      <category>architecture</category>
      <category>devops</category>
      <category>reliability</category>
      <category>technicaldebt</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/feedback-loop-ai-cant-replace/</guid>
      <link>https://daily-devops.net/posts/feedback-loop-ai-cant-replace/</link>
      <title>The Feedback Loop That AI Can&#39;t Replace</title>
      <pubDate>Thu, 15 Jan 2026 17:00:00 +0100</pubDate>
      <description>In the first part of this series, we established that AI-generated code without understanding creates an illusion of productivity that collapses under production load. The differentiator isn&amp;rsquo;t typing speedâ€”it&amp;rsquo;s &lt;strong&gt;the feedback loop&lt;/strong&gt; where code meets reality and exposes incomplete thinking. But what exactly is this feedback loop, and why can&amp;rsquo;t AI replicate it? Modern compilers validate logical consistency, catching gaps pure thought leaves unresolved. Profilers expose the 75x performance difference between &amp;ldquo;seems reasonable&amp;rdquo; and &amp;ldquo;actually performs.&amp;rdquo; Production environments reveal every assumption abstract thinking deferredâ€”scale, concurrency, failure modes. This article explores the mechanisms that transform vague reasoning into concrete understanding: compilation validates logic instantly, testing catches behavioral mismatches, profiling measures what abstract analysis guesses, and production exposes the cost of every deferred decision. Real professionals don&amp;rsquo;t just write codeâ€”they master the iterative discipline of watching it fail, understanding why, and refining their thinking. AI participates in parts of this loop, but it can&amp;rsquo;t close it. That&amp;rsquo;s where professionals remain irreplaceable.</description>
      <category>ai-code-assistant</category>
      <category>architecture</category>
      <category>bestpractices</category>
      <category>codequality</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>github-copilot</category>
      <category>softwareengineering</category>
      <category>technicaldebt</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/kubernetes-not-platform-strategy/</guid>
      <link>https://daily-devops.net/posts/kubernetes-not-platform-strategy/</link>
      <title>Kubernetes Is Not a Platform Strategy</title>
      <pubDate>Tue, 13 Jan 2026 17:00:00 +0100</pubDate>
      <description>Kubernetes has become an assumed default in many organizations, positioned as a universal platform that absorbs governance, security, observability, and operational responsibility. This narrative is incomplete. Kubernetes is a powerful runtime orchestrator that solves one phase of the software lifecycle. Architectural risk, cost decisions, and operational failure occur elsewhere. A critical examination of where Kubernetes&amp;rsquo;s responsibility ends, and what remains the architect&amp;rsquo;s job.</description>
      <category>architecture</category>
      <category>cloudnative</category>
      <category>dotnet</category>
      <category>kubernetes</category>
      <category>platform-engineering</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/kehrwoche-technical-debt/</guid>
      <link>https://daily-devops.net/posts/kehrwoche-technical-debt/</link>
      <title>Kehrwoche: What Swabian Cleaning Teaches About Technical Debt</title>
      <pubDate>Fri, 09 Jan 2026 11:00:00 +0100</pubDate>
      <description>&lt;em&gt;Kehrwoche&lt;/em&gt;â€”a Swabian cleaning traditionâ€”is scarier than breaking the build on Friday afternoon. At least the build doesn&amp;rsquo;t remember next Tuesday. Mrs. Schmid from the second floor does, and she remembers well. What does a weekly cleaning schedule in southern Germany have to do with technical debt? More than most software teams want to admit.</description>
      <category>bestpractices</category>
      <category>codequality</category>
      <category>softwareengineering</category>
      <category>technicaldebt</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/alphabet-soup-file-formats/</guid>
      <link>https://daily-devops.net/posts/alphabet-soup-file-formats/</link>
      <title>Alphabet Soup: The Format Buffet Nobody Ordered</title>
      <pubDate>Thu, 08 Jan 2026 17:00:00 +0100</pubDate>
      <description>Developers wanted one format. We got twenty. CSV mangles data, XML drowns in tags, JSON forbids comments, YAML punishes spaces. TOML tried fixing it. TAML went minimal. TOON optimized for AI. CCL brought category theory. Result? Five formats per project, three parsers, and debugging why &lt;code&gt;NO&lt;/code&gt; became &lt;code&gt;false&lt;/code&gt;. AI can&amp;rsquo;t save us either. Welcome to format hell.</description>
      <category>bestpractices</category>
      <category>codequality</category>
      <category>configuration</category>
      <category>devops</category>
      <category>dotnet</category>
      <category>softwareengineering</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/code-sharpens-thinking/</guid>
      <link>https://daily-devops.net/posts/code-sharpens-thinking/</link>
      <title>Why Real Professionals Will Never Be Replaced by AI</title>
      <pubDate>Tue, 06 Jan 2026 17:00:00 +0100</pubDate>
      <description>The elephant everyone ignores: AI can generate code faster than you can type. GitHub Copilot autocompletes entire functions. ChatGPT builds APIs from prompts. Typing is dead. So why will real professionals never be replaced? Because &lt;strong&gt;&amp;ldquo;vibe coding&amp;rdquo;&lt;/strong&gt;â€”describe what you want, ship what AI generatesâ€”is a productivity illusion that collapses spectacularly in production. When code generation becomes trivial, understanding what that code costs, where it fails, why it breaks under load becomes everything. AI generates syntax. Professionals understand execution, failure modes, operational cost, and production consequences. The differentiator isn&amp;rsquo;t typing speedâ€”it&amp;rsquo;s mastering &lt;strong&gt;the feedback loop&lt;/strong&gt;: write code, watch it fail, understand why, refine thinking. This discipline can&amp;rsquo;t be automated. Prompt engineers generate code. Real professionals ensure it survives contact with reality.</description>
      <category>ai-code-assistant</category>
      <category>architecture</category>
      <category>bestpractices</category>
      <category>codequality</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>github-copilot</category>
      <category>softwareengineering</category>
      <category>technicaldebt</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/happy-new-year-2026/</guid>
      <link>https://daily-devops.net/posts/happy-new-year-2026/</link>
      <title>Most Software Teams Are Lying to Themselvesâ€”2026 Needs to Be Different</title>
      <pubDate>Thu, 01 Jan 2026 14:00:00 +0100</pubDate>
      <description>&lt;p&gt;&lt;em&gt;&lt;strong&gt;Happy New Year 2026! ðŸŽ‰&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Fix one piece of technical debt this weekâ€”not next quarter.
.NET 10, analyzers, and tests are ready; discipline is the only missing part.&lt;/p&gt;</description>
      <category>codequality</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>softwareengineering</category>
      <category>technicaldebt</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/dotnet-2025-year-in-review/</guid>
      <link>https://daily-devops.net/posts/dotnet-2025-year-in-review/</link>
      <title>2025 in Review: The Year .NET Stopped Lying to Itself</title>
      <pubDate>Tue, 30 Dec 2025 17:00:00 +0100</pubDate>
      <description>Forget the hypeâ€”2025 was when .NET tooling finally stopped pretending complexity doesn&amp;rsquo;t exist
Three tools won by being honest: Aspire exposed topology, TUnit killed flaky tests, Testcontainers made infrastructure real</description>
      <category>architecture</category>
      <category>aspire</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>opensource</category>
      <category>softwareengineering</category>
      <category>technicaldebt</category>
      <category>testing</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/dotnet-10-cli-devops/</guid>
      <link>https://daily-devops.net/posts/dotnet-10-cli-devops/</link>
      <title>.NET CLI 10 â€“ Microsoft Finally Realizes DevOps Exists</title>
      <pubDate>Thu, 25 Dec 2025 17:00:00 +0100</pubDate>
      <description>&lt;p&gt;The .NET CLI? Reliable. Boring. You run &lt;code&gt;dotnet build&lt;/code&gt;, &lt;code&gt;dotnet test&lt;/code&gt;, &lt;code&gt;dotnet publish&lt;/code&gt;, done. Real DevOps work happens in Dockerfiles, CI/CD configs, and specialized tools. The CLI does its job but was never built for actual operational workflows.&lt;/p&gt;
&lt;p&gt;.NET 10 changes this. Four additions that sound minor but fix real problems I&amp;rsquo;ve hit in production pipelines for years: native container publishing, ephemeral tool execution, better cross-platform packaging, and machine-readable schemas. Not flashy. Not keynote material. But they&amp;rsquo;re the kind of improvements that save hours every week once you&amp;rsquo;re running them at scale.&lt;/p&gt;
&lt;p&gt;Will they replace your current workflow? Depends on what you&amp;rsquo;re building. Let&amp;rsquo;s look at what actually changed.&lt;/p&gt;</description>
      <category>bestpractices</category>
      <category>cli</category>
      <category>csharp</category>
      <category>devops</category>
      <category>dotnet</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/dotnet-advanced-logging/</guid>
      <link>https://daily-devops.net/posts/dotnet-advanced-logging/</link>
      <title>Why Your Logging Strategy Fails in Production</title>
      <pubDate>Tue, 23 Dec 2025 17:00:00 +0100</pubDate>
      <description>&lt;p&gt;Let me tell you what I&amp;rsquo;ve learned over the years from watching teams deploy logging strategies that looked great on paper and failed spectacularly at 3 AM when production burned.&lt;/p&gt;
&lt;p&gt;It&amp;rsquo;s not that they didn&amp;rsquo;t know the theory. They&amp;rsquo;d read the Azure documentation. They&amp;rsquo;d seen the structured logging samples. They&amp;rsquo;d studied distributed tracing. The real problem was different: they knew &lt;em&gt;what&lt;/em&gt; to do but had no idea &lt;em&gt;why&lt;/em&gt; it mattered until production broke catastrophically.&lt;/p&gt;</description>
      <category>architecture</category>
      <category>bestpractices</category>
      <category>cloudnative</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>observability</category>
      <category>performance</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/dotnet-cli-expanding-scope-autocomplete/</guid>
      <link>https://daily-devops.net/posts/dotnet-cli-expanding-scope-autocomplete/</link>
      <title>Stop Typing: The .NET CLI Tab Completion You&#39;ve Been Missing</title>
      <pubDate>Thu, 18 Dec 2025 17:00:00 +0100</pubDate>
      <description>One command to transform your .NET CLI workflowâ€”tab completion so responsive you&amp;rsquo;ll wonder how you survived without it
Finally, a productivity boost that&amp;rsquo;s actually worth your time</description>
      <category>bestpractices</category>
      <category>cli</category>
      <category>devops</category>
      <category>dotnet</category>
      <category>softwareengineering</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/dotnet-job-scheduling-7-comparative-review/</guid>
      <link>https://daily-devops.net/posts/dotnet-job-scheduling-7-comparative-review/</link>
      <title>.NET Job Scheduling â€” Choosing the Right Framework</title>
      <pubDate>Tue, 16 Dec 2025 17:00:00 +0100</pubDate>
      <description>Synthesizing the series into actionable guidance with feature comparisons, suitability ratings, and decision frameworks.
Select the scheduler that matches your operational model, infrastructure constraints, and team priorities.</description>
      <category>architecture</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>nuget</category>
      <category>softwareengineering</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/dotnet-job-scheduling-6-tickerq/</guid>
      <link>https://daily-devops.net/posts/dotnet-job-scheduling-6-tickerq/</link>
      <title>.NET Job Scheduling â€” TickerQ and Modern Architecture</title>
      <pubDate>Thu, 11 Dec 2025 17:00:00 +0100</pubDate>
      <description>TickerQ represents the next generation of .NET schedulers with compile-time validation, reflection-free execution, and SignalR-powered monitoring.
Understand when modern architecture patterns and performance optimizations justify adopting newer frameworks over established alternatives.</description>
      <category>architecture</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>nuget</category>
      <category>softwareengineering</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/dotnet-power-of-ten-rules/</guid>
      <link>https://daily-devops.net/posts/dotnet-power-of-ten-rules/</link>
      <title>Power of Ten Rules: More Relevant Than Ever for .NET</title>
      <pubDate>Wed, 10 Dec 2025 16:45:00 +0100</pubDate>
      <description>&lt;p&gt;Gerard Holzmann&amp;rsquo;s Power of Ten rules prevented spacecraft failures and exposed Toyota&amp;rsquo;s fatal throttle bugs.
Four rules transfer directly to C# with superior enforcement. Three become irrelevant thanks to the managed runtime.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The verdict:&lt;/strong&gt; These principles aren&amp;rsquo;t just valid. They&amp;rsquo;re finally enforceable without heroic manual effort.&lt;/p&gt;</description>
      <category>bestpractices</category>
      <category>codequality</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>softwareengineering</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/aks-network-policies-zero-trust/</guid>
      <link>https://daily-devops.net/posts/aks-network-policies-zero-trust/</link>
      <title>AKS Network Policies: The Security Layer Your Cluster Is Missing</title>
      <pubDate>Wed, 10 Dec 2025 11:45:00 +0100</pubDate>
      <description>&lt;p&gt;Network segmentation is a fundamental security control for modern Kubernetes environments. AKS supports multiple networking models such as kubenet, Azure CNI, and overlay CNIs. The networking model matters, but the decisive factor for enforcing isolation and compliance is the consistent application of network policies.&lt;/p&gt;
&lt;p&gt;This article describes how network policies work in AKS, the available engines, practical examples, and recommended practices for enforcing a zero-trust posture within a cluster.&lt;/p&gt;</description>
      <category>azure</category>
      <category>cloud</category>
      <category>kubernetes</category>
      <category>networking</category>
      <category>platform-engineering</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/dotnet-job-scheduling-5-ncronjob/</guid>
      <link>https://daily-devops.net/posts/dotnet-job-scheduling-5-ncronjob/</link>
      <title>.NET Job Scheduling â€” NCronJob and Native Minimalism</title>
      <pubDate>Tue, 09 Dec 2025 17:00:00 +0100</pubDate>
      <description>NCronJob leverages IHostedService for lightweight scheduling with zero external dependencies.
Understand when minimal infrastructure and native ASP.NET Core integration outweigh advanced features for cloud-native architectures.</description>
      <category>architecture</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>nuget</category>
      <category>softwareengineering</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/dotnet-job-scheduling-4-coravel/</guid>
      <link>https://daily-devops.net/posts/dotnet-job-scheduling-4-coravel/</link>
      <title>.NET Job Scheduling â€” Coravel and Fluent Simplicity</title>
      <pubDate>Thu, 04 Dec 2025 17:00:00 +0100</pubDate>
      <description>Coravel prioritizes developer velocity with fluent APIs, zero infrastructure, and integrated features like queuing and caching.
Understand when convenience and rapid iteration trump persistence and clustering for practical application development.</description>
      <category>architecture</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>nuget</category>
      <category>softwareengineering</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/aks-networking-clash/</guid>
      <link>https://daily-devops.net/posts/aks-networking-clash/</link>
      <title>AKS Networking Clash: kubenet vs. CNI vs. CNI Overlay</title>
      <pubDate>Wed, 03 Dec 2025 11:45:00 +0100</pubDate>
      <description>&lt;p&gt;Selecting the right network model is arguably one of the most critical architectural decisions you will make when deploying a Kubernetes cluster on Azure Kubernetes Service (AKS). This choice ripples through nearly every aspect of your cluster&amp;rsquo;s lifecycle, influencing how pods communicate, how efficiently you use your IP address space, which Azure services integrate seamlessly with your workloads, and ultimately, how well your infrastructure scales to meet future demands. It affects scalability, security posture, operational cost, performance characteristics, available integration options, and your long-term operational flexibility.&lt;/p&gt;</description>
      <category>azure</category>
      <category>cloud</category>
      <category>kubernetes</category>
      <category>networking</category>
      <category>platform-engineering</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/dotnet-job-scheduling-3-quartznet/</guid>
      <link>https://daily-devops.net/posts/dotnet-job-scheduling-3-quartznet/</link>
      <title>.NET Job Scheduling â€” Quartz.NET for Enterprise Scale</title>
      <pubDate>Tue, 02 Dec 2025 17:00:00 +0100</pubDate>
      <description>Quartz.NET provides advanced scheduling semantics, database-backed clustering, and flexible storage for systems demanding complex workflows.
Understand when enterprise features justify operational complexity and how Quartz.NET scales across distributed deployments.</description>
      <category>architecture</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>nuget</category>
      <category>softwareengineering</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/dotnet-job-scheduling-2-hangfire/</guid>
      <link>https://daily-devops.net/posts/dotnet-job-scheduling-2-hangfire/</link>
      <title>.NET Job Scheduling â€” Hangfire and Persistent Reliability</title>
      <pubDate>Thu, 27 Nov 2025 17:00:00 +0100</pubDate>
      <description>Hangfire combines persistent job storage, automatic retries, and real-time monitoring to simplify background processing.
Learn when database-backed reliability matters and how Hangfire scales from single instances to distributed workers.</description>
      <category>architecture</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>nuget</category>
      <category>softwareengineering</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/dotnet-job-scheduling-1-landscape/</guid>
      <link>https://daily-devops.net/posts/dotnet-job-scheduling-1-landscape/</link>
      <title>.NET Job Scheduling â€” The Landscape</title>
      <pubDate>Tue, 25 Nov 2025 17:00:00 +0100</pubDate>
      <description>Explore the spectrum of .NET job scheduling from lightweight in-memory solutions to enterprise-grade distributed systems.
Understand which approach fits your operational model and why background processing architecture matters.</description>
      <category>architecture</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>nuget</category>
      <category>softwareengineering</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/healthchecks-5-0/</guid>
      <link>https://daily-devops.net/posts/healthchecks-5-0/</link>
      <title>NetEvolve.HealthChecks 5.0: 27+ Targeted Probes, Zero Boilerplate</title>
      <pubDate>Thu, 20 Nov 2025 23:00:00 +0100</pubDate>
      <description>&lt;p&gt;&lt;strong&gt;NetEvolve.HealthChecks 5.0 is a decisive expansionâ€”broader coverage scope, less boilerplate.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;New domainâ€‘specific packages extend monitoring across cloud services, messaging platforms, graph, timeâ€‘series, vector and AI backends. In parallel, the former inheritanceâ€‘driven shared base library (abstract classes + repetitive DI wiring) was replaced by purpose-built source generatorsâ€”removing manual registration churn and consolidating intent. Release 5.0 also formalizes full support for .NET 10â€”aligning with current trimming and analyzer improvements.&lt;/p&gt;</description>
      <category>csharp</category>
      <category>dotnet</category>
      <category>netevolve</category>
      <category>nuget</category>
      <category>performance</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/dotnet-10-testing/</guid>
      <link>https://daily-devops.net/posts/dotnet-10-testing/</link>
      <title>.NET 10 Testing: Microsoft Finally Fixed the Test Runner (Mostly)</title>
      <pubDate>Thu, 20 Nov 2025 17:00:00 +0100</pubDate>
      <description>.NET 10 replaces VSTest with &lt;code&gt;Microsoft.Testing.Platform&lt;/code&gt;, bringing SDK-integrated testing with faster discovery, consistent behavior across environments, and explicit configuration contracts. But it requires .NET 10, breaks old test adapters, and demands CI pipeline discipline. Here&amp;rsquo;s what actually changes, who should migrate now, and who should wait.</description>
      <category>csharp</category>
      <category>devops</category>
      <category>dotnet</category>
      <category>github-actions</category>
      <category>softwareengineering</category>
      <category>testing</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/code-metrics-configuration/</guid>
      <link>https://daily-devops.net/posts/code-metrics-configuration/</link>
      <title>Code Metrics and Configuration: Beyond the Numbers Game</title>
      <pubDate>Tue, 18 Nov 2025 17:00:00 +0100</pubDate>
      <description>&lt;p&gt;Code metrics have become a standard feature in modern development environments, yet their implementation and interpretation often leave much to be desired. While Visual Studio and .NET provide comprehensive code metrics analysis, the way these metrics are configured, presented, and (more critically) acted upon reveals a fundamental disconnect between measurement and meaningful improvement.&lt;/p&gt;
&lt;p&gt;What code metrics actually measure, how to configure them properly, and (more importantly) why blindly following thresholds without understanding context is, frankly, a recipe for misguided refactoring efforts that waste your team&amp;rsquo;s time and actively damage your codebase.&lt;/p&gt;</description>
      <category>bestpractices</category>
      <category>codequality</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>softwareengineering</category>
      <category>visualstudio</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/dotnet-10-released/</guid>
      <link>https://daily-devops.net/posts/dotnet-10-released/</link>
      <title>.NET 10: Boring by Design, Reliable by Default</title>
      <pubDate>Thu, 13 Nov 2025 18:00:00 +0100</pubDate>
      <description>&lt;p&gt;&lt;strong&gt;Microsoft wants you to believe .NET 10 is boring. They&amp;rsquo;re right â€” and that&amp;rsquo;s the best news we&amp;rsquo;ve had in years.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;.NET 10 is here, and for once, Microsoft didn&amp;rsquo;t oversell it. LTS support through 2028, JIT improvements that actually matter, and C# 14 features that won&amp;rsquo;t rewrite your architecture. Here&amp;rsquo;s what you need to know before migrating.&lt;/p&gt;</description>
      <category>architecture</category>
      <category>codequality</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>microsoft</category>
      <category>performance</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/timing-is-the-new-technical-debt/</guid>
      <link>https://daily-devops.net/posts/timing-is-the-new-technical-debt/</link>
      <title>.NET 10: Timing Is the New Technical Debt</title>
      <pubDate>Wed, 12 Nov 2025 18:00:00 +0100</pubDate>
      <description>2025 reshapes the .NET ecosystem with faster release cycles and shared responsibility. Discover why migrating to .NET 10 by Q1 2026 â€” and supporting your dependencies â€” turns timing into sustainable ROI.</description>
      <category>architecture</category>
      <category>bestpractices</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>performance</category>
      <category>technicaldebt</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/dotnet-10-release-cycle-paradox/</guid>
      <link>https://daily-devops.net/posts/dotnet-10-release-cycle-paradox/</link>
      <title>.NET 10 and the Release Cycle Paradox</title>
      <pubDate>Tue, 11 Nov 2025 16:30:00 +0100</pubDate>
      <description>&lt;p&gt;.NETâ€™s yearly rhythm has become a symbol of stability â€” yet also a source of pressure.
The &lt;strong&gt;release cycle paradox&lt;/strong&gt; describes the tension between predictability and exhaustion: a release schedule that keeps the ecosystem healthy, but teams constantly catching up.&lt;/p&gt;
&lt;p&gt;With .NET 10 on the horizon, developers must learn to navigate this rhythm rather than fight it.&lt;/p&gt;</description>
      <category>architecture</category>
      <category>bestpractices</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>softwareengineering</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/proper-use-of-targetframework-conditions/</guid>
      <link>https://daily-devops.net/posts/proper-use-of-targetframework-conditions/</link>
      <title>Stop Breaking Multi-Targeting Builds with String Comparisons</title>
      <pubDate>Thu, 06 Nov 2025 17:30:00 +0100</pubDate>
      <description>String-based TargetFramework conditions fail &lt;strong&gt;silently&lt;/strong&gt; in multi-targeting builds.
&lt;code&gt;IsTargetFrameworkCompatible()&lt;/code&gt; understands framework semantics and prevents production nightmares.</description>
      <category>bestpractices</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>msbuild</category>
      <category>softwareengineering</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/modern-defensive-programming/</guid>
      <link>https://daily-devops.net/posts/modern-defensive-programming/</link>
      <title>Modern Defensive Programming in .NET â€” Unified Throw-Helpers and Multi-Framework Compatibility</title>
      <pubDate>Mon, 03 Nov 2025 18:00:00 +0200</pubDate>
      <description>Modern .NET introduces powerful throw-helper methods such as &lt;code&gt;ArgumentNullException.ThrowIfNull&lt;/code&gt; and &lt;code&gt;ArgumentException.ThrowIfNullOrEmpty&lt;/code&gt; to simplify defensive programming.
However, many projects still target older frameworks where these APIs are missing.
This article explores how the &lt;strong&gt;NetEvolve.Arguments&lt;/strong&gt; library delivers a unified, backward-compatible API that brings modern guard clause patterns to every .NET version, ensuring consistent validation, maintainability, and multi-framework compatibility.</description>
      <category>csharp</category>
      <category>dotnet</category>
      <category>netevolve</category>
      <category>nuget</category>
      <category>softwareengineering</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/tests-are-lying/</guid>
      <link>https://daily-devops.net/posts/tests-are-lying/</link>
      <title>Your Tests Are Lying â€” Mutation Testing in .NET</title>
      <pubDate>Thu, 30 Oct 2025 18:00:00 +0200</pubDate>
      <description>&lt;p&gt;It begins like many stories in software: a well-intentioned developer joining a project, determined to do things properly. You arrive at a codebase that has grown organically, perhaps even chaotically. You decide you will bring order. You set up unit testing, you configure continuous integration, you measure code coverage. You write dozens or hundreds of tests. Every public method is touched, every branch is at least executed. The dashboard lights up green. You feel, quite frankly, on top of things.&lt;/p&gt;
&lt;p&gt;Then one day, &lt;strong&gt;production breaks under your watch&lt;/strong&gt;&lt;/p&gt;</description>
      <category>csharp</category>
      <category>dotnet</category>
      <category>nuget</category>
      <category>technicaldebt</category>
      <category>testing</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/nuget-packagedownload-functionality/</guid>
      <link>https://daily-devops.net/posts/nuget-packagedownload-functionality/</link>
      <title>PackageDownload: NuGet&#39;s Forgotten Power Tool</title>
      <pubDate>Wed, 29 Oct 2025 18:00:00 +0100</pubDate>
      <description>PackageDownload arrived in NuGet 4.8 to solve a niche but genuine problem: downloading packages without adding assembly references. It works. But its version syntax requirements and complete disregard for Central Package Management reveal the messy reality of platform evolution.</description>
      <category>bestpractices</category>
      <category>dependency-management</category>
      <category>dotnet</category>
      <category>msbuild</category>
      <category>nuget</category>
      <category>technicaldebt</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/netevolve-healthchecks/</guid>
      <link>https://daily-devops.net/posts/netevolve-healthchecks/</link>
      <title>Configuration-First Health Checks for Modern .NET</title>
      <pubDate>Tue, 28 Oct 2025 18:00:00 +0200</pubDate>
      <description>&lt;p&gt;Letâ€™s be honest: health checks are the broccoli of .NET projects. Everyone says they have them, but nobodyâ€™s excited to eat their greens. What starts as a humble &lt;code&gt;SELECT 1&lt;/code&gt; in a &lt;code&gt;try/catch&lt;/code&gt; quickly explodes into a wild jungle of scripts, copy-pasted connection strings, and endpoints that only half the team remembers. Sure, it worksâ€”until it doesnâ€™t. And when it breaks, itâ€™s never at a good time.&lt;/p&gt;</description>
      <category>csharp</category>
      <category>dotnet</category>
      <category>netevolve</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/compositeformat-performance-boost/</guid>
      <link>https://daily-devops.net/posts/compositeformat-performance-boost/</link>
      <title>Stop Parsing the Same String Twice: CompositeFormat in .NET</title>
      <pubDate>Thu, 23 Oct 2025 17:00:00 +0200</pubDate>
      <description>Every time you call &lt;code&gt;string.Format()&lt;/code&gt; with the same format string, .NET parses it again. And again. And again. CompositeFormat changes that: parse once, reuse forever. The result? Up to 30% faster formatting, fewer allocations, and a one-line code change. Here&amp;rsquo;s why this matters and how to use it.</description>
      <category>bestpractices</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>hidden-gems</category>
      <category>performance</category>
      <category>softwareengineering</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/searchvalues-saved-us-from-scaling-hell/</guid>
      <link>https://daily-devops.net/posts/searchvalues-saved-us-from-scaling-hell/</link>
      <title>How SearchValues&lt;T&gt; Saved Us From Scaling Hell</title>
      <pubDate>Mon, 20 Oct 2025 17:30:00 +0100</pubDate>
      <description>&lt;p&gt;While you&amp;rsquo;re busy optimizing database queries and adding cache layers, thousands of string searches per second are quietly eating your CPU budget. The problem isn&amp;rsquo;t visible in your APM dashboard because it&amp;rsquo;s distributed across every request. But it&amp;rsquo;s there. Compounding. Scaling linearly with load.&lt;/p&gt;
&lt;p&gt;I discovered this the hard way when a log processing API started choking under production traffic. The bottleneck? String validation and sanitization. The fix? A .NET 8 feature that delivered a &lt;strong&gt;5x performance improvement&lt;/strong&gt; and let us shut down servers instead of adding them. And it&amp;rsquo;s gotten even better in .NET 9 and 10.&lt;/p&gt;</description>
      <category>bestpractices</category>
      <category>codequality</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>hidden-gems</category>
      <category>performance</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/clean-code-lip-service-not-a-standard/</guid>
      <link>https://daily-devops.net/posts/clean-code-lip-service-not-a-standard/</link>
      <title>Clean Code: A Lip Service, Not a Standard</title>
      <pubDate>Thu, 16 Oct 2025 13:00:00 +0200</pubDate>
      <description>Clean Code is often praised but rarely practiced effectively. This article explores how misunderstood ideals and over-engineering harm .NET systems, how to recognize such failures early, and which C# best practices and official guidelines truly support maintainable software.</description>
      <category>bestpractices</category>
      <category>codequality</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>softwareengineering</category>
      <category>technicaldebt</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/constant-expected-attribute/</guid>
      <link>https://daily-devops.net/posts/constant-expected-attribute/</link>
      <title>ConstantExpectedAttribute: Unlocking Performance Through Compiler Awareness</title>
      <pubDate>Tue, 14 Oct 2025 14:30:00 +0200</pubDate>
      <description>The ConstantExpectedAttribute, introduced in .NET 7, provides a powerful mechanism to signal compiler expectations about constant values. This enables better performance optimizations, enhanced IDE tooling, and clearer API contracts. Learn how to leverage this attribute to build more efficient and maintainable .NET applications.</description>
      <category>bestpractices</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>performance</category>
      <category>softwareengineering</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/retiring-legacy-dotnet-projects/</guid>
      <link>https://daily-devops.net/posts/retiring-legacy-dotnet-projects/</link>
      <title>Retiring Legacy .NET Projects â€” Balancing Risk, Cost, and Forward Value</title>
      <pubDate>Mon, 13 Oct 2025 11:30:00 +0200</pubDate>
      <description>&lt;p&gt;In every mature .NET landscape, legacy projects represent both heritage and hazard.
They once powered entire business models â€” now they silently consume time, budget, and attention.
The decision to retire or modernize them isnâ€™t about technology fashion. Itâ€™s about sustaining the organizationâ€™s &lt;strong&gt;capacity for value creation&lt;/strong&gt;.&lt;/p&gt;</description>
      <category>architecture</category>
      <category>bestpractices</category>
      <category>dotnet</category>
      <category>rcda</category>
      <category>softwareengineering</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/tunit-a-pragmatic-evaluation-for-dotnet-teams/</guid>
      <link>https://daily-devops.net/posts/tunit-a-pragmatic-evaluation-for-dotnet-teams/</link>
      <title>TUnit â€” A Pragmatic Evaluation for .NET Teams</title>
      <pubDate>Thu, 09 Oct 2025 11:30:00 +0200</pubDate>
      <description>TUnit brings compile-time test discovery and native AOT support to .NET testing â€” but is it ready for enterprise adoption? A pragmatic analysis of performance gains, tooling maturity, and migration timing for teams evaluating alternatives to MSTest, xUnit, and NUnit.</description>
      <category>architecture</category>
      <category>bestpractices</category>
      <category>dotnet</category>
      <category>performance</category>
      <category>rcda</category>
      <category>softwareengineering</category>
      <category>testing</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/still-waiting-for-the-final-piece/</guid>
      <link>https://daily-devops.net/posts/still-waiting-for-the-final-piece/</link>
      <title>Still Waiting for the Final Piece: When C# 14 Comes Close, But Not Quite There</title>
      <pubDate>Mon, 06 Oct 2025 09:00:00 +0200</pubDate>
      <description>C# 14 introduces the new &amp;lsquo;Extension Everything&amp;rsquo; syntaxâ€”an elegant step toward more expressive code, yet one that still canâ€™t quite match VB.NETâ€™s classic ByRef magic. A humorous reflection on whatâ€™s almost, but not fully, possible in .NET 10.</description>
      <category>csharp</category>
      <category>dotnet</category>
      <category>extensions</category>
      <category>hidden-gems</category>
      <category>vbnet</category>
      <category>visualstudio</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/extended-dotnet-sts-support-timeframe/</guid>
      <link>https://daily-devops.net/posts/extended-dotnet-sts-support-timeframe/</link>
      <title>The Generous Gift? Microsoft Extends .NET STS Support to 24 Months</title>
      <pubDate>Tue, 30 Sep 2025 11:30:00 +0200</pubDate>
      <description>Microsoft has extended .NET STS support from 18 to 24 months. A genuine gift to developers or just catching up with reality? Let&amp;rsquo;s analyze what this means for your development planning.</description>
      <category>dotnet</category>
      <category>microsoft</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/dotnet10rc1-is-knocking-at-the-door/</guid>
      <link>https://daily-devops.net/posts/dotnet10rc1-is-knocking-at-the-door/</link>
      <title>.NET 10 RC 1 is Knocking at the Door: Architectural Impact, C# 14, and Performance</title>
      <pubDate>Wed, 10 Sep 2025 09:00:00 +0200</pubDate>
      <description>&lt;p&gt;.NETÂ 10 RCÂ 1 is knocking at the door, marking the first release candidate and offering the .NET community a detailed preview of whatâ€™s to come in the next LTS cycle. While not the final release, RCÂ 1 is &amp;ldquo;go-live&amp;rdquo; supported and represents the feature-complete platform that will soon become .NETÂ 10 LTS. In this article, Iâ€™ll try to give a rough overview of the architectural impact of .NETÂ 10 RCÂ 1, focusing on the latest C#Â 14 features, under-the-hood performance improvements, and strategic considerations for the upcoming LTS.&lt;/p&gt;</description>
      <category>architecture</category>
      <category>csharp</category>
      <category>dotnet</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/visual-studio-2026/</guid>
      <link>https://daily-devops.net/posts/visual-studio-2026/</link>
      <title>Visual Studio 2026 - Why AI-Native Tooling Will Matter</title>
      <pubDate>Wed, 10 Sep 2025 01:00:00 +0200</pubDate>
      <description>&lt;p&gt;Letâ€™s skip the typical release-cycle enthusiasm for a second: Most IDE updates come and go. New features, some refactoring helpers, a bit of polish, then back to business as usual. &lt;strong&gt;Visual Studio 2026 is different.&lt;/strong&gt; For once, the promise of &amp;ldquo;AI-native&amp;rdquo; isnâ€™t just marketing. If Microsoft lands even half of what theyâ€™re previewing, itâ€™s going to matterâ€”a lot.&lt;/p&gt;</description>
      <category>csharp</category>
      <category>dotnet</category>
      <category>visualstudio</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/buzzword-driven-development/</guid>
      <link>https://daily-devops.net/posts/buzzword-driven-development/</link>
      <title>Buzzword-Driven Development vs. Fundamental Software Quality</title>
      <pubDate>Wed, 23 Jul 2025 17:00:00 +0200</pubDate>
      <description>Explore why fundamental software quality practices in .NET must never be overlooked for trendy buzzwords, including recommended analyzers and project settings for managing technical debt effectively.</description>
      <category>ai-code-assistant</category>
      <category>bestpractices</category>
      <category>codequality</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>nuget</category>
      <category>softwareengineering</category>
      <category>technicaldebt</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/instruction-by-design/</guid>
      <link>https://daily-devops.net/posts/instruction-by-design/</link>
      <title>Instruction by Design: Transforming ADRs into Actionable AI Guidance</title>
      <pubDate>Tue, 15 Jul 2025 10:30:00 +0200</pubDate>
      <description>Discover how to transform architectural decision records (ADRs) into actionable, AI-ready guidance for teams and copilotsâ€”boosting consistency, onboarding, and automation in your development workflow.</description>
      <category>ai-code-assistant</category>
      <category>architecture</category>
      <category>bestpractices</category>
      <category>github</category>
      <category>github-copilot</category>
      <category>rcda</category>
      <category>softwareengineering</category>
      <category>technicaldebt</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/copilot-without-becoming-its-puppet/</guid>
      <link>https://daily-devops.net/posts/copilot-without-becoming-its-puppet/</link>
      <title>How to Use Copilot Without Becoming Its Puppet</title>
      <pubDate>Wed, 14 May 2025 17:30:00 +0200</pubDate>
      <description>&lt;p&gt;In a previous article, we laid it out â€“ unfiltered: &lt;strong&gt;Copilot turns junior devs into syntax secretaries.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Not because itâ€™s evil. But because it &lt;strong&gt;removes friction before understanding&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;It gives you working code before you know what &lt;em&gt;working&lt;/em&gt; even means. It creates the illusion of progress, while slowly eroding the very skills that define a software engineer: reasoning, decision-making, and technical ownership.&lt;/p&gt;</description>
      <category>ai-code-assistant</category>
      <category>bestpractices</category>
      <category>dotnet</category>
      <category>github</category>
      <category>github-copilot</category>
      <category>testing</category>
      <category>visualstudio</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/copilot-turns-junior-devs-into-syntax-secretaries/</guid>
      <link>https://daily-devops.net/posts/copilot-turns-junior-devs-into-syntax-secretaries/</link>
      <title>Copilot Turns Junior Devs Into Syntax Secretaries</title>
      <pubDate>Tue, 13 May 2025 17:30:00 +0200</pubDate>
      <description>&lt;p&gt;The hype around GitHub Copilot (or any other AI code assistant) is deafening. AI-assisted coding. Effortless automation. &lt;em&gt;&lt;strong&gt;10x productivity.&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;But hereâ€™s the harsh truth: &lt;strong&gt;Copilot isnâ€™t empowering junior developers â€“ itâ€™s deskilling them.&lt;/strong&gt;&lt;/p&gt;</description>
      <category>ai-code-assistant</category>
      <category>bestpractices</category>
      <category>dotnet</category>
      <category>github</category>
      <category>github-copilot</category>
      <category>testing</category>
      <category>visualstudio</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/vibe-coding-isnt-wrong-its-unfinished/</guid>
      <link>https://daily-devops.net/posts/vibe-coding-isnt-wrong-its-unfinished/</link>
      <title>Vibe Coding in .NET: Creative Catalyst or Maintenance Risk?</title>
      <pubDate>Wed, 07 May 2025 12:00:00 +0200</pubDate>
      <description>&lt;p&gt;In the world of software development, thereâ€™s a recurring tension between &lt;strong&gt;discipline and improvisation&lt;/strong&gt;. Somewhere along that spectrum lies a phenomenon increasingly referred to as &lt;strong&gt;Vibe Coding&lt;/strong&gt;. The term evokes a style of development where engineers follow intuition and momentum rather than formal plans, processes, or design patterns.&lt;/p&gt;
&lt;p&gt;Itâ€™s fast, fluid, and occasionally brilliant. But is it sustainable in a .NET-based enterprise context?&lt;/p&gt;</description>
      <category>bestpractices</category>
      <category>codequality</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>softwareengineering</category>
      <category>technicaldebt</category>
      <category>testing</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/understanding-csharp-stringvalues/</guid>
      <link>https://daily-devops.net/posts/understanding-csharp-stringvalues/</link>
      <title>Understanding the C# `StringValues`: A Comprehensive Guide</title>
      <pubDate>Mon, 30 Dec 2024 16:00:00 +0100</pubDate>
      <description>&lt;p&gt;In C#, the &lt;code&gt;StringValues&lt;/code&gt; struct belongs to the &lt;code&gt;Microsoft.Extensions.Primitives&lt;/code&gt; namespace, which is widely used in modern .NET applications. This struct plays a crucial role in efficiently managing string collections, especially when handling efficiently, particularly in contexts where multiple strings are involved. In this blog post, weâ€™ll explore the purpose, usage, and key features of the &lt;code&gt;StringValues&lt;/code&gt; struct in C#.&lt;/p&gt;</description>
      <category>csharp</category>
      <category>dotnet</category>
      <category>hidden-gems</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/managing-errors-warnings-and-configurations/</guid>
      <link>https://daily-devops.net/posts/managing-errors-warnings-and-configurations/</link>
      <title>Managing Errors, Warnings, and Configurations in C# and .NET</title>
      <pubDate>Mon, 23 Dec 2024 16:00:00 +0100</pubDate>
      <description>&lt;p&gt;When we activated static code analysis for the first time in one of my last projects, the overwhelming number of warnings exceeded expectations and highlighted gaps in the code. Without making any changes, the project already had a &lt;strong&gt;significant number of warnings&lt;/strong&gt;. After activating additional analyzers and updating some configurations, this number &lt;strong&gt;temporarily increased dramatically&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;The high number of warnings was initially daunting, but we saw it as an opportunity to significantly improve our code quality. At first glance, it seemed easier to suppress or ignore these warnings. But as I often remind my team, &lt;strong&gt;&amp;ldquo;The code you create is a valuable legacy, so it&amp;rsquo;s important to build it carefully.&amp;rdquo;&lt;/strong&gt; Ignoring warnings today creates obstacles for future developersâ€”and that could very well include you six months down the line.&lt;/p&gt;
&lt;p&gt;This experience reinforced the importance of managing warnings and errors systematically. Let me share some of the lessons we learned, the strategies we used to tame those 60,000 warnings, and how you can apply these techniques to your own projects.&lt;/p&gt;</description>
      <category>bestpractices</category>
      <category>codequality</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>msbuild</category>
      <category>softwareengineering</category>
      <category>technicaldebt</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/tale-of-forgotten-pennies-and-lost-dollars/</guid>
      <link>https://daily-devops.net/posts/tale-of-forgotten-pennies-and-lost-dollars/</link>
      <title>A Tale of Forgotten Pennies and Lost Dollars</title>
      <pubDate>Fri, 22 Nov 2024 16:45:00 +0100</pubDate>
      <description>&lt;p&gt;In software development, thereâ€™s a silent debt that accrues interest over time, often hidden beneath layers of code and decisions made in haste or ignorance. This debt is aptly termed &lt;em&gt;technical debt&lt;/em&gt;. Much like the german proverb, &lt;em&gt;&amp;ldquo;Wer den Pfennig nicht ehrt, ist den Taler nicht wert&amp;rdquo;,&lt;/em&gt; (or the english equivalent, &lt;em&gt;&amp;ldquo;A penny saved is a penny earned&amp;rdquo;&lt;/em&gt;) technical debt reminds us that small oversights or compromises in the present can snowball into significant challenges down the road. This article critically examines the parallels between financial principles and technical debt, emphasizing the importance of addressing both direct and indirect debt while understanding its distinction from external risks such as hacking or abuse.&lt;/p&gt;</description>
      <category>bestpractices</category>
      <category>dependency-management</category>
      <category>rcda</category>
      <category>softwareengineering</category>
      <category>technicaldebt</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/dependamerge-action/</guid>
      <link>https://daily-devops.net/posts/dependamerge-action/</link>
      <title>Master dependency management with automation: story behind `dependamerge`</title>
      <pubDate>Wed, 13 Nov 2024 09:00:00 +0100</pubDate>
      <description>&lt;p&gt;In software development, dependencies are inevitable - any project worth its salt relies on various libraries, frameworks, or packages. However, as I found in my own work, managing these dependencies can be an onerous task. Constant updates, new vulnerabilities, and endless manual approvals were draining my time and focus. What if, I thought, these processes could be automated? This thought led to the creation of &lt;code&gt;dependamerge&lt;/code&gt;, a GitHub Action designed to free developers from the drudgery of manual dependency maintenance and let us get back to what we do best: building great software.&lt;/p&gt;</description>
      <category>bestpractices</category>
      <category>dependency-management</category>
      <category>github</category>
      <category>github-actions</category>
      <category>nuget</category>
      <category>technicaldebt</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/introducing-nullability-in-legacy-code/</guid>
      <link>https://daily-devops.net/posts/introducing-nullability-in-legacy-code/</link>
      <title>Gradually Introducing Nullability in Legacy Code: A Practical Guide for .NET and C#</title>
      <pubDate>Mon, 07 Oct 2024 17:15:00 +0200</pubDate>
      <description>&lt;p&gt;As developers, weâ€™re often tasked with maintaining and modernizing legacy codebases that were written long before some of the best practices of todayâ€”such as nullability annotationsâ€”were available. While modern C# now supports nullable reference types, enabling us to avoid the dreaded &lt;code&gt;NullReferenceException&lt;/code&gt;, introducing this feature to existing, large codebases can be a challenge.&lt;/p&gt;
&lt;p&gt;In this article, Iâ€™ll share my step-by-step approach for introducing nullability into a legacy .NET and C# project. Youâ€™ll learn how to apply nullability in a controlled, incremental manner using project-level settings, scoped annotations, and file/method-level directives, all while maintaining the integrity of your legacy codebase. After all, modernizing your code doesnâ€™t have to be an all-or-nothing endeavorâ€”gradual change is key to a successful transition. Letâ€™s get started!&lt;/p&gt;</description>
      <category>bestpractices</category>
      <category>codequality</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>softwareengineering</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/buildinginsidevisualstudio/</guid>
      <link>https://daily-devops.net/posts/buildinginsidevisualstudio/</link>
      <title>Mastering .NET Project Properties: The `BuildingInsideVisualStudio` Flag</title>
      <pubDate>Tue, 10 Sep 2024 17:00:00 +0200</pubDate>
      <description>&lt;p&gt;In the ever-evolving world of .NET development, managing project configurations effectively is crucial for maintaining a clean and efficient build process. One of the less frequently discussed but highly useful properties is &lt;code&gt;BuildingInsideVisualStudio&lt;/code&gt;. This property, when correctly utilized, can streamline your build process and ensure that your project is configured properly depending on the build environment. In this article, we&amp;rsquo;ll explore the &lt;code&gt;BuildingInsideVisualStudio&lt;/code&gt; property with concrete examples and discuss best practices for using it effectively.&lt;/p&gt;</description>
      <category>bestpractices</category>
      <category>csharp</category>
      <category>dotnet</category>
      <category>hidden-gems</category>
      <category>msbuild</category>
      <category>visualstudio</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/reimagining-the-microsoft-certification-exam-ui/</guid>
      <link>https://daily-devops.net/posts/reimagining-the-microsoft-certification-exam-ui/</link>
      <title>Reimagining the Microsoft Certification Exam UI Experience</title>
      <pubDate>Thu, 14 Mar 2024 09:00:00 +0100</pubDate>
      <description>Embark on a journey through Microsoft&amp;rsquo;s redesigned certification exam UI. Discover streamlined navigation, enhanced accessibility, and personalized experiences, revolutionizing the exam-taking experience.</description>
      <category>azure</category>
      <category>certification</category>
      <category>microsoft</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/manage-nuget-packages-centrally/</guid>
      <link>https://daily-devops.net/posts/manage-nuget-packages-centrally/</link>
      <title>Manage NuGet Packages Centrally</title>
      <pubDate>Mon, 17 Apr 2023 08:30:00 +0200</pubDate>
      <description>&lt;p&gt;For over 12 years, NuGet package management has been part of the .NET ecosystem with direct integrations to various IDEs, CLIs and build systems. But a feature took 12 years before it appeared and certainly needs some more maintenance until it is mature!&lt;/p&gt;</description>
      <category>bestpractices</category>
      <category>csharp</category>
      <category>dependency-management</category>
      <category>dotnet</category>
      <category>hidden-gems</category>
      <category>nuget</category>
      <category>technicaldebt</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/illuminate-technical-debt/</guid>
      <link>https://daily-devops.net/posts/illuminate-technical-debt/</link>
      <title>Illuminate Technical Debt</title>
      <pubDate>Wed, 12 Apr 2023 17:00:00 +0200</pubDate>
      <description>&lt;p&gt;Whatever our role, be it developer, IT professional or architect, we try to avoid technical debt. If this is not possible from the outset, or if we decide to accept this technical debt for a limited period of time, we usually lack the tools to do so. This is where this article may help.&lt;/p&gt;</description>
      <category>azuredevops</category>
      <category>extensions</category>
      <category>rcda</category>
      <category>technicaldebt</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/when-can-i-finally-renew-my-microsoft-certification/</guid>
      <link>https://daily-devops.net/posts/when-can-i-finally-renew-my-microsoft-certification/</link>
      <title>When Can I Finally Renew My Microsoft Certification</title>
      <pubDate>Tue, 11 Apr 2023 09:00:00 +0200</pubDate>
      <description>&lt;p&gt;&lt;em&gt;When can I finally renew my Microsoft certification?&lt;/em&gt; - I&amp;rsquo;m certainly not alone with this or similar questions and the associated uncertainty. Okay, a certain impatience certainly resonates as well. After all, I would also like to schedule it into my daily routine. But how?&lt;/p&gt;</description>
      <category>azure</category>
      <category>certification</category>
      <category>microsoft</category>
    </item>
    <item>
      <guid isPermaLink="true">https://daily-devops.net/posts/how-to-prepare-for-microsoft-certification/</guid>
      <link>https://daily-devops.net/posts/how-to-prepare-for-microsoft-certification/</link>
      <title>How to Prepare for Microsoft Certification</title>
      <pubDate>Fri, 27 Jan 2023 21:00:00 +0100</pubDate>
      <description>&lt;p&gt;&lt;em&gt;How do I best prepare for a Microsoft certification?&lt;/em&gt; - this or a similar question is asked by everyone who wants to deal with the topics Microsoft, Azure, Microsoft 365, Power Platform or Dynamics 365. In this article, I would like to go into the possibilities that Microsoft offers us for preparation.&lt;/p&gt;</description>
      <category>azure</category>
      <category>certification</category>
      <category>microsoft</category>
    </item>
  </channel>
</rss>
